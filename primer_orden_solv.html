<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Resolución en Lógica de primer orden - Apunte Final Paradigmas de Lenguajes de Programación 2024</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./custom.css">
        <link rel="stylesheet" href="./mdbook-admonish.css">
        <link rel="stylesheet" href="theme/pagetoc.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="unidad_1.html"><strong aria-hidden="true">1.</strong> Unidad 1 - Programación Funcional Con Haskell</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="programacion_funcional.html"><strong aria-hidden="true">1.1.</strong> Intro a Haskell</a></li><li class="chapter-item expanded "><a href="esquemas_de_recursion.html"><strong aria-hidden="true">1.2.</strong> Esquemas de recursión</a></li></ol></li><li class="chapter-item expanded "><a href="unidad_2.html"><strong aria-hidden="true">2.</strong> Unidad 2 - Cálculo Lambda</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lambda_calc_booleano.html"><strong aria-hidden="true">2.1.</strong> Cálculo Lambda Tipado Booleano</a></li><li class="chapter-item expanded "><a href="lambda_calc_extendido.html"><strong aria-hidden="true">2.2.</strong> Cálculo Lambda Tipado Extendido</a></li><li class="chapter-item expanded "><a href="inferencia_de_tipos.html"><strong aria-hidden="true">2.3.</strong> Inferencia de tipos</a></li><li class="chapter-item expanded "><a href="subtipado.html"><strong aria-hidden="true">2.4.</strong> Subtipado</a></li></ol></li><li class="chapter-item expanded "><a href="unidad_3.html"><strong aria-hidden="true">3.</strong> Unidad 3 - Paradigma de Objetos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="javascript_intro.html"><strong aria-hidden="true">3.1.</strong> Intro a POO</a></li><li class="chapter-item expanded "><a href="sigma_calc.html"><strong aria-hidden="true">3.2.</strong> Cálculo Sigma</a></li></ol></li><li class="chapter-item expanded "><a href="unidad_4.html"><strong aria-hidden="true">4.</strong> Unidad 4 - Programación Lógica</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="prop_solv.html"><strong aria-hidden="true">4.1.</strong> Resolución Proposicional</a></li><li class="chapter-item expanded "><a href="primer_orden_solv.html" class="active"><strong aria-hidden="true">4.2.</strong> Resolución en Lógica de primer orden</a></li><li class="chapter-item expanded "><a href="sld_solv.html"><strong aria-hidden="true">4.3.</strong> Resolución SLD</a></li><li class="chapter-item expanded "><a href="prolog.html"><strong aria-hidden="true">4.4.</strong> Prolog</a></li></ol></li><li class="chapter-item expanded "><a href="practicas.html"><strong aria-hidden="true">5.</strong> Prácticas</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="guia_0.html"><strong aria-hidden="true">5.1.</strong> Guia 0 - Repaso Haskell</a></li><li class="chapter-item expanded "><a href="guia_1.html"><strong aria-hidden="true">5.2.</strong> Guia 1 - Programación funcional</a></li><li class="chapter-item expanded "><a href="guia_2.html"><strong aria-hidden="true">5.3.</strong> Guia 2 - Cálculo Lambda Tipado</a></li><li class="chapter-item expanded "><a href="guia_3.html"><strong aria-hidden="true">5.4.</strong> Guia 3 - Inferencia de Tipos</a></li><li class="chapter-item expanded "><a href="guia_4.html"><strong aria-hidden="true">5.5.</strong> Guia 4 - Subtipado</a></li><li class="chapter-item expanded "><a href="guia_5.html"><strong aria-hidden="true">5.6.</strong> Guia 5 - Programación Orientada a Objetos</a></li><li class="chapter-item expanded "><a href="guia_6.html"><strong aria-hidden="true">5.7.</strong> Guia 6 - Resolución Lógica</a></li><li class="chapter-item expanded "><a href="guia_7.html"><strong aria-hidden="true">5.8.</strong> Guia 7 - Programación Lógica</a></li></ol></li><li class="chapter-item expanded "><a href="bibliografía.html"><strong aria-hidden="true">6.</strong> Bibliografía</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Apunte Final Paradigmas de Lenguajes de Programación 2024</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main><div class="sidetoc"><nav class="pagetoc"></nav></div>
                        <p>$$
\newcommand{\true}{\mathbf{T}}
\newcommand{\false}{\mathbf{F}}
\newcommand{\satisf}{\models}
\newcommand{\notsatisf}{\nvDash}
\newcommand{\set}[1]{\lbrace #1 \rbrace}
$$</p>
<h1 id="repaso-lógica-de-primer-orden"><a class="header" href="#repaso-lógica-de-primer-orden">Repaso: Lógica de primer orden</a></h1>
<h2 id="lenguaje-de-primer-orden"><a class="header" href="#lenguaje-de-primer-orden">Lenguaje de primer orden</a></h2>
<p>Un <strong>lenguaje de primer orden (LPO)</strong> \(\mathcal{L}\) consiste en:</p>
<ol>
<li>Un conjunto numerable de <strong>constantes</strong> \(c_0, c_1, \dots\)</li>
<li>Un conjunto numerable de símbolos de <strong>función con aridad</strong> \(n &gt; 0\) (indica el nro de argumentos) \(f_0, f_1, \dots\)</li>
<li>Un conjunto numerable de símbolos de <strong>predicado con aridad</strong> \(n \geq 0\), \(P_0, P_1, \dots\)</li>
</ol>
<p>Por ejemplo, un lenguaje de primer orden para la aritmética sería:</p>
<ul>
<li>constantes: \(0\),</li>
<li>Símbolos de función: \(S, +, *\)</li>
<li>Símbolos de predicado: \(&lt;, =\)</li>
</ul>
<h2 id="términos-de-primer-orden"><a class="header" href="#términos-de-primer-orden">Términos de primer orden</a></h2>
<p>Los definimos de forma inductiva. Dado un conjunto de variables \(\mathcal{V} = \set{x_0, x_1, \dots}\) y \(\mathcal{L}\) un LPO. El conjunto de \(\mathcal{L}\)-términos se define como:</p>
<ol>
<li>Toda constante de \(\mathcal{L}\) y toda variable es un \(\mathcal{L}\)-término.</li>
<li>Si \(t_1, \dots, t_n \in \mathcal{L}\)-términos y \(f\) es un símbolo de función de aridad \(n\), entonces \(f(t_1, \dots, t_n) \in \mathcal{L}\)-términos.</li>
</ol>
<p>Siguiendo con el ejemplo de la aritmética, tendríamos los términos \(S(0), +(S(0), S(S(0))), *(S(x_1), +(x_2, S(x_3)))\)</p>
<h2 id="fórmulas-atómicas"><a class="header" href="#fórmulas-atómicas">Fórmulas atómicas</a></h2>
<p>Lo mismo que antes pero para predicados:</p>
<ol>
<li>Todo símbolo de predicado de aridad 0 es una \(\mathcal{L}\)-fórmula atómica.</li>
<li>Si \(t_1, \dots, t_n \in \mathcal{L}\)-términos y \(P\) es un símbolo de predicado de aridad \(n\), entonces \(f(t_1, \dots, t_n) \in \mathcal{L}\)-fórmulas atómicas.</li>
</ol>
<p>Again, tomando a la aritmética tendríamos por ejemplo \(&lt;(0, S(0)), &lt;(x_1, +(S(0), x_2))\)</p>
<h2 id="fórmulas-de-primer-orden"><a class="header" href="#fórmulas-de-primer-orden">Fórmulas de primer orden</a></h2>
<p>Dado un conjunto numerable de variables \(\mathcal{V}\) y \(\mathcal{L}\) un LPO. El conjunto de \(\mathcal{L}\)-fórmulas se define como:</p>
<ol>
<li>Toda \(\mathcal{L}\)-fórmula atómica es una \(\mathcal{L}\)-fórmula.</li>
<li>Si \(A, B \in \mathcal{L}\)-fórmulas, entonces \((A \land B), (A \lor B), (A \supset B), (A \iff B) y \neg A\) son \(\mathcal{L}\)-fórmulas.</li>
<li>(cuantificadores) Para toda variable \(x_i\), y cualquier \(\mathcal{L}\)-fórmula A, \(\forall x_i.A\) y \(\exists x_i.A\) son \(\mathcal{L}\)-fórmulas</li>
</ol>
<p>De vuelta pensando en la aritmética, tendríamos por ejemplo \(\forall x. \forall y. (x &lt; y \supset \exists z. y = x + z)\)</p>
<h2 id="variables-libres-y-ligadas"><a class="header" href="#variables-libres-y-ligadas">Variables libres y ligadas</a></h2>
<ul>
<li>Los cuantificadores ligan variables</li>
<li>Usamos \(FV(A)\) y \(BV(A)\) para referirnos a las variables libres y ligadas de \(A\) (F de free, B de bounded).</li>
<li>\(FV(A)\) y \(BV(A)\) se pueden definir por inducción estructural (La noción es la misma que la que vimos para cálculo sigma o cálculo lambda, salvo que ahora estamos trabajando con el lenguaje del cálculo de primer orden).</li>
</ul>
<p>Decimos que una fórmula está <strong>rectificada</strong> si</p>
<ul>
<li>Su conjunto de variables libres y ligadas es disjunto (o sea no hay confución
de qué es libre y qué ligado).</li>
<li>Cuantifictintasadores distintos de la fórmula ligan variables dis</li>
</ul>
<blockquote>
<p>Detalle no menor: toda fórmula se puede <strong>rectificar</strong> a una fórmula
lógicamente equivalente (similar a lo que hicimos cuando vimos lambda
cálculo).</p>
</blockquote>
<h2 id="sentencias"><a class="header" href="#sentencias">Sentencias</a></h2>
<p>Una <strong>sentencia</strong> es una fórmula cerrada.</p>
<ul>
<li>muchos de los resultados se formulan para sentencias</li>
<li>esto no suele tener pérdida de generalidad porque toda fórmula es lógicamente equivalente a su <strong>clausura universal</strong>.</li>
</ul>
<div id="admonition-clausura-universal" class="admonition admonish-info">
<div class="admonition-title">
<p>Clausura universal</p>
<p><a class="admonition-anchor-link" href="#admonition-clausura-universal"></a></p>
</div>
<div>
<p>La clausura universal es aquella que tiene que tiene cuantificadores al principio para todas sus variables. Ej:</p>
<p>$$
\forall x. \forall y. P(x, y) \iff P(x, y)
$$</p>
</div>
</div>
<h2 id="semántica"><a class="header" href="#semántica">Semántica</a></h2>
<h3 id="estructura-de-primer-orden"><a class="header" href="#estructura-de-primer-orden">Estructura de primer orden</a></h3>
<p>La estructura viene a ser una forma de darle significado a nuestra lógica para
que las constantes correspondan a constantes, los símbolos de función a
funciones que corresponden a cierto dominio y a los predicados a predicados
booleanos definidos sobre un dominio.</p>
<p>Para un LPO \(\mathcal{L}\), una estructura para \(\mathcal{L}\), \(\mathbf{M}\) es un par \(\mathbf{M} = (M, I)\) donde:</p>
<ul>
<li>\(M\) (el dominio) es un conjunto no vacío</li>
<li>\(I\) (la función de interpretación) asigna funciones y predicados sobre el dominio \(M\) a símbolos de \(\mathcal{L}\) de la siguiente manera:
<ol>
<li>para toda constante \(c\), \(I(c) \in M\)</li>
<li>para toda \(f\) de aridad \(n &gt; 0\), \(I(f): M^n \rightarrow M\)</li>
<li>para todo predicado \(P\) de aridad \(n \geq 0\), \(I(P) : M^n \rightarrow \set{\true, \false}\)</li>
</ol>
</li>
</ul>
<h3 id="satisfactibilidad"><a class="header" href="#satisfactibilidad">Satisfactibilidad</a></h3>
<div id="admonition-asignación" class="admonition admonish-info">
<div class="admonition-title">
<p>Asignación</p>
<p><a class="admonition-anchor-link" href="#admonition-asignación"></a></p>
</div>
<div>
<p>Para hablar de satisfactibilidad como lo hicimos para la lógica proposicional,
tenemos que hablar antes de las asignaciones. Dada \(\mathbf{M}\) una
estructura para \(\mathcal{L}\), una <strong>asignación</strong> es una función \(s : \mathcal{V} \rightarrow M\).</p>
<p>Si \(a \in M\), usamos la notación \(s[x \leftarrow a]\) para denotar la
asignación que es igual a \(s\) salvo que para \(x\) devuelve \(a\)</p>
</div>
</div>
<p>La relación \( s \satisf_{\mathbf{M}} A\) establece que la asignación \(s\) satisface la fórmula \(A\) bajo la estructura \(\mathbf{M}\). Vamos a definirla de forma informal usando inducción estructural:</p>
<p>$$
\begin{align}
s \satisf_{\mathbf{M}} P(t_1, \dots, t_n) &amp;\text{sii} P(s(t_1), \dots, s(t_n)) \\
s \satisf_{\mathbf{M}} \neg A &amp;\text{ sii } s \notsatisf_{\mathbf{M}} A \\
s \satisf_{\mathbf{M}} (A \land B) &amp;\text{ sii } s \satisf_{\mathbf{M}} A \text{ y } s \satisf_{\mathbf{M}} B \\
s \satisf_{\mathbf{M}} (A \lor B) &amp;\text{ sii } s \satisf_{\mathbf{M}} A \text{ o } s \satisf_{\mathbf{M}} B \\
s \satisf_{\mathbf{M}} (A \supset B) &amp;\text{ sii } s \notsatisf_{\mathbf{M}} A \text{ o } s \satisf_{\mathbf{M}} B \\
s \satisf_{\mathbf{M}} (A \iff B) &amp;\text{ sii } (s \satisf_{\mathbf{M}} A \text{ sii } s \satisf_{\mathbf{M}} B) \\
s \satisf_{\mathbf{M}} \forall x_i. A &amp;\text{ sii } s[x_i \leftarrow a] \satisf_{\mathbf{M}} A \text{ para todo } a \in M \\
s \satisf_{\mathbf{M}} \exists x_i. A &amp;\text{ sii } s[x_i \leftarrow a] \satisf_{\mathbf{M}} A \text{ para algún } a \in M
\end{align}
$$</p>
<h3 id="validez"><a class="header" href="#validez">Validez</a></h3>
<p>Una fórmula \(A\) es <strong>satisfacible en</strong> \(\mathbf{M}\) sii existe una asignación \(s\) tal que</p>
<p>$$
s \satisf_{\mathbf{M}} A
$$</p>
<p>Ahora, si no fijamos el \(\mathbf{M}\), una fórmula \(A\) <strong>es satisfactible</strong> (a secas) sii existe un \(\mathbf{M}\) tal que \(A\) es satisfactible en \(\mathbf{M}\). En caso contrario decimos que es <strong>insatisfactible</strong>.</p>
<p>Por último, decimos que una fórmula \(A\) es <strong>válida en</strong> \(\mathbf{M}\) (fijado el M, es tautología) sii</p>
<p>$$
s \satisf_{\mathbf{M}} A, \text{ para toda asignación } s
$$</p>
<blockquote>
<p><strong>Obs</strong>: \(A\) es válida sii \(\neg A\) es insatisfactible.</p>
</blockquote>
<div id="admonition-teorema-de-church" class="admonition admonish-info">
<div class="admonition-title">
<p>Teorema de Church</p>
<p><a class="admonition-anchor-link" href="#admonition-teorema-de-church"></a></p>
</div>
<div>
<p><strong>No existe</strong> un algoritmo que pueda determinar si una fórmula de primer orden es válida.</p>
<p><img src="./img/ohno.png#center" alt="" /></p>
<p>O sea que sonamos? Bueno no, a medias.</p>
<ul>
<li>El método de resolución que vamos a ver <strong>no es un procedimiento efectivo</strong>,</li>
<li>Es un problema de <strong>semi-decisión</strong>. Vamos a lograr que
<ul>
<li>si una sentencia es insatisfactible, encuentro una refutación.</li>
<li>pero si es satisfactible puede no terminar.</li>
</ul>
</li>
</ul>
</div>
</div>
<h1 id="resolución-en-lógica-de-primer-orden"><a class="header" href="#resolución-en-lógica-de-primer-orden">Resolución en lógica de primer orden</a></h1>
<p>Vamos a aplicar la misma idea del método de resolución que aplicamos para
proposicional, pero ahora para primer orden. Eso si, como el lenguaje es más
complicado que lógica proposicional vamos a tener que aplicar un par de pasos
extra.</p>
<h2 id="forma-normal-clausal"><a class="header" href="#forma-normal-clausal">Forma <del>Normal</del> Clausal</a></h2>
<p>Al igual que para proposicional queremos que nuestra fórmula tenga cierta pinta
para que sea más fácil trabajar con ella. La diferencia es que en este caso
tenemos más lenguaje (sobre todo tenemos que incorporar el uso de
cuantificadores).</p>
<p>Para pasar a forma clausal tenemos que pasar por varios pasos intermedios:</p>
<ol>
<li>Re-escribir la fórmula en términos de \(\land, \lor, \neg, \forall, \exists\)
<ul>
<li>termina siendo eliminar el implica (P =&gt; Q === -P v Q).</li>
</ul>
</li>
<li>Pasar a <strong>forma normal negada</strong></li>
<li>Pasar a <strong>forma normal prenexa</strong> (opcional)</li>
<li>Pasar a <strong>forma normal de Skolem</strong></li>
<li>Pasar matriz a forma normal conjuntiva</li>
<li>Distribuir los cuantificadores universales</li>
</ol>
<p>Veamos paso por paso.</p>
<h3 id="forma-normal-negada"><a class="header" href="#forma-normal-negada">Forma normal negada</a></h3>
<p>Una forma normal negada es una forma en donde lo que queremos es que las negaciones aparezcan lo más adentro posible. Para eso podemos definir el conjunto de fórmulas que están en FNN inductivamente:</p>
<ol>
<li>Para cada fórmula atómica \(A\), \(A\) y \(\neg A\) están en \(FNN\).</li>
<li>Si \(A, B \in FNN\), entonces \((A \lor B), (A \land B)\) están en \(FNN\).</li>
<li>Si \(A \in FNN\), entonces \(\forall x.A, \exists x.A \in FNN\).</li>
</ol>
<p>Ejemplos:</p>
<ul>
<li>\(\neg \exists x.((P(x) \lor \exists y. R(x, y)) \supset (\exists z.R(x, z) \lor P(a)))\) no está en FNN porque el existencial no es una fórmula atómica por lo tanto ni 1, ni 2, ni 3 aplican.</li>
<li>\(\forall x.((P(x) \lor \exists y. R(x, y)) \land (\forall z. \neg R(x, z) \land \neg P(a)))\) si lo está
<ul>
<li>notar que es lógicamente equivalente a la primera pero convertida a FNN</li>
</ul>
</li>
</ul>
<div id="admonition-propiedad" class="admonition admonish-abstract">
<div class="admonition-title">
<p>Propiedad</p>
<p><a class="admonition-anchor-link" href="#admonition-propiedad"></a></p>
</div>
<div>
<p>Toda fórmula de lógica de primer orden es lógicamente equivalente a otra que está en FNN.</p>
<p>La demostración es dar un algoritmo basado en inducción estructural para convertirla:</p>
<p>$$
\begin{align}
\neg(A \land B) &amp;\iff \neg A \lor \neg B \\
\neg(A \lor B) &amp;\iff \neg A \land \neg B \\
\neg\neg A &amp;\iff A \\
\neg \forall x.A &amp;\iff \exists x. \neg A \\
\neg \exists x.A &amp;\iff \forall x. \neg A
\end{align}
$$</p>
<p>Nota: no estamos perdiendo satisfactibilidad en esta transformación. (keep in mind y'all)</p>
</div>
</div>
<h3 id="forma-normal-prenexa"><a class="header" href="#forma-normal-prenexa">Forma normal prenexa</a></h3>
<p>Es una forma de escribir tu fórmula de forma tal que "quede ordenada". En qué
sentido? Que quedan <em>todos</em> los cuantificadores adelante y recién después del
último cuantificador el resto. Qué pinta tiene?</p>
<p>$$
Q_1x_1 \dots Q_nx_n.B, n \geq 0
$$</p>
<p>siendo:</p>
<ul>
<li>\(B\) una fórmula sin cuantificadores (la llamamos <strong>matriz</strong>)</li>
<li>\(x_i\) variables</li>
<li>\(Q_i \in \lbrace \forall, \exists \rbrace\)</li>
</ul>
<div id="admonition-propiedad-1" class="admonition admonish-abstract">
<div class="admonition-title">
<p>Propiedad</p>
<p><a class="admonition-anchor-link" href="#admonition-propiedad-1"></a></p>
</div>
<div>
<p>Toda fórmula <a href="#variables-libres-y-ligadas">rectificada</a> es lógicamente
equivalente a otra en forma prenexa. Es importante lo de rectificada para no
cagarla cuando metemos/sacamos una parte de la fórmula al cuantificador.</p>
<p>La demostración también es dar un algoritmo basado en inducción estructural para convertirla:</p>
<p>$$
\begin{alignat}{3}
(\forall x.A) \land B &amp;\iff \forall x.(A \land B)\ \ \ \ \ \ \ \ \ \ &amp;(\forall x.A) \lor B &amp;\iff \forall x.(A \lor B) \\
(\exists x.A) \land B &amp;\iff \exists x.(A \land B)\ \ \ \ \ \ \ \ \ \ &amp;(\exists x.A) \lor B &amp;\iff \exists x.(A \lor B)
\end{alignat}
$$</p>
<ul>
<li>Nota: no estamos perdiendo satisfactibilidad en esta transformación. (keep in mind y'all)</li>
<li>Nota 2: Recordar que hay varias operaciones que son asociativas y conmutativas (así que hay más combinaciones para la demostración de arriba)</li>
</ul>
</div>
</div>
<h3 id="forma-normal-de-skolem-also-known-as-eskolemizar"><a class="header" href="#forma-normal-de-skolem-also-known-as-eskolemizar">Forma normal de Skolem (also known as "Eskolemizar")</a></h3>
<p>Por qué skolemizar? Nuestro objetivo a largo plazo es tener
<a href="#sentencias">sentencias</a> ya que los existenciales nos pueden complicar la
vida. Skolemizar consiste en eliminar los cuantificadores existenciales, <strong>sin
eliminar satisfactibilidad</strong>.</p>
<p>Cómo elimino cuantificadores existenciales? Mediante <strong>testigos</strong>, que son
constantes o funciones de skolem que instanciamos. Por ejemplo:</p>
<ul>
<li>\(\exists x. P(x)\) se skolemiza a \(P(c)\) donde \(c\) es una nueva
constante que se agrega al lenguaje de primer orden. Esa constante vendría a
representar el valor que se evalúa al valor que quiero. Como sólo busco
satisfactibilidad me alcanza con dar alguna estructura, por lo tanto extender
con esa constante al lenguaje no debería hacerme perder la satisfactibilidad.</li>
<li>Esas funciones/constantes también se las conoce como parámetros</li>
</ul>
<div id="admonition-propiedad-2" class="admonition admonish-abstract">
<div class="admonition-title">
<p>Propiedad</p>
<p><a class="admonition-anchor-link" href="#admonition-propiedad-2"></a></p>
</div>
<div>
<p>Si \(A'\) es el resultado de skolemizar \(A\), entonces \(A\) es satisfactible sii \(A'\) es satisfactible. (no vamos a ver la demo).</p>
<p>Como consecuencia tenemos que la skolemización preserva insatisfactibilidad. Esto ya debería de ser suficiente para poder aplicar el método de resolución.</p>
<blockquote>
<p><strong>Pregunta</strong>: Será posible eliminar cuantificadores preservando no sólo satisfactibilidad si no también la <strong>validez</strong>?</p>
<p>En general, No. Por ejemplo \(\exists x.(P(a) \supset P(x))\) es válida, pero una vez que fijo el \(x\) ya no: \(P(a) \supset P(b)\) depende de la estructura.</p>
<p>Pero de vuelta, no nos importa porque a nosotros sólo nos interesaba la satisfactibilidad.</p>
</blockquote>
</div>
</div>
<h4 id="formalización"><a class="header" href="#formalización">Formalización</a></h4>
<p>Formalizando todo, en la skolemización cáda ocurrencia de una subfórmula</p>
<p>$$
\exists x.B
$$</p>
<p>en \(A\) se reemplaza por</p>
<p>$$
B \lbrace x \leftarrow f(x_1, \dots, x_n) \rbrace
$$</p>
<p>que representa la operación de sustitución aplicada sobre la expresión \(B\)
y donde \(f\) es un símbolo de función nuevo, y \(x_1, \dots, x_n\) son las
variables de las que depende \(x\) en \(B\). Esto implica que si el
existencial está adentro de una fórmula más grande puede que \(B\) tenga
variables libres y en ese caso \(x\) va a depender de ellas (para la
satisfactibilidad).</p>
<p>Definimos entonces la forma de skolem \(\mathbf{SK}(A)\) como:</p>
<ul>
<li>tomo un \(A'\) subfórmula de \(A\)</li>
<li>Si \(A'\) es una fórmula atómica o su negación no cambio anda</li>
</ul>
<p>$$
\mathbf{SK}(A') = A'
$$</p>
<ul>
<li>Si \(A'\) es de la forma \((B * C)\) con \(* \in \lbrace \lor, \land \rbrace\), entonces</li>
</ul>
<p>$$
\mathbf{SK}(A') = (\mathbf{SK}(B) * \mathbf{SK}(C))
$$</p>
<ul>
<li>Si \(A'\) es un cuantificador (\(\forall x. B\)), entonces</li>
</ul>
<p>$$
\mathbf{SK}(A') = \forall x. \mathbf{SK}(B)
$$</p>
<ul>
<li>
<p>Si \(A'\) es un cuantificador existencial (\(\exists x. B\)) y \(\lbrace x, y_1, \dots, y_m \rbrace\) son variables libres de \(B\), entonces</p>
<ol>
<li>si \(m &gt; 0\), crear un nuevo símbolo de función de Skolem, \(f_x\) de aridad \(m\) y definir</li>
</ol>
<p>$$
\mathbf{SK}(A') = \mathbf{SK}(B \lbrace x \leftarrow f_x(y_1, \dots, y_m) \rbrace)
$$
2. si \(m = 0\), crear una nueva constante de Skolem, \(c_x\) y</p>
<p>$$
\mathbf{SK}(A') = \mathbf{SK}(B \lbrace x \leftarrow c_x \rbrace)
$$</p>
</li>
</ul>
<blockquote>
<p>Nota: como asumimos que \(A\) está rectificada, cada \(f_x\) y \(c_x\)
son únicos.</p>
</blockquote>
<blockquote>
<p>Nota 2/Pregunta: por qué necesito tanto constantes como funciones de Skolem?
No podría simplemente tomar el cuantificador "de más afuera" y listo? Bueno,
a priori la skolemización está definida para fórmulas rectificadas, no
necesariamente son fórmulas resultantes de pasar a forma prenexa. Pero si
vengo de prenexa <strong>puedo usar únicamente constantes?</strong> Casi, pero no porque
puedo tener \(\forall\) al principio de todo y no tengo forma de "meterlo"
para adentro en la fórmula ("para todo x existe y ..." no es lo mismo que
"existe un y tal que para todo x ...", no conmutan los cuantificadores).
Dicho eso, es más fácil skolemizar de afuera hacia adentro de todos modos.</p>
</blockquote>
<h3 id="forma-clausal"><a class="header" href="#forma-clausal">Forma clausal</a></h3>
<p>Hasta ahora llegamos a una fórmula:</p>
<p>$$
\forall x_1 \dots \forall x_n. B
$$</p>
<ul>
<li>con las negaciones lo más al fondo posibles (por forma normal negada)</li>
<li>con los cuantificadores lo más afuera posible (por forma normal prenexa)</li>
<li>sin existenciales (por la skolemización)</li>
<li>o sea que lo de adentro está como en el punto de partida de la lógica proposicional!</li>
</ul>
<p>Para llegar a la forma clausal vamos a hacer un par de pasos más:</p>
<ol>
<li>Lo primero que hacemos es pasar \(B\) (la raíz) a FNC \(B'\) como si fuera proposicional.</li>
</ol>
<p>$$
\forall x_1 \dots \forall x_n. B'
$$</p>
<ol start="2">
<li>Segundo, distribuimos los cuantificadores sobre cada conjunción de la FNC. O sea, si tenemos</li>
</ol>
<p>$$
\forall x_1 \dots \forall x_n. C_1 \land \dots \land C_m
$$</p>
<p>ahora lo expresamos como</p>
<p>$$
(\forall x_1 \dots \forall x_n. C_1) \land \dots \land (\forall x_1 \dots \forall x_n. C_m)
$$</p>
<p>donde los \(C_i\) son disyunciones de literales.</p>
<ol start="3">
<li>La notación similar a proposicional queda:</li>
</ol>
<p>$$
\lbrace C_1, \dots, C_m \rbrace
$$</p>
<p>o sea que están, pero en la representación "me olvido" de los cuantificadores.</p>
<div id="admonition-cuidado" class="admonition admonish-warning">
<div class="admonition-title">
<p>Cuidado!</p>
<p><a class="admonition-anchor-link" href="#admonition-cuidado"></a></p>
</div>
<div>
<p>Si bien está el abuso de notación, hay que tener cuidado con qué variables son de los cuantificadores y cuales son constantes</p>
</div>
</div>
<h2 id="la-receta-de-resolución-en-primer-orden"><a class="header" href="#la-receta-de-resolución-en-primer-orden">La receta de resolución en primer orden</a></h2>
<p>Para probar que \(A\) es una tautología pasamos por los siguientes pasos:</p>
<ol>
<li>Calculamos la forma normal conjuntiva \(B\) de \(\neg A\)</li>
<li>Pasamos \(B\) a forma clausal</li>
<li>Aplicamos el método de resolución.</li>
<li>Si hallamos una refutación:
<ul>
<li>\(\neg A\) es insatisfactible, entonces \(A\) es tautología</li>
</ul>
</li>
<li>Si no hallamos una refutación:
<ul>
<li>\(\neg A\) es satisfactible y por lo tanto \(A\) no es tautología</li>
</ul>
</li>
</ol>
<h3 id="método-de-resolución-en-proposicional"><a class="header" href="#método-de-resolución-en-proposicional">Método de resolución en proposicional</a></h3>
<p>Recuerdo:</p>
<ul>
<li>La refutación era una secuencia de pasos de resolución que nos llevan a la cláusula vacía (+ el resto)</li>
<li>Los pasos de resolución eran de la forma:</li>
</ul>
<p>$$
\frac{\lbrace A_1, \dots, A_m, Q \rbrace\ \ \lbrace B_1, \dots, B_n, \neg Q \rbrace}{\lbrace A_1, \dots, A_m, B_1, \dots, B_n \rbrace}
$$</p>
<p>Podemos aplicarlo así como viene en primer orden (asumiendo que los \(A_i, B_i, Q\) son predicados atómicos o sus negaciones)? Para responderlo veamos un ejemplo:</p>
<p>$$
(\forall x. P(x)) \land \neg P(a)
$$</p>
<ul>
<li>Es satisfactible? No, si para todo \(x\) vale \(P(x)\), entonces no puede a la vez valer \(\neg P(a)\) para ningún \(a\)</li>
<li>Y su forma clausal es</li>
</ul>
<p>$$
\lbrace \lbrace P(x) \rbrace, \lbrace \neg P(a) \rbrace \rbrace
$$</p>
<p>Claramente no puedo aplicar taaan directamente la regla de la resolución. Voy a
tener que relacionar el \(x\) que es variable con el \(a\) que es
constante. Si bien \(P(x)\) y \(P(a)\) no son iguales, son <strong>unificables</strong>.</p>
<h4 id="nueva-regla-de-resolución"><a class="header" href="#nueva-regla-de-resolución">Nueva regla de resolución:</a></h4>
<p>$$
\frac{\lbrace B_1, \dots, B_k, A_1, \dots A_m \rbrace\ \ \lbrace \neg D_1, \dots, \neg D_j, C_1, \dots, C_n \rbrace}{\sigma(\lbrace A_1, \dots, A_m, C_1, \dots, C_n \rbrace)}
$$</p>
<p>donde \(\sigma = MGU(\lbrace B_1 = B_2, \dots, B_{k-1} = B_k, B_k = D_1, \dots, D_{j-1} = D_j \rbrace)\), o sea que me deje a <strong>todos</strong> iguales.</p>
<ul>
<li>notar que \(\sigma(B_i) = \sigma(D_j)\) para todos \(i\) y \(j\)</li>
<li>La cláusula \(\sigma(\lbrace A_1, \dots, A_m, C_1, \dots, C_n \rbrace)\) es la que se llama <strong>resolvente</strong> en este caso.</li>
</ul>
<div id="admonition-teorema" class="admonition admonish-info">
<div class="admonition-title">
<p>Teorema</p>
<p><a class="admonition-anchor-link" href="#admonition-teorema"></a></p>
</div>
<div>
<p>El teorema de Herbrand-Skolem-Godel, nos dice que cada uno de los pasos de la resolución en primer orden preserva satisfactibilidad.</p>
</div>
</div>
<h3 id="diferencias-con-proposicional"><a class="header" href="#diferencias-con-proposicional">Diferencias con proposicional</a></h3>
<ul>
<li>puedo unificar de a varios a la vez</li>
<li>esta regla de resolución es <strong>incompleta</strong>, o sea que no es un insatisfactible sii el método encuentra refutación (se puede arreglar)</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="prop_solv.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="sld_solv.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="prop_solv.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="sld_solv.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>
        <script src="theme/pagetoc.js"></script>


    </div>
    </body>
</html>
