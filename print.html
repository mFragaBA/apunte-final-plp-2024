<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Apunte Final Paradigmas de Lenguajes de Programaci贸n 2024</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./custom.css">
        <link rel="stylesheet" href="./mdbook-admonish.css">
        <link rel="stylesheet" href="theme/pagetoc.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="unidad_1.html"><strong aria-hidden="true">1.</strong> Unidad 1 - Programaci贸n Funcional Con Haskell</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="programacion_funcional.html"><strong aria-hidden="true">1.1.</strong> Intro a Haskell</a></li><li class="chapter-item expanded "><a href="esquemas_de_recursion.html"><strong aria-hidden="true">1.2.</strong> Esquemas de recursi贸n</a></li></ol></li><li class="chapter-item expanded "><a href="unidad_2.html"><strong aria-hidden="true">2.</strong> Unidad 2 - C谩lculo Lambda</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lambda_calc_booleano.html"><strong aria-hidden="true">2.1.</strong> C谩lculo Lambda Tipado Booleano</a></li><li class="chapter-item expanded "><a href="lambda_calc_extendido.html"><strong aria-hidden="true">2.2.</strong> C谩lculo Lambda Tipado Extendido</a></li><li class="chapter-item expanded "><a href="inferencia_de_tipos.html"><strong aria-hidden="true">2.3.</strong> Inferencia de tipos</a></li><li class="chapter-item expanded "><a href="subtipado.html"><strong aria-hidden="true">2.4.</strong> Subtipado</a></li></ol></li><li class="chapter-item expanded "><a href="unidad_3.html"><strong aria-hidden="true">3.</strong> Unidad 3 - Paradigma de Objetos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="javascript_intro.html"><strong aria-hidden="true">3.1.</strong> Intro a POO</a></li><li class="chapter-item expanded "><a href="sigma_calc.html"><strong aria-hidden="true">3.2.</strong> C谩lculo Sigma</a></li></ol></li><li class="chapter-item expanded "><a href="unidad_4.html"><strong aria-hidden="true">4.</strong> Unidad 4 - Programaci贸n L贸gica</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="prop_solv.html"><strong aria-hidden="true">4.1.</strong> Resoluci贸n Proposicional</a></li><li class="chapter-item expanded "><a href="primer_orden_solv.html"><strong aria-hidden="true">4.2.</strong> Resoluci贸n en l贸gica de primer orden</a></li><li class="chapter-item expanded "><a href="sld_solv.html"><strong aria-hidden="true">4.3.</strong> Resoluci贸n SLD</a></li><li class="chapter-item expanded "><a href="prolog.html"><strong aria-hidden="true">4.4.</strong> Prolog</a></li></ol></li><li class="chapter-item expanded "><a href="practicas.html"><strong aria-hidden="true">5.</strong> Pr谩cticas</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="guia_0.html"><strong aria-hidden="true">5.1.</strong> Guia 0 - Repaso Haskell</a></li><li class="chapter-item expanded "><a href="guia_1.html"><strong aria-hidden="true">5.2.</strong> Guia 1 - Programaci贸n funcional</a></li><li class="chapter-item expanded "><a href="guia_2.html"><strong aria-hidden="true">5.3.</strong> Guia 2 - C谩lculo Lambda Tipado</a></li><li class="chapter-item expanded "><a href="guia_3.html"><strong aria-hidden="true">5.4.</strong> Guia 3 - Inferencia de Tipos</a></li><li class="chapter-item expanded "><a href="guia_4.html"><strong aria-hidden="true">5.5.</strong> Guia 4 - Subtipado</a></li><li class="chapter-item expanded "><a href="guia_5.html"><strong aria-hidden="true">5.6.</strong> Guia 5 - Programaci贸n Orientada a Objetos</a></li><li class="chapter-item expanded "><a href="guia_6.html"><strong aria-hidden="true">5.7.</strong> Guia 6 - Resoluci贸n L贸gica</a></li><li class="chapter-item expanded "><a href="guia_7.html"><strong aria-hidden="true">5.8.</strong> Guia 7 - Programaci贸n L贸gica</a></li></ol></li><li class="chapter-item expanded "><a href="bibliograf铆a.html"><strong aria-hidden="true">6.</strong> Bibliograf铆a</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Apunte Final Paradigmas de Lenguajes de Programaci贸n 2024</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main><div class="sidetoc"><nav class="pagetoc"></nav></div>
                        <h1 id="unidad-1---paradigma-funcional"><a class="header" href="#unidad-1---paradigma-funcional">Unidad 1 - Paradigma funcional</a></h1>
<p><img src="./img/hold_up.png" alt="" /></p>
<p>La materia se llama "Paradigmas de Programaci贸n. Qu茅 es un paradigma de programaci贸n:</p>
<ul>
<li><strong>paradigma</strong>: es una forma de pensamiento (a.k.a un marco te贸rico, un
conjunto de creencias).</li>
<li><strong>lenguaje de programaci贸n</strong>: el lenguaje que usamos para comunicar
instrucciones a una computadora.
<ul>
<li>describen <strong>c贸mputos</strong> (m谩s de a qu茅 me refiero con esto adelante)</li>
<li>es <strong>turing completo</strong> si puede expresar todas las funciones computables
(LyC war flashbacks). Los DSLs son ejemplos de lenguajes de programaci贸n
que no necesariamente son turing completos.</li>
<li>tiene que poder describir lo que hay que hacer de forma expl铆cita y no
ambigua.</li>
</ul>
</li>
<li>Entonces un <strong>paradigma de lenguaje de programaci贸n</strong> lo vamos a entender
como un estilo de programaci贸n, que impacta en la forma en la que se encaran
las soluciones
<ul>
<li>Est谩 muuuuuy vinculado al <strong>modelo de c贸mputo</strong>
<ul>
<li>A partir de un estado inicial llegar a un estado final.</li>
<li>En orga, por ejemplo parto de un estado inicial <strong>y aplico secuencias
de instrucciones para modificar el estado</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Entender de paradigmas de programaci贸n es una herramienta muy 煤til a la hora de
decidir qu茅 lenguaje elijo para resulver un problema.</p>
<p>En este resumen (y porque es lo visto en clase) voy a hablar de los paradigmas:</p>
<ul>
<li>imperativo</li>
<li>funcional (vamos a usar haskell)</li>
<li>orientado a objetos (javascript)</li>
<li>l贸gico (vamos a usar prolog)</li>
</ul>
<p>Pero sepan que exiten m谩s: concurrente, eventos, basado en continuaciones,
probabil铆stico, cu谩ntico. Adem谩s, hoy en d铆a los lenguajes m谩s modernos suelen
tomar features de distintos paradigmas (por ejemplo: rust . Otro ejemplo es
la incorporaci贸n de funciones an贸nimas en los distintos lenguajes, que antes
estaba medio reservado a los lenguajes funcionales) entonces la linea entre un
paradigma y otro dentro de un lenguaje se vuelve m谩s difusa.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="programaci贸n-funcional"><a class="header" href="#programaci贸n-funcional">Programaci贸n Funcional</a></h1>
<p>Si bien vamos a ver todo con lenguaje "haskelloso", la mayor铆a de conceptos
aplican a los lenguajes funcionales en general. Vamos a ver m谩s formal el
modelo de c贸mputo de lenguajes funcionales cuando veamos c谩lculo lambda.</p>
<ul>
<li>
<p>Programar: Definir funciones</p>
</li>
<li>
<p>Ejecutar: Evaluar expresiones</p>
<pre><code># Programando
factorial(1) = 1
factorial(n) = factorial(n - 1) * n


# Evaluando
factorial(4) =&gt; factorial(3) * 4 
             =&gt; factorial(2) * 3 * 4 
             =&gt; factorial(1) * 2 * 3 * 4
             =&gt; 1 * 2 * 3 * 4
             =&gt; 6 * 4
             =&gt; 24
</code></pre>
</li>
<li>
<p>Un programa es un conjunto de ecuaciones</p>
</li>
<li>
<p>Expresiones</p>
<ul>
<li>Si se puede definir, toda expresi贸n denota un valor</li>
<li>El valor depende 煤nicamente del valor de sus subexpresiones</li>
<li>Evaluar/Reducir una expresi贸n es obtener su valor (en el ejemplo <code>factorial(4) ~&gt; 24</code>)</li>
<li>No toda expresi贸n denota un valor (si no puedo reducir no tengo un valor)</li>
</ul>
</li>
<li>
<p>Valores</p>
<ul>
<li>Los podemos pensar como expresiones que no se pueden seguir reduciendo</li>
</ul>
</li>
</ul>
<h2 id="tipos"><a class="header" href="#tipos">Tipos</a></h2>
<p>En Haskell organizamos los valores en <strong>tipos</strong>. El tipo tiene operaciones asociadas. En haskell se tienen:</p>
<ul>
<li>tipos b谩sicos: <code>Int</code>, <code>Char</code>, <code>Float</code>, <code>Bool</code></li>
<li>tipos compuestos:
<ul>
<li>Listas: <code>[Int]</code></li>
<li>Tuplas: <code>(Int, Bool)</code></li>
<li>Funciones: <code>Int -&gt; Int</code></li>
</ul>
</li>
<li><strong>todo expresi贸n bien formada tiene un tipo asociado</strong> (esto tambi茅n, m谩s
adelante vamos a ver que si no se le puede otorgar tipo a una expresi贸n
entonces no se va a poder reducir) y el tipo depende del tipo de sus
subexpresiones.</li>
</ul>
<h2 id="funciones"><a class="header" href="#funciones">Funciones</a></h2>
<div id="admonition-definici贸n" class="admonition admonish-note">
<div class="admonition-title">
<p>Definici贸n</p>
<p><a class="admonition-anchor-link" href="programacion_funcional.html#admonition-definici贸n"></a></p>
</div>
<div>
<ul>
<li>
<p>Definici贸n con ecuaci贸n orientada:</p>
<pre><code class="language-haskell">doble :: Int -&gt; Int
doble x = x + x
</code></pre>
</li>
<li>
<p>Definici贸n con guardas:</p>
<pre><code class="language-haskell">signo :: Int -&gt; Bool
signo n | n &gt;= 0    = True
        | otherwise = False
</code></pre>
</li>
<li>
<p>Definiciones locales:</p>
<pre><code class="language-haskell">f(x, y) = g x + y
        where g z = z + 2
</code></pre>
</li>
<li>
<p>Expresiones Lambda:</p>
<pre><code class="language-haskell">-- con un par谩metro
\x -&gt; x + 1
-- con muchos par谩metros
\x -&gt; \y -&gt; x + y
-- escritura m谩s simple, separo par谩metros con espacios
\x y -&gt; x + y
</code></pre>
</li>
</ul>
</div>
</div>
<h2 id="polimorfismo-param茅trico"><a class="header" href="#polimorfismo-param茅trico">Polimorfismo param茅trico</a></h2>
<p>Dada la siguiente funci贸n <code>id</code>, cu谩l es su tipo?</p>
<pre><code class="language-haskell">id x = x
</code></pre>
<p>Rta: <code>id :: a -&gt; a</code>, donde <code>a</code> es una variable de tipo (es algo as铆 como un meta-tipo)</p>
<h2 id="clases-de-tipos"><a class="header" href="#clases-de-tipos">Clases de Tipos</a></h2>
<p>Cu谩l es el tipo de <code>m谩ximo</code>?</p>
<pre><code class="language-haskell">maximo x y | x &gt; y      = x
maximo _ y              = y
</code></pre>
<p>Puedo probar de evaluar a <code>m谩ximo</code>:</p>
<pre><code class="language-bash"># La eval煤o con enteros y funciona
&gt; maximo 1 2
2
# La eval煤o con decimales y tambi茅n funciona
&gt; maximo 1.2 3.4
3.4
</code></pre>
<p>Una <strong>clase</strong> es una suerte de interface que define un conjunto de operaciones. Por ejemplo:</p>
<ul>
<li><code>Eq</code>: <code>(==)</code>, <code>(/=)</code></li>
<li><code>Ord</code>: <code>(&lt;)</code>, <code>(&lt;=)</code>, <code>(&gt;=)</code>, <code>(&gt;)</code>, <code>max</code>, <code>min</code>, <code>compare</code></li>
</ul>
<p>pVolviendo a <code>maximo</code>, tenemos que <code>maximo :: Ord a =&gt; a -&gt; a -&gt; a</code>. O sea que
en m谩ximo puedo recibir cualquier tipo en tanto pertenezca a la clase <code>Ord</code>
(cosa de tener el comparador)</p>
<h2 id="instancia-de-una-clase-de-tipos"><a class="header" href="#instancia-de-una-clase-de-tipos">Instancia de una clase de tipos</a></h2>
<p>Notar que haskell permite usar el <code>deriving</code> que deriva autom谩ticamente una
"implementaci贸n por default" de todas las funciones de <code>Eq</code>. En el caso de <code>Eq</code>
compara cada caso, si es <code>Circulo</code> compara el valor, y si es <code>Rectangulo</code>
compara ambos valores.</p>
<pre><code class="language-haskell">data Figura = Circulo Float | Rectangulo Float Float
deriving Eq
</code></pre>
<p>Pero tambi茅n se pueden definir instancias con la l贸gica que quiera:</p>
<pre><code class="language-haskell">instance Ord Figura where
    (&lt;=) = \x -&gt; \y -&gt; area x &lt;= area y
</code></pre>
<h2 id="alto-orden"><a class="header" href="#alto-orden">Alto Orden</a></h2>
<p>En haskell, las funciones son lo que se conoce como first-class citizens, eso
significa que las funciones <strong>son un valor m谩s</strong>. O sea que pod茅s pasarlas como
par谩metro, pueden ser el resultado de una funci贸n.</p>
<p>Por ejemplo, a <code>id</code> le puedo pasar <code>id</code>. Entonces, cu谩l ser铆a el tipo de <code>id id</code>?</p>
<p>El tipo es <code>(id id) :: a -&gt; a</code></p>
<h2 id="currificaci贸n"><a class="header" href="#currificaci贸n">Currificaci贸n</a></h2>
<p>Ve谩moslo con 2 ejemplos:</p>
<pre><code class="language-haskell">suma :: ??
suma x y = x + y

suma' :: ??
suma' (x, y) = x + y
</code></pre>
<p>Si reviso los tipos obtengo que:</p>
<pre><code class="language-haskell">suma :: Int -&gt; Int -&gt; Int
suma' :: (Int, Int) -&gt; Int
</code></pre>
<p>Cu谩l es la diferencia? Que la primera implementaci贸n puedo hacer por ejemplo
<code>suma 5</code> y obtengo una funci贸n que incrementa en 5. Eso no lo puedo hacer con
<code>suma'</code>. Esta feature de poder evaluar parcialmente las funciones es lo que se
conoce como <strong>currificaci贸n</strong>.</p>
<p><img src="./img/currification.png#center" alt="" /></p>
<p>(No, ese Curry no...)</p>
<p>Veamos c贸mo se ve esto en ghci:</p>
<pre><code>&gt; :type suma
suma :: Int -&gt; Int -&gt; Int
&gt; :type suma 4
(suma 4) :: Int -&gt; Int
</code></pre>
<p>O sea que puedo definir por ejemplo <code>inc = suma 1</code></p>
<h3 id="viendo-curryuncurry-como-una-funci贸n"><a class="header" href="#viendo-curryuncurry-como-una-funci贸n">Viendo curry/uncurry como una funci贸n</a></h3>
<pre><code class="language-haskell">curry :: ((a, b) -&gt; c) -&gt; (a -&gt; (b -&gt; c))
curry f = \x -&gt; \y -&gt; f (x,y)
-- versi贸n alternativa --
curry f x = \y -&gt; f (x, y)

uncurry :: (a -&gt; b -&gt; c) -&gt; ((a, b) -&gt; c)
uncurry f (a, b) = f x y
</code></pre>
<h2 id="tipos-algebr谩icos"><a class="header" href="#tipos-algebr谩icos">Tipos Algebr谩icos</a></h2>
<p>Puedo definir los tipos por enumeraci贸n definiendo:</p>
<ul>
<li>el nombre del tipo</li>
<li>los constructores</li>
</ul>
<pre><code class="language-haskell">data Dia = Lunes | Martes | Miercoles | Jueves | Viernes | Sabado | Domingo

data Bool = True | False
</code></pre>
<p>Los constructores tambi茅n pueden tener par谩metros. En la definici贸n tengo que aclarar los tipos de sus argumentos:</p>
<pre><code class="language-haskell">data Figura = Circulo Float | Rectangulo Float Float
</code></pre>
<p>Algunos ejemplos de tipos:</p>
<ul>
<li><code>Lunes :: Dia</code></li>
<li><code>Circulo 1.0 :: Figura</code></li>
<li><code>Circulo :: Float -&gt; Figura</code></li>
</ul>
<h2 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern matching</a></h2>
<p>Es un mecanismo para comparar un valor con un patr贸n y deconstruir un valor en
sus partes. Por ejemplo:</p>
<pre><code class="language-haskell">area :: Figura -&gt; Float
area (Circulo radio) = PI * radio^2 
area (Rectangulo base altura) = base * altura
</code></pre>
<p>Si no hay un match directo, lo que va a hacer haskell es seguir reduciendo.
Eventualmente va a matchear o no se va a poder reducir la expresi贸n (y vamos a
tener un error).</p>
<div id="admonition-el-patr贸n-debe-ser-lineal" class="admonition admonish-info">
<div class="admonition-title">
<p>El patr贸n debe ser lineal</p>
<p><a class="admonition-anchor-link" href="programacion_funcional.html#admonition-el-patr贸n-debe-ser-lineal"></a></p>
</div>
<div>
<ul>
<li>
<p><strong>Lineal</strong> quiere decir que una variable debe aparecer una 煤nica vez a la izquierda.</p>
<pre><code class="language-haskell">esCuadrado :: Figura -&gt; Bool
esCuadrado (Circulo _) = False
esCuadrado (Rectangulo x y) | x == y =&gt;     = True
                            | otherwise     = False
-- alternativa
esCuadrado (Rectangulo x y) | x == y =&gt;     = True
esCuadrado _                                = False

-- alternativa tambi茅n valida
esCuadrado (Rectangulo x y) = x == y
esCuadrado _                = False
</code></pre>
</li>
<li>
<p><code>esCuadrado (Rectangulo x x)</code> ser铆a m谩s simple pero no est谩 permitido en
haskell (ej: en erlang/elixir esto es posible)</p>
</li>
</ul>
<p>Observaciones:</p>
<ul>
<li>
<p><code>_</code> coincide con cualquier forma (ver que en la alternativa agarro tanto el caso de <code>Circulo</code> como el de <code>Rectangulo</code> que no es cuadrado)</p>
</li>
<li>
<p>los casos se eval煤an en el orden que est谩n escritos</p>
</li>
<li>
<p>Puedo definir funciones parciales:</p>
<pre><code class="language-haskell">-- en este caso radio (Rectangulo _ _) va a dar error
radio (Circulo radio) = radio
</code></pre>
</li>
</ul>
</div>
</div>
<h2 id="tipos-recursivos"><a class="header" href="#tipos-recursivos">Tipos Recursivos</a></h2>
<p>La definici贸n de un tipo tpuede tener uno o m谩s par谩metros de tipo:</p>
<pre><code class="language-haskell">data Natural = Zero | Succ Natural

Zero :: Natural
Succ Zero :: Natural
Succ (Succ (Succ Zero)) :: Natural
</code></pre>
<h2 id="listas"><a class="header" href="#listas">Listas</a></h2>
<p>Es un tipo algebr谩ico param茅trico y recursivo con 2 constructores:</p>
<pre><code class="language-haskell">[] :: [a]               -- Constructor de la lista vac铆a
(:) :: a -&gt; [a] -&gt; [a]  -- Append Front
</code></pre>
<p>Ejemplos de pattern matching:</p>
<pre><code class="language-haskell">esVacia :: [a] -&gt; Bool
esVacia [] = True
esVacia _ = False
</code></pre>
<pre><code class="language-haskell">longitud :: [a] -&gt; Int
longitud [] = 0
longitud (x:xs) _ = 1 + longitud xs
</code></pre>
<h2 id="no-terminaci贸n-y-orden-de-evaluaci贸n"><a class="header" href="#no-terminaci贸n-y-orden-de-evaluaci贸n">No terminaci贸n y orden de evaluaci贸n</a></h2>
<p>Veamos la siguiente funci贸n:</p>
<pre><code class="language-haskell">inf1 :: [Int]
inf1 = 1 : inf1
</code></pre>
<p>Se reduce infinitamente, entonces para qu茅 quiero tener algo as铆? De qu茅 me sirve? Veamos esta funci贸n:</p>
<pre><code class="language-haskell">const :: a -&gt; b -&gt; a
const x y = x
</code></pre>
<p>Qu茅 pasa si hago <code>const 42 inf1</code>? Da 42. Pero en realidad depende del mecanismo
de reducci贸n que tenga el lenguaje, porque haskell resuelve primero el pattern
matching en lugar de reducir los par谩metros. Si no me quedaba reduciendo
infinitamente.</p>
<h3 id="evaluaci贸n-lazy-orden-normal"><a class="header" href="#evaluaci贸n-lazy-orden-normal">Evaluaci贸n Lazy (Orden Normal)</a></h3>
<ul>
<li>Tiene que ver con el modelo de c贸mputo que usa haskell, que es el de la
<code>Reducci贸n</code>
<ul>
<li>Se reemplaza un redex (expresi贸n reducible) por otra usando las
ecuaciones orientadas. Un redex es una sub-expresi贸n que no est茅 en forma
normal.</li>
<li>El redex tiene que ser una instancia del lado izquiero de alguna de las
ecuaciones (si no da error), y se reemplaza por el lado derecho asociando
las variables correspondientes.</li>
<li>El resto de la expresi贸n no cambia</li>
</ul>
</li>
<li>La evaluaci贸n Lazy, consiste en seleccionar las funciones m谩s externas y
luego los argumentos (pero s贸lo si se necesitan)</li>
</ul>
<h2 id="ejercicios"><a class="header" href="#ejercicios">Ejercicios</a></h2>
<h3 id="ejercicio-1"><a class="header" href="#ejercicio-1">Ejercicio 1</a></h3>
<p>Definir <code>dobleL :: [Float] -&gt; Float</code> tal que <code>doble xs</code> es la lista que contiene el doble de cada elemento en xs</p>
<pre><code class="language-haskell">doble [] = []
doble x:xs = (x * 2) : (doble xs)
</code></pre>
<h3 id="ejercicio-2"><a class="header" href="#ejercicio-2">Ejercicio 2</a></h3>
<p>Definir <code>esPar :: [Int] -&gt; [Bool]</code> tal que <code>esParL xs</code> indica si el correspondiente elemento en xs es par o no</p>
<pre><code class="language-haskell">esPar [] = []
esPar x:xs = (even x) : (esPar xs)
</code></pre>
<h3 id="ejercicio-3"><a class="header" href="#ejercicio-3">Ejercicio 3</a></h3>
<p>Definir <code>longL :: [[a]] -&gt; [Int]</code> tal que <code>longL xs</code> es la lista que contiene las longitudes de las listas en xs</p>
<pre><code class="language-haskell">longL [] = []
longL x:xs = (length x) : (longL xs)
</code></pre>
<div id="admonition-generalizando" class="admonition admonish-note">
<div class="admonition-title">
<p>Generalizando...</p>
<p><a class="admonition-anchor-link" href="programacion_funcional.html#admonition-generalizando"></a></p>
</div>
<div>
<ul>
<li>
<p>Notar que en los ejercicios el patr贸n era siempre el mismo con la diferencia de que en el primero hac铆amos <code>* 2</code>, en el segundo <code>even x</code> y en el tercero <code>length x</code></p>
</li>
<li>
<p>Podemos generalizar este comportamiento (gracias funciones de alto orden!) en la siguiente funci贸n:</p>
<pre><code class="language-haskell">map :: (a -&gt; b) -&gt; [a] -&gt; [b]
map _ [] = []
map f x:xs = (f x) : (map f xs)
</code></pre>
</li>
<li>
<p>Podemos redefinir las funciones de antes con <code>map</code>:</p>
<pre><code class="language-haskell">-- Ni tengo que agregar el par谩metro a la definici贸n!
doble = map (\x -&gt; 2 * x)
esPar = map even
longL = map length
</code></pre>
</li>
</ul>
</div>
</div>
<h3 id="ejercicio-4"><a class="header" href="#ejercicio-4">Ejercicio 4</a></h3>
<p>Definir <code>negativos :: [Float] -&gt; [Float]</code> tal que <code>negativos xs</code> contiene los elementos negativos de xs</p>
<pre><code class="language-haskell">negativos [] = []
negativos x:xs  | x &lt; 0     = x : (negativos xs)
                | otherwise = negativos xs
</code></pre>
<h3 id="ejercicio-5"><a class="header" href="#ejercicio-5">Ejercicio 5</a></h3>
<p>Definir <code>noVacias :: [[a]] -&gt; [[a]]</code> tal que <code>noVacias xs</code> contiene las listas no vac铆as de <code>xs</code></p>
<pre><code class="language-haskell">noVacias [] = []
noVacias x:xs   | length x &gt; 0     = x : (noVacias xs)
                | otherwise = noVacias xs
</code></pre>
<div id="admonition-generalizando-1" class="admonition admonish-note">
<div class="admonition-title">
<p>Generalizando...</p>
<p><a class="admonition-anchor-link" href="programacion_funcional.html#admonition-generalizando-1"></a></p>
</div>
<div>
<ul>
<li>
<p>Notar que en los ejercicios el patr贸n era siempre el mismo: el caso base
devuelve vac铆o, y para el otro chequeo una condici贸n booleana para saber si
agregar o no.</p>
</li>
<li>
<p>Podemos generalizar este comportamiento (gracias funciones de alto orden again!) en
la siguiente funci贸n:</p>
<pre><code class="language-haskell">filter :: (a -&gt; Bool) -&gt; [a] -&gt; [b]
filter _ [] = []
filter f x:xs   | (f x)     = x : (filter f xs)
                | otherwise = filter f xs
</code></pre>
</li>
<li>
<p>Podemos redefinir las funciones de antes con <code>filter</code>:</p>
<pre><code class="language-haskell">-- Ni tengo que agregar el par谩metro a la definici贸n!
negativos = filter (\x -&gt; x &lt; 0)
noVacias = filter (\x -&gt; length x &gt; 0)
</code></pre>
</li>
</ul>
</div>
</div>
<h2 id="transparencia-referencial"><a class="header" href="#transparencia-referencial">Transparencia referencial</a></h2>
<p>Una propiedad de haskell (y otros lenguajes funcionales) es la de la
<strong>transparencia referencial</strong>. Esto qu茅 significa? Que el resultado de evaluar
una expresi贸n s贸lo depende de sus subexpresiones. Eso tiene la implicancia de
que si yo tengo 2 veces la misma subexpresi贸n ambas van a evaluar al mismo
valor.</p>
<p>Un ejemplo para ver qu茅 no tiene transparencia referencial es en un lenguaje imperativo como C puedo hacer:</p>
<pre><code class="language-c">algunaFuncion(x++, x++);
</code></pre>
<p>Estoy llamando a <code>algunaFuncion</code> y los par谩metros son ambos <code>x++</code> pero no van a
tener el mismo valor.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="esquemas-de-recursi贸n"><a class="header" href="#esquemas-de-recursi贸n">Esquemas de recursi贸n</a></h1>
<h2 id="esquemas-de-recursi贸n-sobre-listas"><a class="header" href="#esquemas-de-recursi贸n-sobre-listas">Esquemas de recursi贸n sobre listas</a></h2>
<h3 id="recursi贸n-estructural"><a class="header" href="#recursi贸n-estructural">Recursi贸n estructural</a></h3>
<p>Pensemos un par de funciones sobre listas:</p>
<ul>
<li>
<p><code>sumaL</code>: la suma de todos los valores de una lista de enteros</p>
<pre><code class="language-haskell">-- alguna def con tipos
sumaL [] = 0
sumaL (x:xs) = x + sumaL(xs)
</code></pre>
</li>
<li>
<p><code>concat</code>: la concatenaci贸n de todos los elementos de una lista de listas</p>
<pre><code class="language-haskell">-- alguna def con tipos
concat [] = []
concat (x:xs) = x ++ concat xs
</code></pre>
</li>
<li>
<p><code>reverso</code>: el reverso de una lista</p>
<pre><code class="language-haskell">reverso [] = []
reverso (x:xs) = reverso xs ++ [x]
</code></pre>
</li>
</ul>
<div id="admonition-generalizando" class="admonition admonish-info">
<div class="admonition-title">
<p>Generalizando...</p>
<p><a class="admonition-anchor-link" href="esquemas_de_recursion.html#admonition-generalizando"></a></p>
</div>
<div>
<p><strong>El approach es siempre el mismo</strong>. Asumo que se calcular el resultado para el
caso m谩s chico y hago alguna operaci贸n para combinar todo, y el resultado puede
ser otra cosa distinta, no necesariamente una lista. Sumado a eso tenemos un
caso base distinguido.</p>
<pre><code class="language-haskell">g :: [a] -&gt; b
-- caso base distinguido
g [] = z
g (x:xs) = f x (g xs)
</code></pre>
<p>Generalizando, obtenemos el fold:</p>
<p><img src="./img/foldr_scheme.png#center" alt="" /></p>
<pre><code class="language-haskell">-- recibimos una funci贸n, un elemento para el caso base y una lista
-- la funci贸n recibe un elemnto de la lista, y lo otro de tipo b es el resultado parcial
foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b
foldr _ z [] = z
foldr f z (x:xs) = f x (foldr f z xs)
</code></pre>
</div>
</div>
<h4 id="algunos-ejemplos-con-foldr"><a class="header" href="#algunos-ejemplos-con-foldr">Algunos ejemplos con <code>foldr</code></a></h4>
<p>Podemos repensar las funciones de antes usando <code>foldr</code>:</p>
<pre><code class="language-haskell">-- a = b = Int =&gt; (+) :: Int -&gt; Int -&gt; Int === a -&gt; b -&gt; b
sumaL = foldr (+) 0
-- a = b = [a'] =&gt; (++) :: [a'] -&gt; [a'] -&gt; [a'] === a -&gt; b -&gt; b
concat = foldr (++) []
-- a = a', b = [a'] =&gt; (:) :: a' -&gt; [a'] -&gt; [a'] === a -&gt; b -&gt; b
-- flip toma una funci贸n de 2 par谩metros y les invierte el orden
-- al componerlo con (:[]) lo que hace es al primer par谩metro (a')
-- lo mete en la lista vac铆a. Luego se pasa a flip (++) que va a 
-- hacer el ++ usando el primer par谩metro como segundo
reverso = foldr ((flip (++)) . (:[])) []
-- alternativa m谩s legible en mi opini贸n
reverso = foldr (\elem -&gt; \partial -&gt; partial ++ [elem]) []
</code></pre>
<p>Y tambi茅n podemos reimplementar <code>map</code> y <code>filter</code> usando <code>foldr</code>:</p>
<pre><code class="language-haskell">map f = foldr (\elem -&gt; \partial -&gt; (f elem):partial) []
-- alternativa: (:) es una funci贸n a -&gt; [a] -&gt; [a]. 
-- La compongo con f (sobre el primer elemento) y gan茅
-- map f = foldr ((:) . f) []
filter f = foldr (\elem -&gt; \partial -&gt; if f elem then (elem:partial) else partial) []
</code></pre>
<p>Podemos implementar <code>(++)</code> usando <code>foldr</code>?</p>
<pre><code class="language-haskell">(++) :: [a] -&gt; [a] -&gt; [a]
xs ++ ys = foldr (:) ys xs
</code></pre>
<p>Ahora probemos algo m谩s complicado. Definamos <code>sumaLong</code> que calcula la
longitud y la suma en una 煤nca pasada sobre una lista.</p>
<pre><code class="language-haskell">sumaLong :: [Int] -&gt; (Int, Int)
-- hago pattern matching contra una tupla
sumaLong = foldr (\elem -&gt; \(recLong, recSum) -&gt; (recLong + elem, recSum + 1)) (0, 0)
</code></pre>
<p>Por 煤ltimo, podemos definir <code>dropWhile</code> usando foldr? Ej de uso: <code>dropWhile even [2, 4, 1, 6] = [1, 6]</code>. La definici贸n "cl谩sica" es:</p>
<pre><code class="language-haskell">dropWhile :: (a -&gt; Bool) -&gt; [a] -&gt; [a]
dropWhile _ [] = []
dropWhile p (x:xs) = if p x then dropWhile p xs else x:xs
</code></pre>
<p>La intuici贸n me dice de que esto no se va a poder, porque ahora no tenemos el
final de la recursi贸n cuando se nos acaba la lista, si no que depende de los
elementos. Igual intentemos:</p>
<pre><code class="language-haskell">dropWhile = foldr (\x rec -&gt; ????????) []
</code></pre>
<p>Tengo un problema... Si justo ten铆a que cortar en <code>x</code>, no tengo forma de
"decirle" al caso recursivo que no tiene que filtrar, y tampoco tengo c贸mo
recuperar lo que falta de la lista.</p>
<p>C贸mo puedo sobreponerme a esto? Bueno, por algo vimos el ejemplo anterior de
<code>SumaLong</code>. Podr铆a hacer que mi funci贸n devuelva una tupla, en donde el primer
elemento es el resultado del <code>dropWhile</code> y el segundo es la lista sin filtrar.</p>
<pre><code class="language-haskell">dropWhile p = fst (foldr (\x (droppedRec, undroppedRec) -&gt; 
        if p x then (undroppedRec, x:undroppedRec) 
        else (x:droppedRec, x:undroppedRec)) ([], []))
-- alternativa
dropWhile p = fst (foldr (\x (droppedRec, undroppedRec) -&gt; 
        (if p x then undroppedRec else x:droppedRec, x:undroppedRec)) ([], []))
-- alternativa: llamo a lo de arriba sin el fst dropWhileTupla y despu茅s dropWhile p xs = fst (dropWhileTupla p xs)
</code></pre>
<h3 id="recursi贸n-primitiva"><a class="header" href="#recursi贸n-primitiva">Recursi贸n Primitiva</a></h3>
<p>Tomando este problema que tuvimos con <code>foldr</code> para implementar <code>dropWhile</code>, por
qu茅 no nos definimos otra funci贸n que si tenga en cuenta el <code>xs</code> del resto de
la lista?</p>
<p>El esquema de <code>dropWhile</code> ser铆a:</p>
<pre><code class="language-haskell">g :: [a] -&gt; b
-- caso base
g [] = z
-- recursi贸n
g (x:xs) = f x xs (g xs)
</code></pre>
<p>Y la generalizaci贸n la llamamos <code>recr</code>:</p>
<pre><code class="language-haskell">recr :: b -&gt; (a -&gt; [a] -&gt; b -&gt; b) -&gt; [a] -&gt; b
recr z _ [] = z
recr z f (x:xs) = f x xs (recr z f xs)
</code></pre>
<div id="admonition-sobre-funciones-primitivas-recursivas" class="admonition admonish-info">
<div class="admonition-title">
<p>Sobre funciones Primitivas Recursivas</p>
<p><a class="admonition-anchor-link" href="esquemas_de_recursion.html#admonition-sobre-funciones-primitivas-recursivas"></a></p>
</div>
<div>
<p>Las funciones Primitivas Recursivas son un conjunto de funciones que vemos en
L贸gica y Computabilidad, y en particular tienen un esquema de recursi贸n muy
parecido a este que acabamos de ver. Dicho eso, sabemos que no son todas las
funciones computables debido a que por ejemplo <a href="https://planetmath.org/ackermannfunctionisnotprimitiverecursive">no existe una primitiva recursiva que pueda calcular la funci贸n de Ackermann</a>.</p>
<p>Sin embargo, es posible con <code>foldr</code> implementar la funci贸n de Ackermann. Esto
da cuenta realmente del poder de expresividad de <code>foldr</code>.</p>
</div>
</div>
<p>Podemos reimplementar <code>dropWhile</code> usando <code>recr</code>?</p>
<pre><code class="language-haskell">dropWhile p = recr [] (\x xs rec -&gt; if p x then xs else x:rec)
</code></pre>
<p>Mucho m谩s simple!</p>
<p>Podemos escribir <code>foldr</code> usando <code>recr</code>?</p>
<pre><code class="language-haskell">foldr f z = recr z (\x xs rec -&gt; f x rec)
</code></pre>
<p>Y <code>recr</code> en t茅rminos de <code>foldr</code>?</p>
<pre><code class="language-haskell">-- Uso el mismo truco de antes, devuelvo la tupla manteniendo en el segundo elemento
recr z f = fst . (foldr (\x (rec, xs) -&gt; (f x xs rec, x:xs)) (z, []))
</code></pre>
<div id="admonition-foldl" class="admonition admonish-info">
<div class="admonition-title">
<p>foldl</p>
<p><a class="admonition-anchor-link" href="esquemas_de_recursion.html#admonition-foldl"></a></p>
</div>
<div>
<p>Una alternativa a <code>foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b</code> es <code>foldl</code> (notar
que se invierte el orden de los tipos en la funci贸n):</p>
<pre><code class="language-haskell">foldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b
foldl _ z [] = z
foldl f z (x:xs) = foldl f (f z x) xs
</code></pre>
<p>La lista ahora se "recorre" de adelante hacia atr谩s:</p>
<p><img src="./img/foldl_scheme.png" alt="" /></p>
<p>Otro detalle es que ahora el llamado recursivo no es parte de la <code>f</code>. Si
volvemos a revisar <code>foldr</code> vamos a notar que si <code>xs</code> era una lista infinita,
pero <code>f</code> ignora la lista no pasa nada. En cambio ac谩 si ten茅s problemas porque
se consume la lista entera incluso si <code>f</code> no la usa.</p>
<p>Notar que en <code>foldl</code> el <code>z</code> es el resultado parcial, no el caso base (o m谩s
bien, es el caso base en el primer elemento y despu茅s es el resultado parcial
acumulado).</p>
<p>Si queremos ver un ejemplo, tomemos <code>sumaL</code>:</p>
<pre><code class="language-haskell">sumaL = foldl (+) 0
</code></pre>
<p>Es igual! Pero el orden de evaluaci贸n cambia:</p>
<pre><code class="language-haskell">foldl (+) 0 [1, 2]
foldl (+) ((+) 0 1) [2]
foldl (+) ((+) ((+) 0 1) 2) []
((+) ((+) 0 1) 2)
((+) 1 2)
3
</code></pre>
<p>Otro ejemplo, el reverse!:</p>
<pre><code class="language-haskell">reverse = foldl (\acc x -&gt; x:acc) []
-- equivalentemente
reverse = foldl (flip (:)) []
</code></pre>
</div>
</div>
<h3 id="foldl-vs-foldr"><a class="header" href="#foldl-vs-foldr"><code>foldl</code> vs <code>foldr</code></a></h3>
<ul>
<li>En listas infinitas? Us谩 <code>foldr</code></li>
<li>Puedo escribir <code>foldl</code> usando <code>foldr</code>?</li>
</ul>
<pre><code class="language-haskell">-- galerazo: en lugar de acumular y listo, devuelvo una funci贸n 
-- que cuando la aplique va a tomar el orden del foldl (asumamos 
-- que g es alguna funci贸n que toma un elemento)
foldl f z xs = foldr (\x recf -&gt; (\ac -&gt; recf (f ac x))) (g) 
</code></pre>
<p>Creo que ayuda m谩s a entender si lo vemos con un ejemplo y lo expandimos:</p>
<pre><code class="language-haskell">-- supongamos que hacemos foldl f g [x, y]
-- al final de la recursi贸n tenemos:
(\ac -&gt; g (f ac y))
-- cuando se vuelve de la recursi贸n y se aplica el siguiente paso
(\ac' -&gt; (\ac -&gt; g (f ac y)) (f ac' x))
-- Si hacemos el reemplazo en la evaluaci贸n:
(\ac' -&gt; g (f (f ac' x) y))
-- ah铆 se puede ver que si ac' es el caso base z, tendr铆a la evaluaci贸n en el orden del foldl
</code></pre>
<p>Por 煤ltimo entonces, alcanza con notar que si <code>g = id</code> ya gan茅. O sea que queda definida como:</p>
<pre><code class="language-haskell">foldl f z xs = foldr (\x recf -&gt; (\ac -&gt; recf (f ac x))) id z
</code></pre>
<ul>
<li>Puedo escribir <code>foldr</code> usando <code>foldl</code>? No, pero si para listas finitas</li>
</ul>
<h1 id="esquemas-de-recursi贸n-sobre-tipos-de-datos-algebr谩icos"><a class="header" href="#esquemas-de-recursi贸n-sobre-tipos-de-datos-algebr谩icos">Esquemas de recursi贸n sobre tipos de datos algebr谩icos</a></h1>
<h2 id="rboles-binarios"><a class="header" href="#rboles-binarios">rboles binarios</a></h2>
<p>Recuerdo, yo pod铆a definir un 谩rbol binario como:</p>
<pre><code class="language-haskell">data Arbol a = Hoja a | Nodo a (Arbol a) (Arbol a)
</code></pre>
<p>Y podr铆a querer por ejemplo aplicar una funci贸n a todos los nodos. A qu茅 te
suena eso? As铆 es, al <code>map</code>. En el caso de 谩rboles tendr铆amos un <code>map</code> definido
como:</p>
<pre><code class="language-haskell">mapA :: (a -&gt; b) -&gt; Arbol a -&gt; Arbol b
mapA f (Hoja x) = Hoja (f x)
mapA f (Nodo a (sai) (sad)) = (Nodo (f a) (mapA f sai) (mapA f sad))
</code></pre>
<p>As铆 como puedo hacer <code>map</code>, puedo hacer <code>fold</code> tambi茅n:</p>
<pre><code class="language-haskell">-- recibo una funci贸n para aplicar en el caso base y otra 
-- para la combinaci贸n. La segunda recibe los resultados del
-- fold para ambas ramas
foldA :: (a -&gt; b) -&gt; (a -&gt; b -&gt; b -&gt; b) -&gt; Arbol a -&gt; b
foldA f g (Hoja x) = f x
foldA f g (Nodo x izq der) = g x (foldA f g izq) (foldA f g der)
</code></pre>
<h3 id="algunas-operaciones-interesantes"><a class="header" href="#algunas-operaciones-interesantes">Algunas operaciones interesantes</a></h3>
<pre><code class="language-haskell">-- no te suena al foldr (:) = id?
-- obs: fold aplicado a los constructores es la identidad
id = foldA Hoja Nodo

sumaA = foldA id (\x izq der -&gt; x + izq + der)

altura = fold (\x -&gt; 1) (\x izq der -&gt; max izq der + 1)
</code></pre>
<h2 id="rboles-generales"><a class="header" href="#rboles-generales">rboles Generales</a></h2>
<pre><code class="language-haskell">data AG a = NodoAG a [AG a]
</code></pre>
<p>La pregunta es c贸mo hago <code>fold</code>/<code>map</code> con esto?</p>
<pre><code class="language-haskell">mapAG :: (a -&gt; b) -&gt; AG a -&gt; AG b
-- uso tanto map como mapAG!!!
mapAG f (NodoAG a as) = NodoAG (f a) (map (mapAG f) as)
</code></pre>
<pre><code class="language-haskell">-- No tengo "caso base" porque map _ [] = []. 
-- Ya est谩 impl铆cito el caso base
foldAG :: (a -&gt; [b] -&gt; b) -&gt; AG a -&gt; b
-- notar que es igual a antes, pero en lugar de aplicar al nodo 
-- izquierdo o derecho lo aplico a todos los nodos de la lista
foldAG f (NodoAG a as) = f a (map (foldAG f) as)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unidad-2---c谩lculo-lambda"><a class="header" href="#unidad-2---c谩lculo-lambda">Unidad 2 - C谩lculo Lambda</a></h1>
<div style="float:right;margin-left:2rem;margin-bottom:2rem;width:330px">
<p><img src="./img/church.png" alt="" /></p>
</div>
<ul>
<li>El C谩lculo Lambda es un modelo de c贸mputo basado en <strong>funciones</strong>, que es la
base para el paradigma funcional.</li>
<li>Fue introducido por Alonzo Church en el 34', cuando quer铆a responder a la
pregunta de si hab铆a un proceso mec谩nico para demostrar si una f贸rmula era
teorema o no.
<ul>
<li>Alonzo formaliz贸 en el lambda c谩lculo esta idea de computar cosas.</li>
</ul>
</li>
<li>Si bien lo introduce en el 34', nosotros vamos a ver el <strong>C谩lculo Lambda Tipado</strong>, tambi茅n desarrollado por Church pero en el 41'.
<ul>
<li>las expresiones tienen tipos</li>
</ul>
</li>
<li>El lambda c谩lculo es tambi茅n computacionalmente completo, a.k.a <strong>Turing Completo</strong>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>$$
\newcommand{\lcb}{\lambda^b}
\newcommand{\ifLC}[3]{if\  {#1}\  then\  {#2}\  else\  {#3}}
\newcommand{\lf}[3]{\lambda{#1}:\ {#2}.{#3}}
\newcommand{\apply}[2]{{#1}\ {#2}}
\newcommand{\hastype}[3]{{#1} \triangleright {#2}: {#3}}
\newcommand{\ttrue}[1]{\frac{}{\hastype{#1}{true}{Bool}} (T-True)}
\newcommand{\tfalse}[1]{\frac{}{\hastype{#1}{false}{Bool}} (T-False)}
\newcommand{\tvar}[3]{\frac{{#2}:{#3} \in {#1}}{\hastype{#1}{#2}{#3}} (T-var)}
\newcommand{\tif}[5]{\frac{\hastype{#1}{#2}{Bool}\ \ \hastype{#1}{#3}{#5}\ \ \hastype{#1}{#4}{#5}}{\hastype{#1}{\ifLC{{#2}}{{#3}}{{#4}}}{#5}} (T-If)}
\newcommand{\tabs}[5]{\frac{\hastype{{#1},{#2}:{#3}}{#5}{#4}}{\hastype{#1}{\lf{{#2}}{{#3}}{{#5}}}{{#3} \rightarrow {#4}}} (T-abs)}
\newcommand{\tapp}[5]{\frac{\hastype{#1}{#2}{#3 \rightarrow #4}\ \ \hastype{#1}{#5}{#3}}{\hastype{#1}{\apply{{#2}}{{#5}}}{#4}} (T-app)}
\newcommand{\eiftrue}[2]{\frac{}{\ifLC{true}{#1}{#2} \rightarrow #1} (E-IfTrue)}
\newcommand{\eiffalse}[2]{\frac{}{\ifLC{false}{#1}{#2} \rightarrow #2} (E-IfFalse)}
\newcommand{\eif}[4]{\frac{#1 \rightarrow #2}{\ifLC{#1}{#3}{#4} \rightarrow \ifLC{#2}{#3}{#4}} (E-If)}
\newcommand{\eift}[4]{\frac{\eiftrue{#3}{#4}}{\ifLC{#1}{#3}{#4} \rightarrow \ifLC{#2}{#3}{#4}} (E-If)}
\newcommand{\eiff}[4]{\frac{\eiffalse{#3}{#4}}{\ifLC{#1}{#3}{#4} \rightarrow \ifLC{#2}{#3}{#4}} (E-If)}
$$</p>
<h1 id="c谩lculo-lambda-tipado-booleano-lcb"><a class="header" href="#c谩lculo-lambda-tipado-booleano-lcb">C谩lculo Lambda Tipado Booleano \(\lcb\)</a></h1>
<h2 id="expresiones-de-tipos"><a class="header" href="#expresiones-de-tipos">Expresiones de tipos</a></h2>
<p>Las expresiones de tipos (o simplemente tipos) de \(\lcb\) son:</p>
<p>$$
\sigma, \tau ::= Bool | \sigma \rightarrow \tau
$$</p>
<p>En criollo,</p>
<ul>
<li>\(Bool\) es el tipo de los booleanos</li>
<li>\(\sigma \rightarrow \tau\) es el tipo de las funciones de tipo
\(\sigma\) en \(\tau\)</li>
</ul>
<p>Por ejemplo, uno puede tener una funci贸n \(Bool \rightarrow Bool\)</p>
<h2 id="t茅rminos-de-lambdab"><a class="header" href="#t茅rminos-de-lambdab">T茅rminos de \(\lambda^b\)</a></h2>
<p>Sea \(\mathcal{X}\) un conjunto infinito enumerable de variables y \(x \in \mathcal{X}\). Los t茅rminos de \(\lambda^b\) est谩n definidos por:</p>
<p>$$
\begin{align}
M,N,P,Q ::=&amp; \ x \\
&amp;| \ true \\
&amp;| \ false \\
&amp;| \ \ifLC{M}{P}{Q} \\
&amp;| \ \lf{x}{\sigma}{M} \\
&amp;| \ \apply{M}{N}
\end{align}
$$</p>
<p>Es importante entender que estas reglas <strong>s贸lo definen c贸mo construir sint谩cticamente los t茅rminos</strong>, pero no necesariamente te va a dar cosas que tengan sentido ni que sean 煤tiles. Veamos algunos ejemplos de t茅rminos v谩lidos:</p>
<ul>
<li>\(\lf{x}{Bool}{x}\)</li>
<li>\(\lf{x}{Bool}{\ifLC{x}{false}{true}}\)</li>
<li>\(\lf{f}{Bool \rightarrow Bool \rightarrow Bool}{\lf{x}{Bool}{\apply{f}{x}}}\)</li>
<li>\((\lf{f}{Bool \rightarrow Bool}{\apply{f}{true}})(\lf{y}{Bool}{y})\)</li>
<li>\(\apply{true}{(\lf{x}{Bool}{x})}\)</li>
<li>\(\apply{x}{y}\)</li>
</ul>
<h2 id="sistema-de-tipado"><a class="header" href="#sistema-de-tipado">Sistema de tipado</a></h2>
<ul>
<li>Es un sistema formal de deducci贸n/derivaci贸n que usa axiomas y reglas de
inferencia para caracterizar al conjunto de los conjuntos "bien tipados"</li>
<li>Lo definimos a partir de reglas de inferencia
<ul>
<li>axiomas de tipado para algunos t茅rminos</li>
<li>reglas de tipado para otros t茅rminos, que derivan (siempre y cuando se
pueda) el tipado de una expresi贸n en base a sus sub-expresiones.</li>
</ul>
</li>
</ul>
<h2 id="variables-libres"><a class="header" href="#variables-libres">Variables libres</a></h2>
<p>Ya vimos que tenemos funciones lambda que se pueden usar en la construcci贸n de
t茅rminos. Antes de seguir con otras cosas est谩 bueno definir y distinguir las
<strong>variables libres</strong> de las <strong>variables ligadas</strong>. Una variable \(x\) se dice
que ocurre libre si no est谩 bajo el alcance de alguna ocurrencia de un
\(\lambda x\). En otro caso decimos que ocurre ligada.</p>
<p><img src="./img/var_libre_vs_ligada.png#center" alt="" /></p>
<p>M谩s formalmente:</p>
<p>$$
\begin{align}
FV(x) &amp;\stackrel{def}{=} \{ x \} \\
FV(true) = FV(false) &amp;\stackrel{def}{=} \emptyset \\
FV(\ifLC{M}{P}{Q}) &amp;\stackrel{def}{=} FV(M) \cup FV(P) \cup FV(Q) \\
FV(\apply{M}{N}) &amp;\stackrel{def}{=} FV(M) \cup FV(N) \\
FV(\lf{x}{\sigma}{M}) &amp;\stackrel{def}{=} FV(M) \setminus \{x\} \\
\end{align}
$$</p>
<h2 id="sistema-de-tipado-1"><a class="header" href="#sistema-de-tipado-1">Sistema de tipado</a></h2>
<p>Un <strong>juicio de tipado</strong> es una expresi贸n de la forma \(\Gamma \triangleright M\ :\ \sigma\) que se lee como: "el t茅rmino \(M\) tiene tipo \(\sigma\) asumiendo el contexto de tipado \(\Gamma\)"</p>
<p>Un <strong>contexto de tipado</strong> por otro lado es un conjunto de pares \(x_i\ :\ \sigma_i\), anotado \(\{x_1\ :\ \sigma_1, \dots, x_n\ :\ \sigma_n\}\) donde los \(\{x_i\}_{i \in 1 \dots n}\) son distintos. Usamos letras \(\Gamma\), \(\bigtriangleup\), ... para contextos de tiapdo.</p>
<h2 id="axiomas-de-tipado-de-lcb"><a class="header" href="#axiomas-de-tipado-de-lcb">Axiomas de tipado de \(\lcb\)</a></h2>
<p>Obs: est谩n guiadas por la sint谩xis!</p>
<p>$$
\ttrue{\Gamma}
$$</p>
<p>$$
\tfalse{\Gamma}
$$</p>
<p>$$
\tvar{\Gamma}{x}{\sigma}
$$</p>
<p>$$
\tif{\Gamma}{M}{P}{Q}{\sigma}
$$</p>
<p>$$
\tabs{\Gamma}{x}{\sigma}{\tau}{M}
$$</p>
<p>$$
\tapp{\Gamma}{M}{\sigma}{\tau}{N}
$$</p>
<ul>
<li>Si \(\hastype{\Gamma}{M}{\sigma}\) puede derivarse usando los axiomas y reglas de tipado decimos que es derivable.</li>
<li>Decimos que \(M\) es tipable si el juicio de tiapdo \(\hastype{\Gamma}{M}{\sigma}\) puede derivarse, para alg煤n \(\Gamma\) y \(\sigma\).</li>
</ul>
<h2 id="resultados-b谩sicos-demostraci贸n-con-inducci贸n-estructural"><a class="header" href="#resultados-b谩sicos-demostraci贸n-con-inducci贸n-estructural">Resultados b谩sicos (demostraci贸n con inducci贸n estructural)</a></h2>
<h3 id="unicidad-de-tipos"><a class="header" href="#unicidad-de-tipos">Unicidad de tipos</a></h3>
<p>Si \(\hastype{\Gamma}{M}{\sigma}\) y \(\hastype{\Gamma}{M}{\tau}\) son derivables, entonces \(\sigma = \tau\).</p>
<h3 id="weakening--strengthening"><a class="header" href="#weakening--strengthening">Weakening + Strengthening</a></h3>
<p>Si \(\hastype{\Gamma}{M}{\sigma}\) es derivable y \(\Gamma \cap \Gamma'\) contiene a todas las variables libres de \(M\), entonces \(\hastype{\Gamma'}{M}{\sigma}\).</p>
<h2 id="sem谩ntica-o-sea-qu茅-hacen-mis-c贸mputos"><a class="header" href="#sem谩ntica-o-sea-qu茅-hacen-mis-c贸mputos">Sem谩ntica (o sea qu茅 hacen mis c贸mputos)</a></h2>
<p>Hasta ahora definimos para \(\lcb\) con reglas inductivas:</p>
<ul>
<li>una sint谩xis</li>
<li>un sistema de tipado</li>
</ul>
<p>Ahora vamos a darle significado a los t茅rminos que para nosotros tengan sentido
(o sea aquellos que est茅n bien tipados).</p>
<p>Hay distintas formas de definir la sem谩ntica, en particular vamos a dar una
<strong>sem谩ntica operacional</strong>. Nota: hay otros tipos de sem谩ntica, como la
sem谩ntica axiom谩tica (similar a lo que vimos en algo 1 con pre-condici贸n y
post-condici贸n, basada en aserciones), denotacional (le das una denotaci贸n a
cada t茅rmino del lenguaje y defin铆s la sem谩ntica dando funciones para los
elementos de la sintaxis).</p>
<p>En qu茅 consiste entonces la sem谩ntica operacional:</p>
<ul>
<li>interpreto a los t茅rminos como estados de una m谩quina abstracta</li>
<li>defino reglas para hacer evolucionar (reducir) los t茅rminos en otros t茅rminos
<ul>
<li>tambi茅n est谩n guiadas por sintaxis</li>
</ul>
</li>
<li>el <strong>significado</strong> de un t茅rmino \(M\) es el estado final que alcanza la
m谩quina si comienza con el estado inicial \(M\)</li>
<li>hay dos formas de dar la sem谩ntica operacional:
<ul>
<li><strong>small-step</strong>: describo pasos chiquitos. Vamos a ver principalmente
este.</li>
<li><strong>big-step (o natural semantics)</strong>: la funci贸n de transici贸n en un paso
reduce al resultado.</li>
</ul>
</li>
<li>definir la sem谩ntica tiene que hacerse de forma precisa cosa de poder llevar
todo a una implementaci贸n de un int茅rprete del lenguaje.</li>
</ul>
<h2 id="sem谩ntica-small-step"><a class="header" href="#sem谩ntica-small-step">Sem谩ntica small-step</a></h2>
<ul>
<li>La hacemos a trav茅s de <strong>juicios de evaluaci贸n</strong>, a.k.a. reglas de reducci贸n que se leen como "el t茅rmino \(M\) reduce en un paso al t茅rmino \(N\)":</li>
</ul>
<p>$$
M \rightarrow N
$$</p>
<ul>
<li>Uso axiomas de evaluaci贸n + reglas de derivaci贸n que establecen que algunos
juicios de evaluaci贸n son derivables a partir de otros juicios que tambi茅n
son derivables.</li>
<li>Adem谩s de la funci贸n de transici贸n, tenemos que definir los <strong>valores</strong>, que
son los posibles resultados de una evaluaci贸n de t茅rminos, en tanto sean
cerrados (no tiene variables libres) y est茅n bien tipados.</li>
</ul>
<h3 id="valores"><a class="header" href="#valores">Valores</a></h3>
<p>Como nuestro lambda c谩lculo es booleano, nos interesan true y false. O sea que
expresiones complejas tambi茅n pueden reducir a esos valores. O sea, todo
t茅rmino bien tiapdo y cerrado de tipo \(Bool\) eval煤a en cero o m谩s pasos, a
\(true\) o \(false\).</p>
<p>$$
V ::= true\ |\ false
$$</p>
<h3 id="juicio-de-evaluaci贸n-en-un-paso"><a class="header" href="#juicio-de-evaluaci贸n-en-un-paso">Juicio de evaluaci贸n en un paso</a></h3>
<p>Al If podemos pensarlo como que lo tenemos que reducir por completo el t茅rmino
del \(if\) hasta un valor, sea \(true\) o \(false\)</p>
<p>$$
\eiftrue{M_2}{M_3}
$$</p>
<p>$$
\eiffalse{M_2}{M_3}
$$</p>
<p>$$
\eif{M_1}{M_1'}{M_2}{M_3}
$$</p>
<div id="admonition-ejemplo" class="admonition admonish-info">
<div class="admonition-title">
<p>Ejemplo</p>
<p><a class="admonition-anchor-link" href="lambda_calc_booleano.html#admonition-ejemplo"></a></p>
</div>
<div>
<p>$$
\eiff{(\ifLC{false}{false}{true})}{true}{false}{true}
$$</p>
<p>Observaciones:</p>
<ul>
<li>No hay \(M\) tal que \(true \rightarrow M\)</li>
<li>Idem con \(false\)</li>
</ul>
</div>
</div>
<h4 id="algunas-propiedades-interesantes"><a class="header" href="#algunas-propiedades-interesantes">Algunas propiedades Interesantes</a></h4>
<ul>
<li><strong>Lema</strong> (Determinismo del juicio de evaluaci贸n en un paso): Si las reglas est谩n bien hechas, y \(M \rightarrow M'\) \(M \rightarrow M''\) entonces \(M' = M''\)</li>
<li>Una <strong>forma noraml</strong> es un t茅rmino que no puede evaluarse m谩s (o sea no existe una regla para reducir).</li>
<li>(recuerdo: un valor es el resultado al que puede evaluar un t茅rmino bien tipado y cerrado)</li>
<li><strong>Lema</strong>: todo valor est谩 en forma normal. No vale el rec铆proco en \(\lcb\). Por ejemplo:
<ul>
<li>\(\ifLC{x}{true}{false}\), no tengo c贸mo reducir porque \(x\) ta libre</li>
<li>\(x\), mismo caso</li>
<li>\(\apply{true}{false}\), no puedo reducir (tampoco tipa...)</li>
</ul>
</li>
<li>Lo vemos en un toque, pero el resultado m谩s fuerte es que si una expresi贸n es cerrada y bien tipada eventualmente puedo reducir hasta llegar a un valor.</li>
</ul>
<h3 id="evaluaci贸n-en-muchos-pasos"><a class="header" href="#evaluaci贸n-en-muchos-pasos">Evaluaci贸n en muchos pasos</a></h3>
<p>El <strong>juicio de evaluaci贸n en muchos pasos</strong> \(\twoheadrightarrow\) es la clausura reflexiva y transitiva de \(\rightarrow\). O sea es la menor relaci贸n tal que:</p>
<ol>
<li>Si \(M \rightarrow M'\), entonces \(M \twoheadrightarrow M'\)</li>
<li>\(M \twoheadrightarrow M\) para todo \(M\)</li>
<li>Si \(M \twoheadrightarrow M'\) y \(M' \twoheadrightarrow M''\), entonces \(M \twoheadrightarrow M''\)</li>
</ol>
<p>Por ejemplo, tenemos que:</p>
<p>$$
\ifLC{true}{(\ifLC{false}{false}{true})}{true} \twoheadrightarrow true
$$</p>
<h4 id="propiedades"><a class="header" href="#propiedades">Propiedades</a></h4>
<p>Para el c谩lculo de expresiones booleanas valen:</p>
<ul>
<li><strong>Lema</strong> (Unicidad de formas normales): Si \(M \twoheadrightarrow U\) y \(M \twoheadrightarrow V\), con \(U, V\) formas normales, entonces \(U = V\)</li>
<li><strong>Lema</strong> (Terminaci贸n): Para todo \(M\) existe una forma normal \(N\) tal que \(M \twoheadrightarrow \).
<ul>
<li>esto es bueno porque me aseguro que mi algoritmo de evaluaci贸n no tiene loops infinitos</li>
</ul>
</li>
</ul>
<h2 id="sem谩ntica-operacional-de-lcb"><a class="header" href="#sem谩ntica-operacional-de-lcb">Sem谩ntica Operacional de \(\lcb\)</a></h2>
<p>Ya hablamos antes de que en haskell por ejemplo, las funciones tambi茅n pueden ser resultados de una evaluaci贸n (eso de first class citizen, yada yada yada...). As铆 que por qu茅 no extendemos nuestro conjunto de valores:</p>
<p>$$
V ::= true\ false\ \lf{x}{\sigma}{M}
$$</p>
<p>Vamos a extender nuestro sistema tal que valgan los lemas previos, pero adem谩s valga el siguiente resultado:</p>
<div id="admonition-teorema" class="admonition admonish-abstract">
<div class="admonition-title">
<p>Teorema</p>
<p><a class="admonition-anchor-link" href="lambda_calc_booleano.html#admonition-teorema"></a></p>
</div>
<div>
<p>Para todo t茅rmino bien tipado y cerrado de tipo:</p>
<ul>
<li>\(Bool\) eval煤a, en cero o m谩s pasos, a \(true, false\).</li>
<li>\(\sigma \rightarrow \tau\) eval煤a, en cero o m谩s pasos, a \(\lf{x}{\sigma}{M}\), para alguna variable \(x\) y alg煤n t茅rmino \(M\)
<ul>
<li>en castellano: si tipa como una funci贸n eventualmente lo puedo reducir a la forma de una lambda con una variable y un t茅rmino</li>
</ul>
</li>
</ul>
</div>
</div>
<h3 id="juicio-de-evaluaci贸n-en-un-paso-1"><a class="header" href="#juicio-de-evaluaci贸n-en-un-paso-1">Juicio de evaluaci贸n en un paso</a></h3>
<ul>
<li>Primero, una regla que me haga reducir lo m谩s que pueda la "funci贸n" que quiero evaluar:</li>
</ul>
<p>$$
\frac{M_1 \rightarrow M_1'}{\apply{M_1}{M_2} \rightarrow \apply{M_1'}{M_2}} (E-App1 / \mu)
$$</p>
<ul>
<li>Segundo, una regla que me haga reducir lo m谩s que pueda al argumento:</li>
</ul>
<p>$$
\frac{M_2 \rightarrow M_2'}{\apply{(\lf{x}{\sigma}{M})}{M_2} \rightarrow \apply{(\lf{x}{\sigma}{M})}{M_2'}} (E-App1 / v)
$$</p>
<ul>
<li>Por 煤ltimo, una regla que se encargue del reemplazo de la evaluaci贸n</li>
</ul>
<p>$$
\frac{}{\apply{(\lf{x}{\sigma}{M})}{V} \rightarrow M \{x \leftarrow V\}} (E-AppAbs / \beta)
$$</p>
<ul>
<li>Esto 煤ltimo quiere decir agarrar la funci贸n lambda, y reemplazar sint谩cticamente las ocurrencias de \(x\) por \(V\)
<ul>
<li>sustituyo 煤nicamente las ocurrencias <strong>libres</strong> de \(x\)</li>
<li>le da sem谩ntica a la aplicaci贸n de funciones</li>
<li>hay que tener cuidado con los ligadores de variable (los \(\lambda x\))</li>
</ul>
</li>
</ul>
<p>Podemos dar una definici贸n basada en la sintaxis:</p>
<p>$$
\begin{align}
x \{x \leftarrow N\} &amp;\stackrel{def}{=} N \\
a \{x \leftarrow N\} &amp;\stackrel{def}{=} a \text{si a } \notin \{true, false\} \cup \mathcal{X} \setminus \{x\} \\
\ifLC{M}{P}{Q} \{x \leftarrow N\} &amp;\stackrel{def}{=} \ifLC{M\{x \leftarrow N\}}{P\{x \leftarrow N\}}{Q\{x \leftarrow N\}} \\
(\apply{M_1}{M_2}) \{x \leftarrow N\} &amp;\stackrel{def}{=} \apply{M_1\{x \leftarrow N\}}{M_2\{x \leftarrow N\}} \\
\lf{y}{\sigma}{M} \{x \leftarrow N\} &amp;\stackrel{def}{=} ? \\
\end{align}
$$</p>
<p>Y ese 煤ltimo? Imaginemos el caso de la sustituci贸n:</p>
<p>$$
\lf{z}{\sigma}{x} \{x \leftarrow N\} \stackrel{def}{=} \lf{z}{\sigma}{z}
$$</p>
<p>La convertimos de la funci贸n constante en la funci贸n identidad! Pero bueno, a
priori no importa qu茅 nombre tenga la variable ligada, no? Entonces, lo que
podemos hacer es renombrar (o asumir que se hizo el renombre para estas
reglas), de manera tal que la variable que se liga en la funci贸n lambda <strong>no
ocurre libre</strong> en \(N\). De ser as铆 la regla nos queda:</p>
<p>$$
\lf{y}{\sigma}{M} \{x \leftarrow N\} \stackrel{def}{=} \lf{y}{\sigma}{M\{x \leftarrow N\}}\ \ x \neq y, y \notin FV(N) \\
$$</p>
<p>Para formalizar esto aparece el concepto de \(\alpha\)-equivalencia. Dos
t茅rminos son \(\alpha\)-equivalentes si <strong>煤nicamente difieren en el nombre de
sus variables ligadas</strong>. Es una relaci贸n de equivalencia.</p>
<div id="admonition-algunos-ejemplos" class="admonition admonish-example">
<div class="admonition-title">
<p>Algunos ejemplos</p>
<p><a class="admonition-anchor-link" href="lambda_calc_booleano.html#admonition-algunos-ejemplos"></a></p>
</div>
<div>
<ul>
<li>\(\lf{x}{Bool}{x} =_{\alpha} \lf{y}{Bool}{y}\)</li>
<li>\(\lf{x}{Bool}{y} =_{\alpha} \lf{z}{Bool}{y}\)
<ul>
<li>ac谩 \(y\) es variable libre en ambos casos</li>
</ul>
</li>
<li>\(\lf{x}{Bool}{y} \neq_{\alpha} \lf{x}{Bool}{z}\)
<ul>
<li>ac谩 tanto \(y\) como \(z\) son variables libres y son distintas en cada t茅rmino.</li>
</ul>
</li>
<li>\(\lf{x}{Bool}{\lf{x}{Bool}{x}} \neq_{\alpha} \lf{y}{Bool}{\lf{x}{Bool}{y}}\)
<ul>
<li>ac谩 la lambda interna tiene en su subt茅rmino a la \(x\) ligada, mientras que del lado derecho no.</li>
</ul>
</li>
</ul>
<p>Llevado a la pr谩ctica, esto quiere decir que mientras hagamos las reducciones,
podemos tener que hacer el reemplazo por un t茅rmino \(\alpha\)-equivalente y
despu茅s aplicar la sustituci贸n.</p>
</div>
</div>
<h2 id="estado-de-error"><a class="header" href="#estado-de-error">Estado de error</a></h2>
<ul>
<li>Es un estado (t茅rmino) que <strong>no es</strong> un valor, pero en el que la evaluaci贸n est谩 <strong>trabada</strong>.</li>
<li>Representa un estado en el cual el sistema de runtime en una implementaci贸n real generar铆a una excepci贸n</li>
<li>Ejemplos:
<ul>
<li>\(\ifLC{x}{M}{N}\)
<ul>
<li>obs: no es cerrado</li>
</ul>
</li>
<li>\(\apply{true}{M}\)
<ul>
<li>obs: no es tipable</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="objetivo-de-un-sistema-de-tipos"><a class="header" href="#objetivo-de-un-sistema-de-tipos">Objetivo de un sistema de tipos</a></h2>
<p>Queremos garantizar la <strong>ausencia</strong> de estados de error. Decimos que un t茅rmino
<strong>termina</strong> o que es <strong>fuertemente normalizante</strong> si no hay cadenas de
reducci贸n infinitas a partir de 茅l.</p>
<div id="admonition-teorema-1" class="admonition admonish-note">
<div class="admonition-title">
<p>Teorema</p>
<p><a class="admonition-anchor-link" href="lambda_calc_booleano.html#admonition-teorema-1"></a></p>
</div>
<div>
<ul>
<li>Todo t茅rmino bien tipado termina</li>
<li>Si un t茅rmino cerrado est谩 bien tipado, entonces eval煤a a un valor</li>
</ul>
</div>
</div>
<p>Tenemos algunas propiedades que nos garantizan este teorema:</p>
<ul>
<li>Progreso: Si \(M\) es cerrado y bien tipado, entonces:
<ul>
<li>\(M\) es un valor</li>
<li>o bien existe \(M'\) tal que \(M \rightarrow M'\) (o sea no se traba si los t茅rminos son cerrados y bien tipados, y no son valores)</li>
</ul>
</li>
<li>Preservaci贸n (de tipo): Si \(\hastype{\Gamma}{M}{\sigma}\) y \(M \rightarrow N\), entonces \(\hastype{\Gamma}{N}{\sigma}\) (o sea que la reducci贸n/evaluaci贸n preserva tipos).</li>
</ul>
<blockquote>
<p><strong>Observaci贸n</strong>: parto de progreso. O bien es un valor, o tengo el t茅rmino al
que reducir. Luego por preservaci贸n de tipos, aplicar la reducci贸n nos dice
que el nuevo t茅rmino est谩 bien tipado, y sigue siendo cerrado.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>$$
\newcommand{\lcb}{\lambda^b}
\newcommand{\lce}{\lambda^{bn}}
\newcommand{\lcr}{\lambda^{\dots n}}
\newcommand{\lcu}{\lambda^{bnu}}
\newcommand{\lclet}{\lambda^{\dots let}}
\newcommand{\ifLC}[3]{if\  {#1}\  then\  {#2}\  else\  {#3}}
\newcommand{\lf}[3]{\lambda{#1}:\ {#2}.{#3}}
\newcommand{\apply}[2]{{#1}\ {#2}}
\newcommand{\hastype}[3]{{#1} \triangleright {#2}: {#3}}
\newcommand{\tzero}[1]{\frac{}{\hastype{\Gamma}{0}{Nat}}  (T-Zero)}
\newcommand{\tsucc}[2]{\frac{\hastype{#1}{#2}{Nat}}{\hastype{\Gamma}{succ(M)}{Nat}}  (T-Succ)}
\newcommand{\tpred}[2]{\frac{\hastype{#1}{#2}{Nat}}{\hastype{\Gamma}{pred(M)}{Nat}}  (T-Pred)}
\newcommand{\tiszero}[2]{\frac{\hastype{#1}{#2}{Nat}}{\hastype{\Gamma}{iszero(M)}{Bool}}  (T-IsZero)}
\newcommand{\esucc}[2]{\frac{#1 \rightarrow #2}{succ(#1) \rightarrow succ(#2)} (E-Succ)}
\newcommand{\epredzero}{\frac{}{pred(0) \rightarrow 0} (E-PredZero)}
\newcommand{\epredsucc}[1]{\frac{}{pred(#1 + 1) \rightarrow #1} (E-PredSucc)}
\newcommand{\epred}[2]{\frac{#1 \rightarrow #2}{pred(#1) \rightarrow pred(#2)} (E-Pred)}
\newcommand{\eiszerozero}{\frac{}{iszero(0) \rightarrow true} (E-IsZeroZero)}
\newcommand{\eiszerosucc}{\frac{}{iszero(n + 1) \rightarrow false} (E-IsZeroSucc)}
\newcommand{\eiszero}[2]{\frac{#1 \rightarrow #2}{iszero(#1) \rightarrow iszero(#2)} (E-IsZero)}
$$</p>
<h1 id="c谩lculo-lambda-tipado-extendido-lce"><a class="header" href="#c谩lculo-lambda-tipado-extendido-lce">C谩lculo Lambda Tipado Extendido \(\lce\)</a></h1>
<p>Idea: extendamos \(lcb\) para agregar los n煤meros naturales y as铆 darle mayor utilidad.</p>
<blockquote>
<p>Nota: esta idea de extender el lenguaje es interesante m谩s all谩 de lo
te贸rico, en la pr谩ctica si uno quiere agregar un feature a un lenguaje tiene
que considerar qu茅 pasos son necesarios para extenderlo.</p>
</blockquote>
<h2 id="tipos-y-t茅rminos-de-lce"><a class="header" href="#tipos-y-t茅rminos-de-lce">Tipos y T茅rminos de \(\lce\)</a></h2>
<p>Los tipos son:</p>
<p>$$
\sigma ::= Bool\ Nat\ \sigma \rightarrow \rho
$$</p>
<p>Y los t茅rminos son:</p>
<p>$$
M ::= \dots | 0 | succ(M) | pred(M) | iszero(M)
$$</p>
<p>donde tengo los t茅rminos del \(lcb\) usual m谩s los aqu铆 definidos:</p>
<ul>
<li>\(succ(M)\): evaluar \(M\) hasta que de un n煤mero e incrementarlo.</li>
<li>\(pred(M)\): evaluar \(M\) hasta que de un n煤mero y decrementarlo.</li>
<li>\(iszero(M)\): evaluar \(M\) hasta que de un n煤mero y luego devolver \(true / false\) seg煤n sea cero o no.</li>
</ul>
<h2 id="reglas-de-tipado-de-lce"><a class="header" href="#reglas-de-tipado-de-lce">Reglas de tipado de \(lce\)</a></h2>
<p>Junto con las reglas y axiomas previamente definidas para \(lcb\), se le suman:</p>
<p>$$
\tzero{\Gamma}
$$</p>
<p>$$
\tsucc{\Gamma}{M}
$$</p>
<p>$$
\tpred{\Gamma}{M}
$$</p>
<p>$$
\tiszero{\Gamma}{M}
$$</p>
<h2 id="valores-lce"><a class="header" href="#valores-lce">Valores \(\lce\)</a></h2>
<p>Valores:</p>
<p>$$
V ::= \dots |\ n\ \text{ donde n abrevia } succ^n(0)
$$</p>
<p>Esto ya nos da una idea de que si tengo un \(succ(M)\) voy a querer reducir lo de adentro tanto como pueda</p>
<h2 id="juicio-de-evaluaci贸n-en-un-paso-2"><a class="header" href="#juicio-de-evaluaci贸n-en-un-paso-2">Juicio de evaluaci贸n en un paso</a></h2>
<p>Ahora le damos la sem谩ntica. Igual que para el tipado, usamos las mismas reglas que antes sumando:</p>
<ul>
<li>Para succ y pred:</li>
</ul>
<p>$$
\esucc{M_1}{M_1'}
$$</p>
<p>$$
\epredzero
$$</p>
<p>$$
\epredsucc{n}
$$</p>
<p>$$
\epred{M_1}{M_1'}
$$</p>
<ul>
<li>Para iszero:</li>
</ul>
<p>$$
\eiszerozero
$$</p>
<p>$$
\eiszerosucc
$$</p>
<p>$$
\eiszero{M_1}{M_1'}
$$</p>
<blockquote>
<p>Algunas observaciones:</p>
<ul>
<li>Tanto \(E-Succ\) y \(E-Pred\) intentan reducir el argumento hasta llevarlo a un valor</li>
<li>pred adem谩s reduce cuando tiene adentro un succ (a pesar de estar en forma normal)</li>
<li>iszero reduce hasta tener un valor y despu茅s hace el chequeo</li>
</ul>
</blockquote>
<h1 id="c谩lculo-lambda-tipado-extendido-lcr"><a class="header" href="#c谩lculo-lambda-tipado-extendido-lcr">C谩lculo Lambda Tipado Extendido \(\lcr\)</a></h1>
<h2 id="tipos-1"><a class="header" href="#tipos-1">Tipos</a></h2>
<p>Podemos pensar a los registros como un struct de C ponele. Incluso m谩s simple,
es un conjunto de tuplas <strong>ordenado</strong> (nombre, valor).</p>
<p>Para suponemos que tenemos \(\mathcal{L}\) un conjunto de etiquetas y sumamos el nuevo tipo:</p>
<p>$$
\sigma ::= \dots |\ \{l_i : \sigma_i^{i \in 1 \dots n}\}
$$</p>
<blockquote>
<p>Observaci贸n: los registros pueden tener subregistros adentro. Por ejemplo:</p>
</blockquote>
<h2 id="t茅rminos"><a class="header" href="#t茅rminos">T茅rminos</a></h2>
<p>$$
M ::= \dots |\ \{l_i = M_i^{i \in 1 \dots n}\} |\ M.I
$$</p>
<p>Informalmente hablando:</p>
<ul>
<li>El registro \(\{l_i = M_i^{i \in 1 \dots n}\}\) eval煤a a \(\{l_i = V_i^{i \in 1 \dots n}\}\), donde \(V_i\) es el valor al que eval煤a \(M_i\), \(i \in 1 \dots n\).</li>
<li>\(M.I\), la proyecci贸n, consiste en evaluar \(M\) hasta obtener \(\{l_i = V_i^{i \in 1 \dots n}\}\) y luego proyectar al campo correspondiente.</li>
</ul>
<p>Algunos ejemplos:</p>
<p><img src="./img/ejemplo_lcr.png#center" alt="" /></p>
<ol>
<li>Dado un \(x\) de tipo \(Nat\) y un \(y\) de tipo \(Bool\), genera un registro donde pongo en \(edad\) a \(x\) y en \(esMujer\) a \(y\).</li>
<li>Dado un registro que tiene 2 campos, aplica la proyecci贸n del campo \(edad\)</li>
<li>Este 煤ltimo es igual al anterior pero se eval煤a en lugar de obtener una funci贸n y listo</li>
</ol>
<h2 id="reglas-de-tipado"><a class="header" href="#reglas-de-tipado">Reglas de tipado</a></h2>
<p>$$
\frac{\Gamma \triangleright M_i : \sigma_i\ \text{para cada } i \in 1 \dots n}{\Gamma \triangleright \{l_i = M_i^{i \in 1 \dots n} \} : \{l_i : \sigma_i^{i \in 1 \dots n}\}} (T-RCD)
$$</p>
<p>$$
\frac{\Gamma \triangleright M_i : \{l_i : \sigma_i^{i \in 1 \dots n}\}\ j \in 1 \dots n}{\Gamma \triangleright M.I_j : \sigma_j} (T-Proj)
$$</p>
<h2 id="sem谩ntica-operacional-de-lcr"><a class="header" href="#sem谩ntica-operacional-de-lcr">Sem谩ntica operacional de \(lcr\)</a></h2>
<h3 id="valores-1"><a class="header" href="#valores-1">Valores</a></h3>
<p>Agrego los registros como posibles valores (en tanto todos sus elementos sean valores tambi茅n):</p>
<p>$$
V ::= \dots |\ \{l_i = V_i^{i \in 1 \dots n}\}
$$</p>
<h3 id="reglas-de-reducci贸n"><a class="header" href="#reglas-de-reducci贸n">Reglas de reducci贸n</a></h3>
<p>La primer regla nos da la idea de que s铆 o si tengo que reducir en el orden de las etiquetas:</p>
<p>$$
\frac{M_j \rightarrow M_j'}{\{l_i = V_i^{i \in 1 \dots j-1}, l_j = M_j, l_i = M_i^{i \in j+1 \dots n}\} \rightarrow \{l_i = V_i^{i \in 1 \dots j-1}, l_j = M_j', l_i = M_i^{i \in j+1 \dots n}\}} (E-RCD)
$$</p>
<p>Luego tenemos las reglas para la proyecci贸n:</p>
<p>$$
\frac{j \in 1 \dots n}{\{l_i = V_i^{i \in 1 \dots n}\}.l_j \rightarrow V_j} (E-ProjRCD)
$$</p>
<p>$$
\frac{M \rightarrow M'}{M.I \rightarrow M'.I} (E-ProjRCD)
$$</p>
<p>O sea que primero reduzco antes de proyectar, y reduzco en el orden de las
etiquetas. Una vez que llegu茅 a una expresi贸n de registro en forma normal,
reci茅n ah铆 hago el reemplazo por el valor correspondiente a la etiqueta.</p>
<h1 id="c谩lculo-lambda-tipado-extendido-lcu"><a class="header" href="#c谩lculo-lambda-tipado-extendido-lcu">C谩lculo Lambda Tipado Extendido \(\lcu\)</a></h1>
<p>Vamos a agregar un nuevo tipo, que se va a comportar similar a lo que es el void en C o C++. A este tipo lo vamos a llamar \(Unit\). No nos importa mucho qu茅 retorna.</p>
<h2 id="tipos-y-t茅rminos-de-lcu"><a class="header" href="#tipos-y-t茅rminos-de-lcu">Tipos y t茅rminos de \(\lcu\)</a></h2>
<p>$$
\sigma ::= Bool\ |\ Nat\ |\ \textbf{Unit}\ |\ \sigma \rightarrow \rho
$$</p>
<p>$$
M ::= \dots\ |\ unit
$$</p>
<h2 id="reglas-de-tipado-1"><a class="header" href="#reglas-de-tipado-1">Reglas de tipado</a></h2>
<p>Se agrega un axioma de tipado:</p>
<p>$$
\frac{}{\hastype{\Gamma}{unit}{Unit}}
$$</p>
<blockquote>
<p>Observaciones:</p>
<ul>
<li>no se agregan reglas de evaluaci贸n nuevas</li>
<li>Se extiende el conjunto de valores \(V\) con \(unit\):
$$
V ::= \dots\ |\ unit
$$</li>
</ul>
</blockquote>
<h2 id="utilidad-de-unit"><a class="header" href="#utilidad-de-unit">Utilidad de Unit</a></h2>
<ul>
<li>El principal uso es en lenguajes que tienen side effects.</li>
<li>En dichos lenguajes es 煤til poder evaluar varias expresiones secuencialmente. Entonces definimos:</li>
</ul>
<p>$$
M_1;M_2 \stackrel{def}{=} \apply{(\lf{x}{Unit}{M_2})}{M_1}\ \ \ x \notin FV(M_2)
$$</p>
<ul>
<li>La evaluaci贸n de \(M_1;M_2\) consiste en nprimero evaluar \(M_1\) y luego \(M_2\).</li>
<li>Bajo esta definici贸n, el comportamiento se da con las reglas de evaluaci贸n ya existentes.</li>
</ul>
<blockquote>
<p><em>Obs</em>: por ahora nuestro lenguaje no tiene side effects, ya vamos a llegar a eso.</p>
</blockquote>
<h1 id="c谩lculo-lambda-tipado-extendido-lclet"><a class="header" href="#c谩lculo-lambda-tipado-extendido-lclet">C谩lculo Lambda Tipado Extendido \(\lclet\)</a></h1>
<p>En este caso, vamos a agregar una feature que no introduce tipos, y tampoco
introduce mecanismos de ejecuci贸n necesariamente pero si aporta legibilidad. Es
el equivalente en c谩lculo lambda del <code>f = ... where ...</code> de haskell.</p>
<h2 id="t茅rminos-1"><a class="header" href="#t茅rminos-1">T茅rminos</a></h2>
<p>$$
M ::= \dots\ |\ let\ x : \sigma = M\ in\ N
$$</p>
<p>La idea es evaluar \(M\) hasta un valor \(V\), ligamos \(x\) a \(V\) y evaluamos \(N\). Algunos ejemplos:</p>
<ul>
<li><code>let x: Nat = 2 in succ(x)</code></li>
<li><code>pred (let x: Nat = 2 in x)</code></li>
<li><code>let f: Nat -&gt; Nat = \x: Nat.succ(n) in f(f(0))</code></li>
<li><code>let x: Nat = 2 in let x: Nat = 3 in x</code></li>
</ul>
<h2 id="tipado"><a class="header" href="#tipado">Tipado</a></h2>
<p>Si bien no agregamos tipos, si tenemos una regla de tipado:</p>
<p>$$
\frac{\hastype{\Gamma}{M}{\sigma_1}\ \ \ \hastype{\Gamma,\ x:\sigma_1}{N}{\sigma_2}}{\hastype{\Gamma}{let\ x: \sigma_1 = M\ in\ N}{\sigma_2}} (T-Let)
$$</p>
<blockquote>
<p><strong>Obs</strong>: la regla tiene un aire a \(T-Abs\)</p>
</blockquote>
<h2 id="sem谩ntica-operacional-de-lclet"><a class="header" href="#sem谩ntica-operacional-de-lclet">Sem谩ntica operacional de \(\lclet\)</a></h2>
<p>Tenemos 2 reglas, una para reducir y otra cuando llego a un valor:</p>
<p>$$
\frac{M_1 \rightarrow M_1'}{let\ x: \sigma = M_1\ in\ M_2 \rightarrow let\ x: \sigma = M_1'\ in\ M_2} (E-Let)
$$</p>
<p>$$
\frac{}{let\ x: \sigma = V_1\ in\ M_2 \rightarrow \apply{M_2}{\{x \leftarrow V_1\}}} (E-LetV)
$$</p>
<h2 id="interpretando-el-let"><a class="header" href="#interpretando-el-let">Interpretando el <code>let</code></a></h2>
<p>En una expresi贸n como <code>let x: Nat = 2 in M</code>:</p>
<ul>
<li>x se declara con el valor 2</li>
<li>x es inalterado a lo largo de la evaluaci贸n de M</li>
<li>en este sentido x es <strong>inmutable</strong>. No hay operaci贸n de asignaci贸n</li>
</ul>
<p>Lo siguiente es agregar variables <strong>mutables</strong> (casi que estamos saliendo del terreno del lenguaje funcional y meti茅ndonos en el terreno del lenguaje mutable)</p>
<h1 id="c谩lculo-lambda-con-variables-mutables"><a class="header" href="#c谩lculo-lambda-con-variables-mutables">C谩lculo Lambda con variables mutables</a></h1>
<p>Vamos a agregar algunas operaciones b谩sicas:</p>
<ul>
<li>Reserva de memoria (allocation): \(ref M\) genera una referencia fresca cuyo contenido es el valor de \(M\).</li>
<li>Desreferenciaci贸n (lectura): \(!x\) sigue la referencia \(x\) y retorna su contenido.</li>
<li>Asignaci贸n: \(x := M\) almacena en la referencia \(x\) el valor de \(M\).</li>
</ul>
<div id="admonition-algunos-ejemplos" class="admonition admonish-example">
<div class="admonition-title">
<p>Algunos Ejemplos</p>
<p><a class="admonition-anchor-link" href="lambda_calc_extendido.html#admonition-algunos-ejemplos"></a></p>
</div>
<div>
<p>(Nota: se omiten los tipos de las expreciones para facilitar la lectura, perdemos algo de formalismo. Sepan comprender)</p>
<ul>
<li><code>let x = ref 2 in !x</code> eval煤a a 2</li>
<li><code>let x = ref 2 in (\_: Unit.!x) (x := succ(!x))</code> eval煤a a 3 (es lo mismo que
hacer <code>x := succ(!x); !x</code>)</li>
<li><code>let x = 2 in x</code> eval煤a a 2</li>
<li><code>let x = ref 2 in x</code> a qu茅 eval煤a? A priori no sabemos (todav铆a no vimos qu茅
devuelve un <code>ref 2</code>)</li>
<li><code>let x = ref 2 in let y = x in (\_: Unit.!x) (y := succ(!y))</code> eval煤a a 3.
Primero reemplaza el y por la referencia, y despu茅s es igual al segundo
ejemplo. Obtuve en este caso un alias a la celda de memoria.</li>
</ul>
<p><strong>Obs</strong>: x sigue <strong>siendo inmutable</strong> pero en los primeros 2 casos lo que es inmutable es la referencia a la memoria, no su contenido.</p>
</div>
</div>
<h2 id="comandos"><a class="header" href="#comandos">Comandos</a></h2>
<p>Pregunta: el t茅rmino <code>let x = ref 2 in x := succ(!x)</code>, a qu茅 eval煤a? En la operaci贸n de asignaci贸n s贸lo interesa el efecto que tiene, por lo tanto la definimos como que eval煤a a \(unit\). Esto es lo que conocemos como <strong>comando</strong></p>
<h2 id="formalizando"><a class="header" href="#formalizando">Formalizando</a></h2>
<h3 id="expresiones-de-tipos-1"><a class="header" href="#expresiones-de-tipos-1">Expresiones de tipos</a></h3>
<div style="float:right;margin-left:2rem;margin-bottom:1rem;margin-top:-6rem;width:330px">
<div id="admonition-achievement-unlocked" class="admonition admonish-success">
<div class="admonition-title">
<p>Achievement Unlocked</p>
<p><a class="admonition-anchor-link" href="lambda_calc_extendido.html#admonition-achievement-unlocked"></a></p>
</div>
<div>
<p>Wow, ya desbloqueamos los punteros a funciones!</p>
<p><img src="./img/function_pointer.png" alt="" /></p>
</div>
</div>
</div>
<p>\(Ref \sigma\) va a ser el tipo de las referencias a valores de tipo \(\sigma\). O sea \(Ref (Bool \rightarrow Nat)\) es el tipo de las referencias a funciones de \(Bool\) en \(Nat\).</p>
<p>$$
\sigma ::= Bool\ |\ Nat\ |\ \sigma \rightarrow \tau\ |\ Unit\ |\ Ref \sigma
$$</p>
<h3 id="t茅rminos-2"><a class="header" href="#t茅rminos-2">T茅rminos</a></h3>
<p>$$
M ::= \dots\ |\ ref\ M\ |\ !M\ |\ M := N\ |\ l
$$</p>
<div style="width:330px">
<blockquote>
<p>Nota: por ahora ignorar el 煤ltimo t茅rmino pero es el que corresponde a las
referencias propiamente dichas (idealemente no se exponen al "programador"
pero en la maquinaria l贸gica hay que tenerlas en consideraci贸n)</p>
</blockquote>
</div>
<h3 id="reglas-de-tipado-2"><a class="header" href="#reglas-de-tipado-2">Reglas de tipado</a></h3>
<p>El tipo de la referencia es una referencia al tipo del t茅rmino:</p>
<p>$$
\frac{\hastype{\Gamma}{M_1}{\sigma}}{\hastype{\Gamma}{ref\ M_1}{Ref\ \sigma}} (T-Ref)
$$</p>
<p>El tipo de la desreferencia es el tipo interno de la referencia:</p>
<p>$$
\frac{\hastype{\Gamma}{M_1}{Ref\ \sigma}}{\hastype{\Gamma}{!M_1}{\sigma}} (T-DeRef)
$$</p>
<p>Por 煤ltimo, el tipo de una asignaci贸n es siempre unit y adem谩s el tipo de la variabla tiene que ser una referencia del tipo que se est谩 asignando:</p>
<p>$$
\frac{\hastype{\Gamma}{M_1}{Ref\ \sigma_1}\ \ \hastype{\Gamma}{M_2}{\sigma_1}}{\hastype{\Gamma}{M_1 := M_2}{Unit}} (T-Assign)
$$</p>
<h3 id="sem谩ntica"><a class="header" href="#sem谩ntica">Sem谩ntica</a></h3>
<p>Al intentar formalizar la sem谩ntica operacional surgen 2 preguntas:</p>
<ul>
<li>Cu谩les son los valores de tipo \(Ref \sigma\)</li>
<li>C贸mo modelo la evaluaci贸n del t茅rmino \(ref M\)</li>
</ul>
<p>Para poder responder esto tenemos que responder antes a la pregunta: <em>qu茅 es una referencia</em> (rta: es una abstracci贸n de una porci贸n de memoria que se encuentra en uso).</p>
<p>Entonces, vamos a tener que modelar la memoria!</p>
<ul>
<li>Usamos direcciones simb贸licas o "locations" \(l, l_i \in \mathcal{L}\) para representar referencias.</li>
<li>La memoria o store va a ser una funci贸n parcial de direcciones a valores (a.k.a un diccionario).</li>
<li>Usamos \(\mu, \mu'\) para referirnos a stores</li>
<li>Notaci贸n:
<ul>
<li>\(\mu[l \rightarrow V]\) es el store resultante de pisar \(\mu(l)\) con \(V\).</li>
<li>\(\mu \oplus (l \rightarrow V)\) es el store extendido resultante de ampliar \(\mu\) con una nueva asociaci贸n \(l \rightarrow V\) (asumiendo \(l \notin Dom(\mu)\), porque si no hubiese usado la sint谩xis de arriba).</li>
</ul>
</li>
<li>Cambia tambi茅n ligeramente la sintaxis de los juicios de valor:</li>
</ul>
<p>$$
M\ |\ \mu \rightarrow M'\ |\ \mu'
$$</p>
<div id="admonition-juicios-de-tipado" class="admonition admonish-note">
<div class="admonition-title">
<p>juicios de tipado</p>
<p><a class="admonition-anchor-link" href="lambda_calc_extendido.html#admonition-juicios-de-tipado"></a></p>
</div>
<div>
<p>Agregar las location nos obliga a agregar nuevas reglas de tipado. En particular, cu谩l ser铆a el tipo de \(\hastype{\Gamma}{l}{?}\)?</p>
<ul>
<li>Depende de qu茅 valores se almacenen en \(l\)</li>
<li>Tengo un problema similar al de las variables libres</li>
<li>Tenemos que introducir entonces un <strong>contexto de tipado</strong> para direcciones \(\Sigma\)</li>
</ul>
<p>Nuevo formato de los juicios de tipado:</p>
<p>$$
\hastype{\Gamma | \Sigma}{M}{\sigma}
$$</p>
<p>Y Nueva regla de tipado:</p>
<p>$$
\frac{\Sigma(l) = \sigma}{\hastype{\Gamma | \Sigma}{l}{Ref \sigma}} (T-Loc)
$$</p>
</div>
</div>
<h4 id="valores-2"><a class="header" href="#valores-2">Valores</a></h4>
<p>Adem谩s de los ya existentes, incluimos las direcciones al conjunto de valores:</p>
<p>$$
V ::= \dots\ |\ unit\ |\ \lf{x}{\sigma}{M}\ |\ l
$$</p>
<h4 id="operaciones-de-reducci贸n-en-un-paso"><a class="header" href="#operaciones-de-reducci贸n-en-un-paso">Operaciones de reducci贸n en un paso</a></h4>
<p>Reglas para ref:</p>
<p>$$
\frac{M_1\ |\ \mu \rightarrow M_1'\ |\ \mu' \rightarrow}{(ref\ M_1 | \mu) \rightarrow ref\ M_1' | \mu} (E-RefV)
$$</p>
<p>$$
\frac{l \notin Dom(\mu)}{(ref V\ | \mu) \rightarrow (l | \mu \oplus (l \rightarrow V))} (E-RefV)
$$</p>
<p>Reglas para la desreferenciaci贸n:</p>
<p>$$
\frac{M_1 | \mu \rightarrow M_1' | \mu'}{!M_1 | \mu \rightarrow !M_1' | \mu} (E-Deref)
$$</p>
<p>$$
\frac{\mu(l) = V}{!l | \mu \rightarrow V | u} (E-DerefLoc)
$$</p>
<p>Las reglas para la asignaci贸n:</p>
<p>Dejo evolucionar el lado de la etiqueta:</p>
<p>$$
\frac{M_1\ |\ \mu \rightarrow M_1'\ |\ \mu'}{M_1 := M_2\ |\ \mu \rightarrow M_1' := M_2\ |\ \mu' } (E-Assign1)
$$</p>
<p>Cuando llegu茅 al valor eval煤o lo que se asigna:</p>
<p>$$
\frac{M_2\ |\ \mu \rightarrow M_2'\ |\ \mu'}{V := M_2\ |\ \mu \rightarrow V := M_2'\ |\ \mu' } (E-Assign2)
$$</p>
<p>Por 煤ltimo, la evaluaci贸n se reduce a \(unit\),  pero la memoria se modifica:</p>
<p>$$
\frac{}{l := V\ |\ \mu \rightarrow unit\ |\ \mu[l \rightarrow V] } (E-Assign)
$$</p>
<h2 id="revisitando-reglas-de-evaluaci贸n-viejas"><a class="header" href="#revisitando-reglas-de-evaluaci贸n-viejas">Revisitando reglas de evaluaci贸n viejas</a></h2>
<p>Como ahora tenemos el store, tenemos que actualizar todas las reglas previas.
Veamos un par de ejemplos de la aplicaci贸n pero en general la regla es la misma
y lo 煤nico que hay que reflejar es si el store puede cambiar o no.</p>
<p>$$
\frac{M_1\ |\ \mu \rightarrow M_1'\ |\ \mu'}{\apply{M_1}{M_2}\ |\ \mu \rightarrow \apply{M_1'}{M_2}\ |\ \mu'} (E-App1)
$$</p>
<p>$$
\frac{M_2\ |\ \mu \rightarrow M_2'\ |\ \mu'}{\apply{V_1}{M_2}\ |\ \mu \rightarrow \apply{V_1}{M_2'}\ |\ \mu'} (E-App2)
$$</p>
<p>Notar que para cuando hacemos la aplicaci贸n, al ser un reemplazo sint谩ctico el store no cambia:</p>
<p>$$
\frac{}{\apply{(\lf{x}{\sigma}{M})}{V}\ |\ \mu \rightarrow M \{x \leftarrow V\}\ |\ \mu} (E-AppAbs)
$$</p>
<h2 id="the-last-crusade-correcci贸n-de-sistema-de-tipos"><a class="header" href="#the-last-crusade-correcci贸n-de-sistema-de-tipos">The last crusade: Correcci贸n de sistema de tipos</a></h2>
<p>Como vimos para \(\lcb\), pod铆amos asegurar dos caracter铆sticas que eran:</p>
<ul>
<li>progreso: si \(M\) es cerrado y bien tipado entonces o bien es un valor o
se puede reducir a un t茅rmino \(M'\)</li>
<li>preservaci贸n: si \(M\) es de tipo \(\sigma\) bajo el contexto
\(\Gamma\), y se reduce a otro t茅rmino \(N\), entonces ese nuevo t茅rmino
tambi茅n va a ser de tipo \(\sigma\). O sea que la reducci贸n preserva tipos.</li>
</ul>
<p>Tenemos que poder reformular estas propiedades en el marco del lambda c谩lculo
tipado con referencias (y registros y otras cosas, aunque lo relevante son las
referencias).</p>
<div id="admonition-primer-intento" class="admonition admonish-warning">
<div class="admonition-title">
<p>Primer intento</p>
<p><a class="admonition-anchor-link" href="lambda_calc_extendido.html#admonition-primer-intento"></a></p>
</div>
<div>
<p>Qu茅 pasa con la siguiente formulaci贸n?</p>
<blockquote>
<p>Si \(\hastype{\Gamma | \Sigma}{M}{\sigma}\) y \(M\ |\ \mu \rightarrow M'\ |\ \mu'\) entonces \(\hastype{\Gamma | \Sigma}{M'}{\sigma}\)</p>
</blockquote>
<p>El problema que tenemos con esto es que la sem谩ntica puede no respetar los tipos asumidos para las direcciones (o sea \(\sigma\))</p>
<p>Por ejemplo, supongamos que:</p>
<ul>
<li>\(M = !l \)</li>
<li>\(\Gamma = \emptyset \)</li>
<li>\(\Sigma(l) = Nat \)</li>
<li>\(\mu(l) = true \)</li>
</ul>
<p>Esto ya de por si es raro porque significar铆a que nuestro tipo dice que tenemos
un \(Nat\) pero guardamos un valor booleano. Pero bueno, no est谩 restringido
en lo que enunciamos.</p>
<p>Observar que:</p>
<ul>
<li>\(\hastype{\Gamma | \Sigma}{M}{Nat} \) y</li>
<li>\(M\ |\ \mu \rightarrow true\ |\ \mu \)</li>
<li>pero \(\hastype{\Gamma | \Sigma}{true}{Nat}\) no vale</li>
</ul>
<p>Lo importante es la <strong>coordinaci贸n entre el contexto de tipado</strong> \(\Sigma\) <strong>y el valor en el store durante la evaluaci贸n</strong> \(\mu\)</p>
</div>
</div>
<h3 id="reformulando-preservaci贸n"><a class="header" href="#reformulando-preservaci贸n">Reformulando preservaci贸n</a></h3>
<p>Tenemos que hablar de compatibilidad / coordinaci贸n entre el store y el
contexto de tipado para stores (se podr铆a pensar que "tipamos" los stores).</p>
<p>Para eso intrducimos un nuevo "juicio de tiapdo" para el store:</p>
<p>$$
\Gamma | \Sigma \triangleright \mu \iff
$$</p>
<ul>
<li>\(Dom(\Sigma) = Dom(\mu)\)</li>
<li>\(\hastype{\Gamma | \Sigma}{\mu(l)}{\Sigma(l)} \text{ para todo } l \in Dom(\mu)\)</li>
</ul>
<p>Con esto definido, podemos reformular la propiedad de preservaci贸n:</p>
<blockquote>
<p>Si \(\hastype{\Gamma | \Sigma}{M}{\sigma}\) y \(M\ |\ \mu \rightarrow N\ |\ \mu'\) y \(\Gamma | \Sigma \triangleright \mu\) entonces \(\hastype{\Gamma | \Sigma}{N}{\sigma}\)</p>
</blockquote>
<p>Pero de vuelta, tenemos que considerar una cosa m谩s. En el paso de evaluaci贸n,
pudo haber cambiado el store. Entonces necesitamos tambi茅n incluir dicha
consideraci贸n.</p>
<blockquote>
<p>Si</p>
<ul>
<li>\(\hastype{\Gamma | \Sigma}{M}{\sigma}\)</li>
<li>\(M\ |\ \mu \rightarrow N\ |\ \mu'\)</li>
<li>\(\Gamma | \Sigma \triangleright \mu\)</li>
</ul>
<p>entonces existe un \(\Sigma' \subseteq \Sigma\) tal que:</p>
<ul>
<li>\(\hastype{\Gamma | \Sigma'}{N}{\sigma}\)</li>
<li>\(\Gamma\ |\ \Sigma' \triangleright \mu'\)</li>
</ul>
</blockquote>
<h3 id="reformulando-progreso"><a class="header" href="#reformulando-progreso">Reformulando progreso</a></h3>
<p>Si \(M\) es cerrado y bien tipado (es decir, \(\hastype{\emptyset | \Sigma}{M}{\sigma}\)) para alg煤n \Sigma,\sigma) entonces:</p>
<ul>
<li>\(M\) es un valor (o sea el store qued贸 fijo)</li>
<li>o bien para cualquier store \(\mu\) tal que \(\emptyset | \Sigma \rightarrow \mu\), existe \(M'\) y \(\mu'\) tal que \(M\ |\ \mu \rightarrow M'\ |\ \mu'\) (o sea que puedo haber cambiado el store)</li>
</ul>
<h3 id="ejemplos"><a class="header" href="#ejemplos">Ejemplos</a></h3>
<p><img src="./img/eval_example_with_references.png#center" alt="" /></p>
<p><img src="./img/eval_example_with_references_2.png#center" alt="" /></p>
<p><img src="./img/eval_example_with_references_3.png#center" alt="" /></p>
<div id="admonition-opa-opa-opa" class="admonition admonish-warning">
<div class="admonition-title">
<p>Opa Opa Opa...</p>
<p><a class="admonition-anchor-link" href="lambda_calc_extendido.html#admonition-opa-opa-opa"></a></p>
</div>
<div>
<p>En ese 煤ltimo ejemplo me quedo en un loop infinito de evaluaciones. En
\(\lambda^{bnr}\) (lambda c谩lculo con booleanos, naturales y referencias) no
todo t茅rmino cerrado y bien tipado termina.</p>
</div>
</div>
<h2 id="recursi贸n"><a class="header" href="#recursi贸n">Recursi贸n</a></h2>
<p>Algo com煤n en funcional es tener definiciones de funciones recursivas.
Intentemos extender el \(\lambda\)-c谩lculo para soportarlo. Para eso tenemos
que introducir un nuevo t茅rmino:</p>
<p>$$
M ::= \dots\ |\ fix\ M
$$</p>
<p>Y si bien no se precisan nuevos tipos, si se necesita una regla de tipado nueva:</p>
<p>$$
\frac{\hastype{\Gamma}{M}{\sigma_1 \rightarrow \sigma_1}}{\hastype{\Gamma}{fix\ M}{\sigma_1}} (T-Fix)
$$</p>
<blockquote>
<p>Obs: s贸lo le puedo pasar funciones cuyo dominio y codominio coincidan, y \(fix M\) tiene el mismo tipo que el codominio.</p>
</blockquote>
<h3 id="sem谩ntica-operacional"><a class="header" href="#sem谩ntica-operacional">Sem谩ntica operacional</a></h3>
<p>No hay valores nuevos pero se suman 2 reglas de evaluaci贸n.</p>
<blockquote>
<p>Nota: si bien es posible, ac谩 dejamos de considerar la parte de c谩lculo
lambda con efectos y referencias</p>
</blockquote>
<p>Primero reduzco todo lo que pueda lo de adentro del fix</p>
<p>$$
\frac{M_1 \rightarrow M_1'}{fix\ M_1 \rightarrow fix\ M_1'} (E-Fix)
$$</p>
<p>Luego hago el reemplazo como cuando hac铆a la evaluaci贸n de una lambda. Pero ojo, <strong>lo reemplazo por el fix entero</strong>.</p>
<p>$$
\frac{}{fix\ \lf{x}{\sigma}{M} \rightarrow M \{x \leftarrow fix\ \lf{x}{\sigma}{M}\}} (E-FixBeta)
$$</p>
<h3 id="mecanismo-de-escape"><a class="header" href="#mecanismo-de-escape">Mecanismo de escape</a></h3>
<p>Dada la sem谩ntica operacional de \(fix\), se va a evaluar tanto como sea
necesario. Pero a priori puede seguir de forma infinita. Entonces necesitamos
alguna herramienta que nos de control respecto a cu谩ndo cortar. Una posibilidad
es usar un if-else-then. Veamos un ejemplo de eso:</p>
<p>Sea M el t茅rmino:</p>
<pre><code>\f: Nat -&gt; Nat. 
    \x: Nat. if iszero(x) then 1 else x * f(pred(x))
</code></pre>
<p>en</p>
<pre><code>let fact = fix M in fact 3
</code></pre>
<p>Veamos c贸mo se reduce:</p>
<pre><code>let fact = fix M in fact 3
let fact = \x: Nat. if iszero(x) then 1 else x * (fix M)(pred(x)) in fact 3
\x: Nat. if iszero(x) then 1 else x * (fix M)(pred(x)) 3
if iszero(3) then 1 else 3 * (fix M)(pred(3))
3 * (\x: Nat. if iszero(x) then 1 else x * (fix M)(pred(x)))(pred(3))
3 * (\x: Nat. if iszero(x) then 1 else x * (fix M)(pred(x)))(2)
3 * (if iszero(2) then 1 else 2 * (fix M)(pred(2))))
3 * (2 * (fix M)(pred(2)))
3 * (2 * (\x: Nat. if iszero(x) then 1 else x * (fix M)(pred(x)))(pred(2)))
3 * (2 * (\x: Nat. if iszero(x) then 1 else x * (fix M)(pred(x)))(1))
3 * (2 * iszero(1) then 1 else 1 * (fix M)(pred(1)))
3 * (2 * 1 * (fix M)(pred(1)))
3 * (2 * 1 * (fix M)(0))
3 * (2 * 1 * (\x: Nat. if iszero(x) then 1 else x * (fix M)(pred(x)))(0))
3 * (2 * 1 * if iszero(0) then 1 else 0 * (fix M)(pred(0)))
3 * (2 * 1 * 1)
...
6
</code></pre>
<p>Obs: el t茅rmino M tiene tipo <code>(Nat-&gt;Nat) -&gt; (Nat-&gt;Nat)</code>, con lo cual el fix va
a ser de tipo <code>Nat-&gt;Nat</code>. De alguna forma podemos pensar que la f sirve para
llamar a la recursi贸n de la funci贸n y la x es el par谩metro del llamado actual.</p>
<h3 id="m谩s-ejemplos"><a class="header" href="#m谩s-ejemplos">M谩s ejemplos</a></h3>
<ul>
<li>Podemos definir funciones parciales:</li>
</ul>
<pre><code>fix (\x: Nat.succ x) 
-&gt; succ (fix (\x: Nat.succ x)) 
-&gt; succ (succ (fix (\x: Nat.succ x)))
-&gt; ...
</code></pre>
<h2 id="letrec"><a class="header" href="#letrec">letrec</a></h2>
<p>A modo de sintactic sugar definimos:</p>
<pre><code>letrec f: t -&gt; t = \x : t.M in N
</code></pre>
<p>El letrec se puede re-escribir usando let con:</p>
<pre><code>let f = fix (\f : t -&gt; t. \x: t.M) in N
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>$$
\newcommand{\lft}[2]{\lambda{#1}.{#2}}
\newcommand{\lf}[3]{\lambda{#1}:\ {#2}.{#3}}
\newcommand{\ifLC}[3]{if\  {#1}\  then\  {#2}\  else\  {#3}}
\newcommand{\apply}[2]{{#1}\ {#2}}
\newcommand{\hastype}[3]{{#1} \triangleright {#2}: {#3}}
\newcommand{\inference}[1]{\mathbb{W}(#1)}
$$</p>
<h1 id="inferencia-de-tipos"><a class="header" href="#inferencia-de-tipos">Inferencia de tipos</a></h1>
<p>Queremos resolver el problema de recibir t茅rminos sin informaci贸n de tipos o
con informaci贸n de tipos parcial en t茅rminos tipables. Para eso es necesario
<strong>inferir</strong> la informaci贸n de tipos que falta.</p>
<p>En lenguajes tipados esto permite obviar algunas declaraciones de tipos (e.g
Haskell, Rust, etc.), esto puede resultar en c贸digo m谩s simple de entender
(menos complejidad), y no afecta el tiempo de ejecuci贸n porque esto se puede
hacer en tiempo de compilaci贸n.</p>
<h2 id="punto-de-partida"><a class="header" href="#punto-de-partida">Punto de partida</a></h2>
<p>Primero vamos a modificar la sintaxis de los t茅rminos del \(\lambda\)-c谩lculo
eliminando toda anotaci贸n de tipos (el 煤nico lugar donde ten铆amos era en la
lambda). O sea la funci贸n lambda pasa a ser: \(\lft{x}{M}\). A ese conjunto
de t茅rminos lo denotamos \(\Lambda\).</p>
<p>Para formalizar esto, vamos a usar la funci贸n \(Erase(.):\ \Lambda_{\tau} \rightarrow \Lambda\) que elimina las anotiaciones de tipos. Por ejemplo:</p>
<p>$$
Erase(\lf{x}{Nat}{\lf{f}{Nat\ \rightarrow Nat}{\apply{f}{x}}}) = \lft{x}{\lft{f}{\apply{f}{x}}}
$$</p>
<h2 id="definici贸n-formal-del-problema-de-la-inferencia"><a class="header" href="#definici贸n-formal-del-problema-de-la-inferencia">Definici贸n formal del problema de la inferencia</a></h2>
<p>Dado \(U\) un t茅rmino sin anotaciones de tipo, encontrar un t茅rmino con anotaciones de tipos \(M\) tal que:</p>
<ol>
<li>\(\hastype{\Gamma}{M}{\sigma}\) para alg煤n \(\Gamma\) y \(\sigma\), y</li>
<li>\(Erase(M) = U\)</li>
</ol>
<h3 id="ejemplos-1"><a class="header" href="#ejemplos-1">Ejemplos</a></h3>
<ul>
<li>\(U = \lft{x}{succ(x)}\), \(\lf{x}{Nat}{succ(x)}\) (en este caso no hay otra posibilidad)</li>
<li>\(U = \lft{x}{\lft{f}{\apply{f}{x}}}\) tomamos \(M_{\sigma,\tau} = \lf{x}{\sigma}{\lf{f}{\sigma \rightarrow \tau}{\apply{f}{x}}}\) (notar que en este caso hay un \(M_{\sigma,\tau}\) por cada par \(\sigma,\tau\))</li>
<li>Si \(U = \apply{x}{x}\), en principio no tenemos un t茅rmino \(M\) que satisfaga la propiedad.</li>
</ul>
<div id="admonition-chequeo--inferencia" class="admonition admonish-warning">
<div class="admonition-title">
<p>Chequeo != Inferencia</p>
<p><a class="admonition-anchor-link" href="inferencia_de_tipos.html#admonition-chequeo--inferencia"></a></p>
</div>
<div>
<p>Es importante poder diferenciar un problema de otro. El problema del chequeo de
tipos es que dado un t茅rmino \(M\) tengo que determinar si existe un contexto
\(\Gamma\) y un tipo \(\sigma\) tales que \(\hastype{\Gamma}{M}{\sigma}\)
es derivable.</p>
<ul>
<li>esto es muuuuuucho m谩s f谩cil que el problema de inferencia, ya que est谩 todo guiado por sint谩xis</li>
<li>de hecho, la forma para chequear eso es seguir la estructura sint谩ctica para construir una derivaci贸n del juicio de tipado.</li>
<li>es escencialmente lo mismo a que ya te den el \(\Gamma\) y el \(\sigma\) y veas si \(\hastype{\Gamma}{M}{\sigma}\) es derivable.</li>
</ul>
</div>
</div>
<h2 id="variables-de-tipo"><a class="header" href="#variables-de-tipo">Variables de tipo</a></h2>
<p>Supongamos que tenemos \(U = \lft{x}{\lft{f}{\apply{f}{x}}}\). Entonces dijimos que para cada \(\sigma\) tengo definido un \(M_{\sigma} = \lf{x}{\sigma}{\lf{f}{\sigma \rightarrow \sigma}{\apply{f}{x}}}\). Y cada uno de esos es una soluci贸n posible al problema de la inferencia.</p>
<p>Entonces, estar铆a bueno tener una forma de agrupar todas esas soluciones en una sola. Para eso, podr铆amos representar a todas las soluciones con \(\lf{x}{s}{\lf{f}{s \rightarrow s}{\apply{f}{x}}}\</p>
<ul>
<li>\(s\) no es un tipo en si mismo si no que es una variable de tipos.</li>
<li>la expresi贸n no es una soluci贸n en si misma, pero la substituci贸n de \(s\)
por cualquier expresi贸in de tipos si nos da una soluci贸n.</li>
</ul>
<h2 id="extensi贸n-de-las-expresiones-de-tipo"><a class="header" href="#extensi贸n-de-las-expresiones-de-tipo">Extensi贸n de las expresiones de tipo</a></h2>
<p>$$
\sigma ::= s\ |\ Nat\ |\ Bool\ |\ \sigma \rightarrow \tau
$$</p>
<ul>
<li>Denotamos con \(\mathcal{V}\) al conjunto de variables de tipo.</li>
<li>Denotamos con \(\mathcal{T}\) al conjunto de tipos definidos como arriba.</li>
</ul>
<h2 id="sustituci贸n-de-tipos"><a class="header" href="#sustituci贸n-de-tipos">Sustituci贸n de tipos</a></h2>
<p>Vamos a definir una funci贸n de sustituci贸n que mapea variables de tipo en
expresiones de tipo \(\mathcal{S}: \mathcal{V} \rightarrow \mathcal{T}\).
S贸lo nos interesan las \(\mathcal{S}\) tales que \(\{t \in \mathcal{V}\ |\ St \neq t\}\)
es finito (Es un detalle t茅cnico, lo importante es que no queremos que reemplace infinitas variables)</p>
<p>Adem谩s, vamos a querer poder aplicar \(S\) a varias cosas:</p>
<ul>
<li>expresiones de tipos (dado \(\sigma\), escribimos \(S\sigma\))</li>
<li>un t茅rmino cualquiera (dado \(M\) escribimos \(SM\))</li>
<li>un contexto de tipado (dado \(\Gamma = \{x_1: \sigma_1, \dots, x_n: \sigma_n\}\) escribimos \(S\Gamma\) definido como:)</li>
</ul>
<p>$$
S\Gamma = \{x_1: S\sigma_1, \dots, x_n: S\sigma_n\}
$$</p>
<p>Algunas consideraciones extra:</p>
<ul>
<li>Llamamos <strong>soporte de</strong> \(S\) a \(\{t\ |\ St \neq t\}\)</li>
<li>El soporte representa las variables que \(S\) "afecta".</li>
<li>Usamos la notaci贸n \(\{\sigma_1/t_1, \dots, \sigma_n/t_n\}\) para la sustituci贸n con soporte \(\{t_1, \dots, t_n\}\)
<ul>
<li>los \(\sigma_i\) es la cosa por la que reemplazo a los Ts</li>
</ul>
</li>
<li>La sustituci贸n con soporte \(\emptyset\) es la sustituci贸n identidad y la notamos \(Id\)</li>
</ul>
<h2 id="juicio-de-tipado-instanciado"><a class="header" href="#juicio-de-tipado-instanciado">Juicio de tipado instanciado</a></h2>
<p>Dado un juicio de tipado original \(\hastype{\Gamma}{M}{\sigma}\), hablamos del juicio de tipado instanciado \(\hastype{\Gamma'}{M'}{\sigma'}\) al resultante de aplicarle una sustituci贸n \(S\) al juicio original (en caso de existir tal \(S\). Esto es equivalente a que existe \(S\) tal que:</p>
<p>$$
S\Gamma \subseteq \Gamma', M' = SM, \sigma' = S\sigma
$$</p>
<blockquote>
<p><strong>Propiedad</strong>: si \(\hastype{\Gamma}{M}{\sigma}\) es derivable, entonces cualquier instancia del mismo juicio de tipado lo es.</p>
</blockquote>
<h2 id="funci贸n-de-inferencia-inference"><a class="header" href="#funci贸n-de-inferencia-inference">Funci贸n de inferencia \(\inference{.}\)</a></h2>
<p>Es una funci贸n que dado un t茅rmino \(U\) sin anotaciones verifica:</p>
<ul>
<li>Correcci贸n: \(\inference{U} = \hastype{\Gamma}{M}{\sigma}\) implica
<ul>
<li>\(Erase(M) = U\)</li>
<li>\(\hastype{\Gamma}{M}{\sigma}\) es derivable</li>
</ul>
</li>
<li>Completitud: Si \(\hastype{\Gamma}{M}{\sigma}\) es derivable y \(Erase(M) = U\), entonces
<ul>
<li>\(\inference{U}\) tiene 茅xito (si existe lo tiene que encontrar)</li>
<li>produce un juicio \(\hastype{\Gamma'}{M'}{\sigma'}\) tal que \(\hastype{\Gamma}{M}{\sigma}\) es instancia del mismo (se dice que \(\inference{.}\)) <strong>computa un tipo principal</strong>. (capaz no encuentra exactamente el mismo t茅rmino o al menos va a encontrar algo del que mi juicio original sea instancia. O sea que el algoritmo te va a dar la versi贸n m谩s general)</li>
</ul>
</li>
</ul>
<h3 id="algoritmo-de-inferencia-casos-bases"><a class="header" href="#algoritmo-de-inferencia-casos-bases">Algoritmo de inferencia (casos bases)</a></h3>
<p>$$
\begin{align}
\inference{0} &amp;\stackrel{def}{=} \hastype{\emptyset}{0}{Nat} \\
\inference{true} &amp;\stackrel{def}{=} \hastype{\emptyset}{true}{Bool} \\
\inference{false} &amp;\stackrel{def}{=} \hastype{\emptyset}{false}{Bool} \\
\inference{x} &amp;\stackrel{def}{=} \hastype{\{x: s\}}{x}{s}, x \text{ variable fresca}
\end{align}
$$</p>
<h3 id="algoritmo-de-inferencia-caso-succ"><a class="header" href="#algoritmo-de-inferencia-caso-succ">Algoritmo de inferencia (caso succ)</a></h3>
<p>$$
\inference{succ(U)} \stackrel{def}{=} ?
$$</p>
<ul>
<li>Sea \(\inference{U} = \hastype{\Gamma}{M}{\tau}\) ("aplico hip贸tesis inductiva")</li>
<li>Tenemos que saber si \(\tau\) puede ser un \(Nat\)</li>
</ul>
<div id="admonition-unificaci贸n" class="admonition admonish-info">
<div class="admonition-title">
<p>Unificaci贸n</p>
<p><a class="admonition-anchor-link" href="inferencia_de_tipos.html#admonition-unificaci贸n"></a></p>
</div>
<div>
<p>Al igual que arriba, me puedo encontrar casos en donde tengo que saber si una
expresi贸n de tipos es compatible o unificable con otra. Dicho proceso implica
determinar si existe una sustituci贸n \(S\) tal que las expresiones de tipos
(ponele que son \(\sigma\) y \(\tau\)) son unificables (o sea \(S\sigma =
S\tau\))</p>
<p>Por ejemplo, el tipo \(s \rightarrow t\) es unificable con \(Nat \rightarrow u\)?</p>
<ul>
<li>puedo armar una sustituci贸n que tome \(s\) y lo transforme en \(Nat\), y agarre \(t\) y lo transforme en \(u\)</li>
<li>en este caso la estructura lo facilita tambi茅n, pero se puede replicar para otras expresiones</li>
</ul>
</div>
</div>
<h2 id="propiedades-de-sustituciones"><a class="header" href="#propiedades-de-sustituciones">Propiedades de sustituciones</a></h2>
<ul>
<li>La composici贸n de sustituciones es equivalente a la composici贸n de funciones. Ejemplo:</li>
</ul>
<p><img src="./img/sust_composicion.png#center" alt="" /></p>
<ul>
<li>Decimos que \(S = T\) si tienen el mismo soporte y \(St = Tt\) para todo \(t\) del soporte.</li>
<li>la identidad no afecta en la composici贸n</li>
<li>la composici贸n es asociativa</li>
<li>decimos que una sustituci贸n \(S\) es <strong>m谩s general</strong> que \(T\) si existe \(U\) tal que \(T = U \circ S\)
<ul>
<li>\(S\) es m谩s general que \(T\) porque \(T\) se obtiene instanciando \(S\)</li>
<li>Ej: una sustituci贸n que reemplaza \(s\) por \(t \rightarrow t\) es m谩s general que otra que la reemplaza por \(Nat \rightarrow Nat\)</li>
</ul>
</li>
</ul>
<h2 id="unificador"><a class="header" href="#unificador">Unificador</a></h2>
<p>Una <strong>expresi贸n de unificaci贸n</strong> es algo de la forma <code>expr1 = expr2</code>. Una sustituci贸n es una soluci贸n de un conjunto de ecuaciones de unificaci贸n \(\{\sigma_1 = \sigma_1', \dots, \sigma_n = \sigma_n'\}\) si \(S\sigma_1 = S\sigma_1', \dots, S\sigma_n = S\sigma_n'\)</p>
<p>Veamos unos ejemplos:</p>
<ul>
<li>La sustituci贸n \(\{Bool/v, Bool \times Nat/u\}\) es soluci贸n de \{v \times Nat \rightarrow Nat = u \rightarrow Nat\}
<ul>
<li>\(\{Bool \times Bool/v, (Bool \times Bool) \times Nat/u\}\) tambi茅n es soluci贸n, pero es un poco m谩s compleja.</li>
<li>\(\{v \times Nat/u\}\) tambi茅n... y de hecho es m谩s simple... m谩s <strong>GENERAL</strong>.</li>
</ul>
</li>
<li>\(\{Nat \rightarrow s = t \times u\}\) no tiene soluci贸n porque no puedo matchear la funci贸n con un producto interno.</li>
<li>\(\{u \rightarrow Nat = u\}\) no tiene soluci贸n porque cualquier cosa por la que reemplace a \(u\) me queda distinto.</li>
</ul>
<h3 id="unificador-m谩s-general-mgu"><a class="header" href="#unificador-m谩s-general-mgu">Unificador m谩s general (MGU)</a></h3>
<p>Retomemos eso de la soluci贸n simple y <strong>m谩s general</strong>. Una sustituci贸n \(S\) es un MGU de \(\{\sigma_1 = \sigma_1', \dots, \sigma_n = \sigma_n'\}\) si:</p>
<ol>
<li>es soluci贸n del conjunto de ecuaciones</li>
<li>es m谩s general que cualquier otra soluci贸n</li>
</ol>
<p>En el ejemplo anterior \(\{v \times Nat/u\}\) era la MGU.</p>
<h3 id="algoritmo-de-unificaci贸n"><a class="header" href="#algoritmo-de-unificaci贸n">Algoritmo de unificaci贸n</a></h3>
<p>Sabiendo que vale el siguiente teorema:</p>
<blockquote>
<p>Si \(\{\sigma_1 = \sigma_1', \dots, \sigma_n = \sigma_n'\}\) tiene soluci贸n, entonces existe MGU y es 煤nico salvo por renombre de variables</p>
</blockquote>
<p>Vamos a armar un algoritmo que cumple:</p>
<ul>
<li>entrada:
<ul>
<li>conjunto de ecuaciones de unificaci贸n</li>
</ul>
</li>
<li>salida:
<ul>
<li>MGU del conjunto, si tiene soluci贸n</li>
<li>falla en caso contrario</li>
</ul>
</li>
</ul>
<h3 id="algoritmo-de-martelli-montanari"><a class="header" href="#algoritmo-de-martelli-montanari">Algoritmo de Martelli-Montanari</a></h3>
<ul>
<li>es no determin铆stico (defino reglas para aplicar pero no hay un orden espec铆fico establecido)</li>
<li>consiste en reglas de simplificaci贸n, que simplifican conjuntos de pares de tipos a unificar (goals)</li>
</ul>
<p>$$
G_0 \rightarrow G_1 \rightarrow \dots \rightarrow G_n
$$</p>
<ul>
<li>las secuencias que terminan con el goal vac铆o son las existosas. El resto
fallan</li>
<li>algunos pasos usan una substituci贸n que representa una soluci贸n parcial, pero
si la secuencia es exitosa basta con componer todas las substituciones y
obtenemos el MGU.</li>
</ul>
<h4 id="reglas-del-algoritmo"><a class="header" href="#reglas-del-algoritmo">Reglas del algoritmo</a></h4>
<ol>
<li>Descomposici贸n
<ul>
<li>\(\{\sigma_1 \rightarrow \sigma_2 = \tau_1 \rightarrow \tau_2\} \cup G \rightarrow \{\sigma_1 = \tau_1, \sigma_2 = \tau2\} \cup G\) (igualdad de funciones se descompone en igualdad de cada tipo de la funci贸n)</li>
<li>\(\{Nat = Nat\} \cup G \rightarrow G\)</li>
<li>\(\{Bool = Bool\} \cup G \rightarrow G\)</li>
</ul>
</li>
<li>Eliminaci贸n de par trivial
<ul>
<li>\(\{s = s\} \cup G \rightarrow G\)</li>
</ul>
</li>
<li>Swap: si \(\sigma\) no es una variable
<ul>
<li>\(\{\sigma = s\} \cup G \rightarrow \{s = \sigma\} \cup G\) (es un paso intermedio para usar la regla 4)</li>
</ul>
</li>
<li>Eliminaci贸n de variable: si \(s \notin FV(\sigma)\)
<ul>
<li>\(\{s = \sigma\} \cup G \rightarrow_{\{\sigma/s\}} \{\sigma/s\}G \) (el objetivo de la regla es eliminar la restricci贸n)</li>
</ul>
</li>
<li>Colisi贸n
<ul>
<li>\(\{\sigma = \tau\} \cup G \rightarrow falla\), con \((\sigma, \tau) \in T \cup T^{-1}\) (las permutaciones de matchear Bool, Nat o funci贸n) y \(T = \{(Bool, Nat), (Nat, \sigma_1 \rightarrow \sigma_2), (Bool, \sigma_1 \rightarrow \sigma_2)\}\)</li>
</ul>
</li>
<li>Occur check: si \(s \neq \sigma\) y \(s \in FV(\sigma)\)
<ul>
<li>\(\{s = \sigma\} \cup G \rightarrow falla\) (es como el ejemplo de \(s = s \rightarrow Nat\) que hab铆amos visto antes)</li>
</ul>
</li>
</ol>
<div id="admonition-ejemplo" class="admonition admonish-example">
<div class="admonition-title">
<p>Ejemplo</p>
<p><a class="admonition-anchor-link" href="inferencia_de_tipos.html#admonition-ejemplo"></a></p>
</div>
<div>
<p><img src="./img/ejemplo_montanari.png#center" alt="" /></p>
<p>Notar que aplicamos 3 sustituciones. Armemos el MGU que es:</p>
<p>$$
\{Nat \rightarrow (s \rightarrow s)/u\} \circ \{s \rightarrow s/r\} \circ \{Nat \rightarrow r/t\} = \\
\{Nat \rightarrow (s \rightarrow s)/t, s \rightarrow s/r, Nat \rightarrow (s \rightarrow s)/u\}
$$</p>
</div>
</div>
<h4 id="propiedades-del-algoritmo-teorema"><a class="header" href="#propiedades-del-algoritmo-teorema">Propiedades del algoritmo (Teorema)</a></h4>
<ul>
<li>El algoritmo siempre termina</li>
<li>Sea \(G\) un conjunto de pares. Si tiene unificador, entonces el algoritmo de Martelli-Montanari termina exitosamente y devuelve un MGU. Y si no tiene  el algoritmo termina con \(falla\)</li>
</ul>
<h3 id="volviendo-a-succ"><a class="header" href="#volviendo-a-succ">Volviendo a Succ</a></h3>
<p>$$
\inference{succ(U)} \stackrel{def}{=} ?
$$</p>
<ul>
<li>Sea \(\inference{U} = \hastype{\Gamma}{M}{\tau}\) ("aplico hip贸tesis inductiva")</li>
<li>Sea \(S = MGU\{\tau = Nat\}\)</li>
</ul>
<p>Entonces:</p>
<p>$$
\inference{succ(U)} \stackrel{def}{=} \hastype{S\Gamma}{S\ succ(M)}{Nat}
$$</p>
<blockquote>
<p>Nota: \(pred\) es similar</p>
</blockquote>
<h3 id="algoritmo-de-inferencia-caso-iszero"><a class="header" href="#algoritmo-de-inferencia-caso-iszero">Algoritmo de inferencia (caso iszero)</a></h3>
<ul>
<li>Sea \(\inference{U} = \hastype{\Gamma}{M}{\tau}\)</li>
<li>Sea \(S = MGU\{\tau = Nat\}\)</li>
</ul>
<p>Entonces:</p>
<p>$$
\inference{iszero(U)} \stackrel{def}{=} \hastype{S\Gamma}{S\ iszero(M)}{Bool}
$$</p>
<h3 id="algoritmo-de-inferencia-caso-ifthenelse"><a class="header" href="#algoritmo-de-inferencia-caso-ifthenelse">Algoritmo de inferencia (caso ifThenElse)</a></h3>
<ul>
<li>Sea \(\inference{U} = \hastype{\Gamma_1}{M}{\rho}\)</li>
<li>Sea \(\inference{V} = \hastype{\Gamma_2}{P}{\sigma}\)</li>
<li>Sea \(\inference{W} = \hastype{\Gamma_3}{Q}{\tau}\)</li>
<li>Sea \(S = MGU(\{\rho = Bool, \sigma = \tau\} \cup \{\sigma_1 = \sigma_2\ |\ x: \sigma_1 \in \Gamma_i \land x: \sigma_2 \in \Gamma_j, i \neq j\})\)
<ul>
<li>el primer conjunto es simplemente forzar que la parte del if sea un booleano y que matcheen los tipos del then y del else para que todo tipe bien.</li>
<li>la segunda parte es para asegurarte que las variables que reciben un tipo en cada t茅rmino sean consistentes con el resto (notar que el ifThenElse no liga variables as铆 que no hay que tener mucho cuidado respecto a eso).</li>
</ul>
</li>
</ul>
<p>Entonces:</p>
<p>$$
\inference{\ifLC{U}{V}{W}} \stackrel{def}{=} \hastype{S\Gamma_1 \cup S\Gamma_2 \cup S\Gamma_3}{S\ (\ifLC{M}{P}{Q})}{\sigma}
$$</p>
<blockquote>
<p>Notar que se puede usar tanto \(\tau\) como \(\sigma\) porque ya tenemos la ecuaci贸n de unificaci贸n que hace que sean iguales.</p>
</blockquote>
<h3 id="algoritmo-de-inferencia-caso-aplicaci贸n"><a class="header" href="#algoritmo-de-inferencia-caso-aplicaci贸n">Algoritmo de inferencia (caso aplicaci贸n)</a></h3>
<ul>
<li>Sea \(\inference{U} = \hastype{\Gamma_1}{M}{\tau}\)</li>
<li>Sea \(\inference{V} = \hastype{\Gamma_2}{N}{\rho}\)</li>
<li>Sea \(S = MGU(\{\tau = \rho \rightarrow t\} \cup \{\sigma_1 = \sigma_2\ |\ x: \sigma_1 \in \Gamma_i \land x: \sigma_2 \in \Gamma_j, i \neq j\})\), con \(t\) una variable fresca.
<ul>
<li>el segundo conjunto es el mismo que para el ifThenElse</li>
<li>el otro es para asegurarnos que \(U\) sea una funci贸n que recibe lo que sea que devuelva \(V\).</li>
</ul>
</li>
</ul>
<p>Entonces:</p>
<p>$$
\inference{\apply{U}{V}} \stackrel{def}{=} \hastype{S\Gamma_1 \cup S\Gamma_2}{S(\apply{M}{N})}{St}
$$</p>
<h3 id="algoritmo-de-inferencia-caso-abstracci贸n--lambda"><a class="header" href="#algoritmo-de-inferencia-caso-abstracci贸n--lambda">Algoritmo de inferencia (caso abstracci贸n / lambda)</a></h3>
<ul>
<li>Sea \(\inference{U} = \hastype{\Gamma}{M}{\rho}\)</li>
<li>Si el contexto tiene informaci贸n de tipos para \(x\) (o sea \(x: \tau \in \Gamma\), o lo que es lo mismo, \(x\) no puede tomar cualquier valor), entonces:</li>
</ul>
<p>$$
\inference{\lft{x}{U}} \stackrel{def}{=}  \hastype{\Gamma \setminus \{x: \tau\}}{\lf{x}{\tau}{M}}{\tau \rightarrow \rho}
$$</p>
<ul>
<li>Si no (o sea \(x \notin Dom(\Gamma)\)), elegimos una variable fresca \(s\) y entonces:</li>
</ul>
<p>$$
\inference{\lft{x}{U}} \stackrel{def}{=}  \hastype{\Gamma}{\lf{x}{s}{M}}{s \rightarrow \rho}
$$</p>
<blockquote>
<p>Notar que en este caso s贸lo le saco cosas al contexto, justamente porque el
t茅rmino \(U\) es como dejar "libre" a \(x\), pero en realidad el valor de
\(x\) va a estar restringido por el tipo que le ligue la funci贸n lambda, no
el contexto.</p>
</blockquote>
<h3 id="algoritmo-de-inferencia-caso-fix"><a class="header" href="#algoritmo-de-inferencia-caso-fix">Algoritmo de inferencia (caso \(fix\))</a></h3>
<ul>
<li>Sea \(\inference{U} \stackrel{def}{=} \hastype{\Gamma}{M}{\rho}\)</li>
<li>Recuerdo la regla de tipado de fix:</li>
</ul>
<p>$$
\frac{\hastype{\Gamma}{M}{\sigma_1 \rightarrow \sigma_1}}{\hastype{\Gamma}{fix\ M}{\sigma_1}} (T-Fix)
$$</p>
<ul>
<li>Sea \(S = MGU \{\rho = s \rightarrow s\}\) con \(s\) una variable fresca</li>
</ul>
<p>Entonces:</p>
<p>$$
\inference{fix(U)} \stackrel{def}{=} \hastype{S\Gamma}{S\ fix(M)}{s}
$$</p>
<div style="break-before: page; page-break-before: always;"></div><p>$$
\newcommand{\ifLC}[3]{if\  {#1}\  then\  {#2}\  else\  {#3}}
\newcommand{\lf}[3]{\lambda{#1}:\ {#2}.{#3}}
\newcommand{\apply}[2]{{#1}\ {#2}}
\newcommand{\hastype}[3]{{#1} \triangleright {#2}: {#3}}
\newcommand{\tapp}[5]{\frac{\hastype{#1}{#2}{#3 \rightarrow #4}\ \ \hastype{#1}{#5}{#3}}{\hastype{#1}{\apply{{#2}}{{#5}}}{#4}} (T-app)}
$$</p>
<h1 id="subtipado"><a class="header" href="#subtipado">Subtipado</a></h1>
<h2 id="por-qu茅"><a class="header" href="#por-qu茅">Por qu茅?</a></h2>
<p>Arrancamos con un c谩lculo lambda bastante simple, y le fuimos agregando
extensiones para hacer cosas m谩s interesantes (registros, referencias, side
effects, fix, etc.). Ahora vamos a ver una extensi贸n m谩s, que va a flexibilizar
un poco el sistema de tipos.</p>
<p>Qu茅 quiere decir esto? Bueno, que hay casos donde sabemos que el programa no va
a "romper", pero nuestro sistema de tipos rechaza ese t茅rmino. Pensar que el
objetivo del sistema de tipos en parte es rechazar t茅rminos que no tienen
sentido. Veamos un ejemplo:</p>
<p>$$
\apply{\lf{x}{\{a: Nat\}}{x.a}}{\{a = 1, b = true\}}
$$</p>
<p>A simple vista parece que funciona, pero el t茅rmino es rechazado porque el tipo
del registro tambi茅n incluye lo que pasa con \(b\). Pero a mi qu茅 me importa
que tenga \(b\) en el contexto de la lambda?</p>
<h2 id="principio-de-sustitutividad"><a class="header" href="#principio-de-sustitutividad">Principio de sustitutividad</a></h2>
<p>Definimos la siguiente expresi贸n:</p>
<p>$$
\sigma &lt;: \tau
$$</p>
<p>Que quiere decir que en todo contexto donde se espera una expresi贸n de tipo
\tau, puedo pasarle una de tipo \sigma y tambi茅n funciona. Es mucho muy
importante entender esto y ante la duda hacer con un ejemplo (o tomar el caso
puntual) y preguntarte, con qu茅 tipo anda y con qu茅 tipo quiero que tambi茅n
funcione.</p>
<p>Esto mismo se expresa con la regla de tipado de Subsumption (Subsumisi贸n):</p>
<p>$$
\frac{\hastype{\Gamma}{M}{\sigma}\ \ \ \sigma &lt;: \tau}{\hastype{\Gamma}{M}{\tau}} (T-Subs)
$$</p>
<div id="admonition-subtipado-de-tipos-b谩sicos" class="admonition admonish-info">
<div class="admonition-title">
<p>Subtipado de tipos b谩sicos</p>
<p><a class="admonition-anchor-link" href="subtipado.html#admonition-subtipado-de-tipos-b谩sicos"></a></p>
</div>
<div>
<ul>
<li>\(Nat &lt;: Float\)
<ul>
<li>"Siempre que tenga un t茅rmino que acepta float puedo usar un nat y no deber铆a romper"</li>
</ul>
</li>
<li>\(Int &lt;: Float\)
<ul>
<li>"Siempre que tenga un t茅rmino que acepta float puedo usar un int y no deber铆a romper"</li>
</ul>
</li>
<li>\(Bool &lt;: Nat\)
<ul>
<li>"Siempre que tenga un t茅rmino que acepta Nat puedo usar un bool y no deber铆a romper"</li>
</ul>
</li>
</ul>
</div>
</div>
<p>Algo interesante que agrega este operador es que induce un pre-orden, o sea que es reflexiva y transitiva:</p>
<div style="width:330px;">
<p>$$
\frac{}{\sigma &lt;: \sigma} (T-Refl) \\
\frac{\sigma &lt;: \tau\ \ \ \tau &lt;: \rho}{\sigma &lt;: \rho} (T-Trans)
$$</p>
</div>
<div style="float:right;margin-left:2rem;margin-bottom:3rem;margin-top:-10rem;width:330px">
<blockquote>
<p>Nota: No es ni antisim茅trica ni sim茅trica</p>
</blockquote>
<div id="admonition-querr铆amos-tener-un-orden-total" class="admonition admonish-question">
<div class="admonition-title">
<p>Querr铆amos tener un orden total?</p>
<p><a class="admonition-anchor-link" href="subtipado.html#admonition-querr铆amos-tener-un-orden-total"></a></p>
</div>
<div>
<p>A priori suena medio raro, porque hay cosas que ni tienen sentido comparar. No
tiene mucho sentido comparar por ejemplo un entero con una funci贸n, o un
booleano con una funci贸n. Pero capaz si tiene sentido comparar las funciones
seg煤n su tipo de entrada y salida.</p>
</div>
</div>
</div>
<h2 id="revisitando-las-reglas-de-tipado-para-lambdac谩lculo-con-registros"><a class="header" href="#revisitando-las-reglas-de-tipado-para-lambdac谩lculo-con-registros">Revisitando las reglas de tipado para lambdac谩lculo con registros</a></h2>
<p>A priori las reglas m谩s b谩sicas \(T-Var\), \(T-Var\), \(T-Abs\) y
\(T-App\) no requieren cambios.</p>
<p>Por otro lado ten铆amos las <a href="./lambda_calc_extendido.html#reglas-de-tipado">reglas de tipado</a> para registros \(T-Rcd\) y \(T-Proj\) para los registros y su proyecci贸n:</p>
</br>
</br>
<p>$$
\frac{\Gamma \triangleright M_i : \sigma_i\ \text{para cada } i \in 1 \dots n}{\Gamma \triangleright \{l_i = M_i^{i \in 1 \dots n} \} : \{l_i : \sigma_i^{i \in 1 \dots n}\}} (T-RCD) \\
\frac{\Gamma \triangleright M_i : \{l_i : \sigma_i^{i \in 1 \dots n}\}\ j \in 1 \dots n}{\Gamma \triangleright M.I_j : \sigma_j} (T-Proj)
$$</p>
<p>Ahora, lo siguiente que vamos a hacer es introducir la regla \(T-Trans\), y
la vamos a usar para agregar nuevas reglas.</p>
<h3 id="subtipados-de-registros-a-lo-ancho"><a class="header" href="#subtipados-de-registros-a-lo-ancho">Subtipados de registros a lo "ancho"</a></h3>
<p>Idea de la regla: si yo tengo algo que tipa para un registro, agregarle m谩s
cosas a dicho registro no deber铆a de cambiar nada. Por ejemplo: <code>{nombre: String, edad: Int} &lt;: {nombre: String}</code>.</p>
<p>Generalizando, nos quedar铆a:</p>
<p>$$
\frac{}{\{l_i: \sigma_i\ |\ i \in 1\dots n + k\} &lt;: \{l_i: \sigma_i\ |\ i \in 1\dots n\}} (S-RcdWidth)
$$</p>
<ul>
<li>Nota: \(\sigma &lt;: \{\}\) para todo registro \(\sigma\).</li>
<li>Hay alg煤n tipo registro \(t\) tal que \(\tau &lt;: \sigma\) para todo tipo registro \(\sigma\).
<ul>
<li>yo creo que no, porque basta con agarrar un registro que tenga una etiqueta que \(t\) no use y armar un registro con eso.</li>
</ul>
</li>
</ul>
<h3 id="subtipado-en-profundidad"><a class="header" href="#subtipado-en-profundidad">Subtipado "en profundidad"</a></h3>
<p>Si yo tuviese <code>{a: Nat, b: Int} ? {a: Float, b: Int}</code>. Qu茅 va en el <code>?</code>? Bueno,
si yo cuando espero un <code>Float</code> me pasan un <code>Nat</code> y anda, deber铆a de pasar lo
mismo si para una etiqueta el tipo es <code>Float</code> y me pasan algo que para esa
etiqueta el tipo es <code>Nat</code>. Generalizando eso se escribe como:</p>
<p>$$
\frac{\sigma_i &lt;: \tau_i\ i \in \{1 \dots n\}}{\{l_i: \sigma_i\ |\ i \in 1\dots n\} &lt;: \{l_i: \tau_i\ |\ i \in 1\dots n\}} (S-RcdDepth)
$$</p>
<ul>
<li>Notar que la restricci贸n la hacemos sobre todos los campos (como el subtipado
es reflexivo no nos trae muchos problemas y no perdemos flexibilidad vs
escribir la regla sobre un label puntual).</li>
<li>Ejemplo: <code>{x: {a: Nat, b: Nat}, y: {m: Nat}} &lt;: {x: {a: Nat}, y: {}}</code>. Vale pues:
<ul>
<li><code>{m: Nat} &lt;: {}</code> (value para cualquier cosa que ponga a la izquierda).</li>
<li><code>{a: Nat, b: Nat} &lt;: {a: Nat}</code> ya que es agregarle <code>b: Nat</code> a <code>{a: Nat}</code> (\(S-RcdWidth\))</li>
<li>Como para <code>x</code> e <code>y</code>, los tipos del t茅rmino de la izquierda son subtipos de los de la derecha, + \(S-RcdDepth\) obtenemos que el t茅rmino de la izquierda es subtipo del de la derecha</li>
</ul>
</li>
</ul>
<h3 id="permutaciones-de-campos"><a class="header" href="#permutaciones-de-campos">Permutaciones de campos</a></h3>
<p>M谩s que nada para simplificar el lenguaje, cuando definimos los registros
ten铆amos la restricci贸n de que el tipo te fijaba el 贸rden de las etiquetas, a
pesar de que con las etiquetas ya deber铆a de ser suficiente independientemente
del orden. O sea, me da lo mismo tener <code>{a: String, b: Int}</code> que <code>{b: Int, a: String}</code>. Generalizando:</p>
<p>$$
\frac{\{k_j: \sigma_j\ j \in 1 \dots n\} \text{ es permutaci贸n de } \{l_i: \tau_i\ i \in 1 \dots n\}}{\{k_j: \sigma_j\ j \in 1 \dots n\} &lt;: \{l_i: \tau_i\ i \in 1 \dots n\}} (S-RcdPerm)
$$</p>
<div id="admonition-nota-eliminando-etiquetas" class="admonition admonish-info">
<div class="admonition-title">
<p>Nota: Eliminando etiquetas</p>
<p><a class="admonition-anchor-link" href="subtipado.html#admonition-nota-eliminando-etiquetas"></a></p>
</div>
<div>
<p>Usando \(S-RcdWidth\) + \(S-Trans\) + \(S-RcdPerm\) puedo eliminar campos en cualquier parte del registro</p>
<ul>
<li>lo puedo lograr reordenando los campos que no quiero al fondo y despu茅s eliminandolos</li>
<li>podr铆a armar una regla nueva tambi茅n, pero ya con lo que tenemos tenemos una base</li>
</ul>
<p>$$
\frac{\{l_i: \tau_i\ i \in 1 \dots n\} \subseteq \{k_j: \sigma_j\ j \in 1 \dots m\}\ \ \ \ k_j = l_i \implies \sigma_j &lt;: \tau_i}{\{k_j: \sigma_j\ j \in 1 \dots n\} &lt;: \{l_i: \tau_i\ i \in 1 \dots n\}} (S-Rcd)
$$</p>
<p>O sea que si:</p>
<ul>
<li>tengo un subconjunto de las etiquetas (est谩 impl铆cito que tiene m谩s campos) y</li>
<li>en aquellas que coincide su tipo correspondiente es subtipo del otro</li>
</ul>
<p>Entonces un tipo registro es subtipo del otro. Para hacer las pruebas vamos a usar esta regla (m谩s que nada para ahorrarnos pasos y que quede una demo m谩s directa)</p>
</div>
</div>
<h2 id="subtipado-de-tipos-funci贸n"><a class="header" href="#subtipado-de-tipos-funci贸n">Subtipado de tipos funci贸n</a></h2>
<p>C贸mo funcionar铆a para las funciones? Si yo quiero que \(\sigma_1 \rightarrow \tau_1 &lt;: \sigma_2 \rightarrow \tau_2\), qu茅 le tengo que pedir a \(\sigma_1, \sigma_2, \tau_1, \tau_2\)?</p>
<p>Primero, hay que tener como base que lo que quiero es que a una funci贸n que acepta \(\sigma_2 \rightarrow \tau_2\) le pueda pasar algo de tipo \(\sigma_1 \rightarrow \tau_1\). Esto significar铆a:</p>
<ul>
<li>Que el dominio tiene que ser compatible, o sea que las cosas de \(\sigma_2\) que se le pasaban a la funci贸n funcionen con cosas de \(sigma_1\).
<ul>
<li>o sea \(\sigma_2 &lt;: \sigma_1\)</li>
</ul>
</li>
<li>Que el resultado de la funci贸n funcione en lugar del tipo que devolv铆a lo otra funci贸n.
<ul>
<li>o sea \(\tau_1 &lt;: \tau_2\)</li>
</ul>
</li>
</ul>
<p>Veamos dos casos:</p>
<ul>
<li>Supongamos que tenemos los tipos <code>Nat</code> e <code>Int</code>, y mi c贸digo usaba una funci贸n
de tipo <code>Int -&gt; Int</code> (por ejemplo, la funci贸n <code>sumar_2 x = x + 2</code>). Si yo le
pasara la funci贸n ra铆z cuadrada que es de tipo <code>Nat -&gt; Nat</code> y en alg煤n
momento se le pasaba un n煤mero negativo, explotaba!.</li>
<li>Mismos tipos que antes pero mi c贸digo usa una funci贸n de tipo <code>Nat -&gt; Nat</code>.
Si yo le paso una funci贸n de tipo <code>Int -&gt; Int</code> podr铆a pasar que al resultado
de llamar a la funci贸n se lo pasara a la funci贸n ra铆z cuadrada, y de vuelta
si en alguna situaci贸n mi nueva funci贸n daba como resultado un n煤mero
negativo, tambi茅n explotar铆a.</li>
</ul>
<p>La regla entonces que sacamos de esto es (en la te贸rica est谩n al rev茅s los tipos):</p>
<p>$$
\frac{\sigma' &lt;: \sigma\ \ \tau &lt;: \tau'}{\sigma \rightarrow \tau &lt;: \sigma' \rightarrow \tau'} (S-Arrow)
$$</p>
<p>Se dice que el constructor de tipos funci贸n es <strong>contravariante</strong> en su primer argumento y <strong>variante</strong> en el segundo.</p>
<h2 id="subtipado-de-referencias"><a class="header" href="#subtipado-de-referencias">Subtipado de referencias</a></h2>
<p>Es covariante? Veamos c贸mo ser铆a la regla (covariante):</p>
<p>$$
\frac{\sigma &lt;: \tau}{Ref \sigma &lt;: Ref \tau}
$$</p>
<p>Qu茅 pasa?</p>
<ul>
<li>La desreferencia tiene sentido que ande</li>
<li>Pero y si intento escribir? Ve谩mos un ejemplo:</li>
</ul>
<pre><code>let r = ref 3 (*r: Ref Int*)
in r := 2.1;
!r
</code></pre>
<ul>
<li>En el ejemplo, tengo que <code>Int &lt;: Float</code>, y sin embargo <code>Ref Int &lt;: Ref Float</code>
no vale porque a la hora de asignar estar铆a asign谩ndole un <code>Float</code> a algo a
lo que s贸lo puede recibir un <code>Int</code></li>
</ul>
<p>Por lo tanto es contravariante, no?</p>
<p>$$
\frac{\tau &lt;: \sigma}{Ref \sigma &lt;: Ref \tau}
$$</p>
<p>Qu茅 pasa con:</p>
<pre><code>let r = ref 3.2 (*r: Ref Float*)
in succ(!r)
</code></pre>
<p>Ahora tengo el otro problema: si asumo que es contravariante, como <code>Int &lt;: Float</code>, obtengo que <code>Ref Float &lt;: Ref Int</code>, lo cual significar铆a que donde
espere una referencia a un entero puedo pasarle una referencia a un float y
anda. Claramente en el ejemplo no puedo pasar una referencia a un float porque
<code>succ</code> no tipa.</p>
<h3 id="la-desilusi贸n"><a class="header" href="#la-desilusi贸n">La desilusi贸n...</a></h3>
<p>Ah, que bien esto de subtipado, no me sirve para nada!!!!!</p>
<p><img src="./img/nacagada.png#center" alt="" /></p>
<p>Pero a no desesperar. Vamos a hacer un 煤ltimo empuj贸n para hacerlo andar. Qu茅
pasa si a la regla le pedimos que los tipos sean equivalentes. Eso resolver铆a
nuestros problemas porque al leer de un tipo coerciono contra el otro, y al
escribir hago lo mismo a la inversa. Eso quedar铆a:</p>
<p>$$
\frac{\sigma &lt;: \tau\ \ \tau &lt;: \sigma}{Ref \sigma &lt;: Ref \tau}
$$</p>
<p>Notar que el orden de los refs abajo es intercambiable. O sea que si dos tipos
son equivalentes, sus referencias tambi茅n lo ser谩n. Cuando esto sucede, decimos
que el tipo (Ref en este caso) es <strong>Invariante</strong>.</p>
<h3 id="refinando-ref"><a class="header" href="#refinando-ref">Refinando \(Ref\)</a></h3>
<p>La soluci贸n anterior no me deja del todo satisfecho porque lo que trae
problemas es la co-existencia de la lectura y la escritura, ya que esas nos
restringen a ser covariante o contravariante. Y en muchos casos, puedo
煤nicamente querer leer o 煤nicamente escribir.</p>
<p>Entonces, vamos a separar las referencias dependiendo de si son de lectura o de
esritura. Vamos a definir 2 tipos de referencias nuevos:</p>
<ul>
<li>\(Source\ \sigma\) para las referencias de lectura</li>
<li>\(Sink\ \sigma\) para las referencias de escritura</li>
</ul>
<p>Las reglas de tipado para ambos t茅rminos son:</p>
<p>$$
\frac{\hastype{\Gamma|\Sigma}{M}{Source \sigma}}{\hastype{\Gamma|\Sigma}{!M}{\sigma}} \\
\frac{\hastype{\Gamma|\Sigma}{M}{Sink\ \sigma}\ \hastype{\Gamma|\Sigma}{N}{\sigma}}{\hastype{\Gamma|\Sigma}{M := N}{Unit}}
$$</p>
<p>Ahora, estoy forzando a que a un source 煤nicamente le hago la desreferencia, y
a un sink le hago una asignaci贸n. Adem谩s, por la l贸gica vista anteriormente,
nos quedar铆a que el source va a ser covariante (\(S-Source\)) y el sink contravariante (\(S-Sink\)):</p>
<p>$$
\frac{\sigma &lt;: \tau}{Source \sigma &lt;: Source \tau} \\
\frac{\sigma &lt;: \tau}{Sink \tau &lt;: Sink \sigma}
$$</p>
<p>Un 煤ltimo detalle, porque recuerdo que el ejemplo era:</p>
<pre><code>let r = ref 3
in r := 2.1;
!r
</code></pre>
<p>Ac谩 estoy tanto leyendo como escribiendo en la referencia! A priori no me
funciona mi abstracci贸n... o s铆? Bueno, hay que agregar una cosa m谩s, y es
poder "downgradear" las referencias a \(Sink\) o \(Source\) dependiendo de
lo que se necesite.</p>
<p>Para eso sumamos las reglas:</p>
<p>$$
\frac{}{Ref\ \sigma &lt;: Source\ \sigma} \\
\frac{}{Ref\ \sigma &lt;: Sink\ \sigma}
$$</p>
<p>Con eso en el ejemplo tendr铆a:</p>
<pre><code>let r = ref 3 (* el ref 3 va a ser de tipo Ref Int*)
in r := 2.1; (* esto lo tipo como sink, y uso que ref es subtipo*)
!r
</code></pre>
<h2 id="d谩ndole-un-uso"><a class="header" href="#d谩ndole-un-uso">D谩ndole un uso</a></h2>
<p><a href="subtipado.html#principio-de-sustitutividad">Al principio de todo</a> dijimos que agreg谩bamos la
regla de subsumption. Esto cambia en parte la l贸gica de nuestro algoritmo de
chequeo de tipos, porque hasta ahora todas las reglas estaban guiadas por
sint谩xis, y la regla que introducimos est谩 guiada por la "oportunidad" del tipo
(o sea seg煤n te convenga). C贸mo har铆amos con eso para implementar un algoritmo
de chequeo de tipos? Idealmente, me gustar铆a poder sacar la regla \(T-Subs\).
Entonces, para eso vamos a mirar en qu茅 casos pueden haber incompatibilidades
de tipos. Si revisamos la reglas, todas son de la pinta "instancio un tipo y le
asigno el tipo abajo y restrinjo el tipo arriba". La 煤nica regla que parecer铆a
agregar nuevos tipos es la de la aplicaci贸n \(T-App\):</p>
<p>$$
\tapp{\Gamma}{M}{\tau}{\sigma}{N}
$$</p>
<p>Entonces la idea es tomar esa regla, y cambiar lo que nos da problemas, que es
el tipo de \(N\). Vamos a pedir que el tipo de \(N\) sea subtipo de lo que
sea que acepta \(M\):</p>
<p>$$
\frac{\hastype{\Gamma}{M}{\sigma \rightarrow \tau}\ \ \hastype{\Gamma}{N}{\rho}\ \ \rho &lt;: \tau}{\hastype{\Gamma}{\apply{M}{N}}{\tau}} (T-App')
$$</p>
<p>Hay un resultado que nos dice que:</p>
<ul>
<li>Si en este nuevo sistema de tipado pude asignar un tipo v谩lido a un t茅rmino,
entonces tambi茅n lo puedo hacer con el que tiene la regla de subsumption
libre (lo cual tiene sentido, ya que el otro me permite hacer lo mismo y
meter la regla de subsumption donde se me cante.</li>
<li>Pero adem谩s, el resulado dice que en el rec铆proco, si vos probaste que tu
t茅rmino tiene tipo \(\sigma\), entonces con esta variante pod茅s probar que
tiene tipo \(\rho\), con \(\rho &lt;: \tau\) (o sea que capaz es un poquito
m谩s restrictivo, pero al menos tengo una implementaci贸n m谩s directa).</li>
</ul>
<h3 id="m谩s-problemas"><a class="header" href="#m谩s-problemas">M谩s problemas</a></h3>
<p>Si bien me saqu茅 de encima \(T-Subs\), todav铆a me quedan algunas reglas que no est谩n guiadas por sint谩xis. En particular \(S-Refl\) y \(S-Trans\) (ponele que en \(S-Func\) podr铆a llegar a zafar porque tengo funciones). Por suerte hay soluci贸n:</p>
<div id="admonition-ojo" class="admonition admonish-warning">
<div class="admonition-title">
<p>Ojo</p>
<p><a class="admonition-anchor-link" href="subtipado.html#admonition-ojo"></a></p>
</div>
<div>
<p>Que no est谩n guiadas por sint谩xis en este caso no refiere al t茅rmino si no a la
sint谩xis de los tipos. A esas reglas les da lo mismo si tengo \(Nat\) o si
tengo \(Nat -&gt; Nat\).</p>
</div>
</div>
<ul>
<li>se puede probar que \(\sigma &lt;: \sigma\) se puede derivar si tengo
reflexividad para tipos escalares (asumidos como axiomas):
<ul>
<li>\(Nat &lt;: Nat\)</li>
<li>\(Int &lt;: Int\)</li>
<li>\(Bool &lt;: Bool\)</li>
<li>\(Float &lt;: Float\)</li>
</ul>
</li>
<li>adem谩s recuerdo que tengo un par de reglas axiom谩ticas que relacionan los
tipos escalares:
<ul>
<li>\(Nat &lt;: Float\)</li>
<li>\(Int &lt;: Float\)</li>
<li>\(Bool &lt;: Float\)</li>
</ul>
</li>
<li>de forma similar se puede probar que no hace falta la regla de transitividad \(S-Trans\), ya que tenemos transitividad en las reglas de tipado (ojo, no es tan directo pero tampoco voy a ahondar mucho en esto).</li>
</ul>
<h3 id="funci贸n-subtype"><a class="header" href="#funci贸n-subtype">Funci贸n <code>subtype</code></a></h3>
<p>Obviando los casos base para tipos escalares, nos quedar铆a algo as铆:</p>
<pre><code class="language-python">subtype(S, T):
    # Manejar casos base
    if S == S1 -&gt; S2 and T = T1 -&gt; T2:
        subtype(T1, S1) and subtype(S2, T2)
    else:
        if S == {k_j: S_j, j in (1..m)} and T == {l_i: T_i, i in (1..n)}:
            subseteq({l_i, i in (1..n)}, {k_j, j in (1..m)}) and all(i in (1..n) -&gt; exists(j in (1..m) -&gt; k_j = l_i and subtype(S_j, T_i)))
        else: 
            false
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unidad-3---programaci贸n-funcional"><a class="header" href="#unidad-3---programaci贸n-funcional">Unidad 3 - Programaci贸n Funcional</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="programaci贸n-orientada-a-objetos"><a class="header" href="#programaci贸n-orientada-a-objetos">Programaci贸n orientada a objetos</a></h1>
<p>As铆 como en la programaci贸n imperativa, ten铆amos la idea de <em>estado</em> que tiene
el valor de las variables y nosotros le damos una serie de instrucciones para
modificar el estado. Despu茅s vimos el paradigma funcional y el modelo de
c贸mputo cambio. En ese nuevo paradigma defino funciones, las eval煤o en
expresiones y reducimos las expresiones a su forma normal.</p>
<p>En objetos, lo pensamos como que un programa es una simulaci贸n. Y cada entidad
(relevante, que quiero modelar) del sistema que se simula se representa en el
programa con un <strong>objeto</strong>. En este paradigma la forma de razonar es hacer que
los objetos "hablen" entre s铆.</p>
<h2 id="modelo-de-c贸mputo"><a class="header" href="#modelo-de-c贸mputo">Modelo de c贸mputo</a></h2>
<ul>
<li>Sistema formado por objetos.</li>
<li>El modelo de c贸mputo consiste en el env铆o de mensajes.</li>
<li>Un <strong>mensaje</strong> es una solicitud que se le manda a un objeto para que lleve a
caba alguna de las operaciones que sabe hacer.</li>
<li>El <strong>receptor</strong> es el objeto que recibe el mensaje y es quien se encarga de
determinar <strong>c贸mo</strong> se resulve esa solicitud/mensaje.
<ul>
<li>Los <strong>m茅todos</strong> son los que describen ese c贸mo.</li>
<li>La forma en la que se resuleve puede depender del estado interno del
objeto.
<ul>
<li>Ese estado interno se representa mediante <strong>colaboradores internos</strong>
(tambi茅n conocidos como <strong>atributos</strong> o <strong>variables de instancia</strong>)</li>
</ul>
</li>
</ul>
</li>
<li>El conjunto de mensajes a los que un objeto responde se lo llama <strong>interfaz o
protocolo</strong>.</li>
<li>la <strong>煤nica</strong> forma de interactuar con un objeto es mediante el env铆o de
mensajes
<ul>
<li>la implementaci贸n de un objeto no puede depender de los detalles de
implementaci贸n de otros objetos (confio en que tienen una interfaz que
resuelve lo que necesito y de manera correcta).</li>
</ul>
</li>
<li>el estado de un objeto es <strong>privado</strong> y s贸lo puede ser modificado por medio
de sus m茅todos.
<ul>
<li>no todos los lenguajes imponen esta restricci贸n though (ej: en c++ tengo el modifier <code>friend</code>)</li>
</ul>
</li>
</ul>
<h3 id="method-dispatch"><a class="header" href="#method-dispatch">Method Dispatch</a></h3>
<p>El m茅todo de c贸mputo se puede describir con los siguientes pasos:</p>
<ul>
<li>(reminder) la interacci贸n entre objetos es mediante env铆o de mensajes</li>
<li>al recibir un mensaje se activa el m茅todo que corresponde
<ul>
<li>para procesar el mensaje, hay un proceso de encontrar el m茅todo
correspondiente para ese mensaje. Dicho proceso se conoce como <strong>method
dispatch</strong></li>
<li>puede ser tan simple como ver si mi objeto tiene el m茅todo para el nombre
o puedo complejizarlo cuando meto herencia, entre otras features. En esos
casos el method dispatch tiene un algoritmo no tan sencillo.</li>
</ul>
</li>
<li>el method dispatch se puede hacer de forma est谩tica (c, no todo. Java h铆brido) o din谩mica (en tiempo de
ejecuci贸n)</li>
</ul>
<div id="admonition-ejemplo" class="admonition admonish-example">
<div class="admonition-title">
<p>Ejemplo</p>
<p><a class="admonition-anchor-link" href="javascript_intro.html#admonition-ejemplo"></a></p>
</div>
<div>
<p>objeto <code>unCirculo</code>. Si le quiero pedir el radio: <code>unCirculo radio</code> en smalltalk, <code>unCirculo.radio</code> en c#, etc.</p>
<ul>
<li><code>unCirculo</code> es el receptor del mensaje</li>
<li><code>radio</code> es el mensaje que se le env铆a</li>
</ul>
<p>objeto <code>unRectangulo</code></p>
<ul>
<li>interfaz: area</li>
<li>atributos: alto y ancho</li>
<li>m茅todos: area = function(){ return alto * ancho }</li>
</ul>
</div>
</div>
<h2 id="corrientes"><a class="header" href="#corrientes">Corrientes</a></h2>
<p>Hablamos de que tenemos mensajes y que tenemos m茅todos para responder dichos
mensajes. Ahora, d贸nde ponemos esos m茅todos? Si tengo un objeto <code>Estudiante</code>,
una vez cargada las notas parciales la nota final se calcula siempre igual,
entonces podr铆a reusar esa l贸gica. las 2 alternativas m谩s conocidas son
<strong>clasificaci贸n</strong> y <strong>prototipado</strong>.</p>
<h3 id="clasificaci贸n"><a class="header" href="#clasificaci贸n">Clasificaci贸n</a></h3>
<p>Usan el concepto de <strong>Clase</strong>:</p>
<ul>
<li>modelan conceptos abstractos del dominio del problema</li>
<li>son como un "molde" de los objetos: definen la forma (los colaboradores externos) y el comportamiento de
los objetos</li>
<li>todo objeto es instancia de alguna clase (los objetos son distintos pero usan
los m茅todos de la misma clase para responder a mensajes)</li>
</ul>
<h4 id="componentes-de-una-clase"><a class="header" href="#componentes-de-una-clase">Componentes de una clase</a></h4>
<ul>
<li>un nombre</li>
<li>definici贸n de las variables de instancia</li>
<li>m茅todos de instancia</li>
<li>por cada m茅todo se especifica
<ul>
<li>nombre</li>
<li>par谩metros formales</li>
<li>cuerpo</li>
</ul>
</li>
</ul>
<p>Algunos lenguajes como smalltalk permiten tener tanto m茅todos de clase como
m茅todos de instancia.</p>
<h4 id="self-o-this-seg煤n-el-lenguaje"><a class="header" href="#self-o-this-seg煤n-el-lenguaje">Self (o this seg煤n el lenguaje)</a></h4>
<p>Es una pseudo-variable que se resuelve durante la evaluaci贸n de un m茅todo. Recerencia al receptor del mensaje que activ贸 la evaluaci贸n</p>
<ul>
<li>no se puede modificar por medio de una asignaci贸n</li>
<li>se liga al receptor ni bien comienza la evaluaci贸n del m茅todo</li>
</ul>
<h4 id="jerarqu铆a-de-clases"><a class="header" href="#jerarqu铆a-de-clases">Jerarqu铆a de clases</a></h4>
<ul>
<li>Es com煤n que algunas clases aparezcan como una extensi贸n de otras clases
<ul>
<li>porque se agrega / sobreescribe el comportamiento de alg煤n m茅todo</li>
<li>porque quiero agregar nuevas variables de instancia / clase</li>
</ul>
</li>
<li>Se permite que una clase <strong>herede</strong> o <strong>extienda</strong> una clase pre-existente, que conocemos como <strong>superclase</strong></li>
<li>La herencia es una relaci贸n transitiva, lo cual da origen a la diferenciaci贸n entre <strong>ancestros</strong> y <strong>descendientes</strong></li>
</ul>
<h4 id="herencia"><a class="header" href="#herencia">Herencia</a></h4>
<p>Hay 2 tipos de herencia:</p>
<ul>
<li>Simple: una clase tiene una 煤nica clase padre (salvo <code>Object</code>)</li>
<li>M煤ltiple: una clase puede tener m谩s de una clase padre
<ul>
<li>ejemplo: un <code>ProjeforUniversitario</code> es un <code>Profesor</code> y un <code>Investigador</code></li>
</ul>
</li>
<li>La mayor铆a de los lenguajes OO usan <strong>herencia simple</strong> ya que la herencia m煤ltiple complica el proceso de method dispatch (qu茅 pasa cuando ambas clases implementan un m茅todo)
<ul>
<li>hay soluciones (pero siguen agregando complejidad medio al dope):
<ul>
<li>uso el 贸rden de b煤squeda</li>
<li>fuerzo a que en esos casos se tenga que redefinir el m茅todo de la nueva clase.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="method-dispatch-est谩tico"><a class="header" href="#method-dispatch-est谩tico">Method Dispatch Est谩tico</a></h2>
<p>Lo que le da power al lenguaje orientado a objetos es la posibilidad de tener
method dispatch din谩mico. Sin embargo, hay lenguajes que cuentan com method
dispatch est谩tico. Esto se puede dar por una cuesti贸n de eficiencia o porque se
requiera m谩s all谩 de la eficiencia, como lo es con <code>super</code>.</p>
<div id="admonition-method-dispatch-est谩tico" class="admonition admonish-example">
<div class="admonition-title">
<p>Method dispatch est谩tico</p>
<p><a class="admonition-anchor-link" href="javascript_intro.html#admonition-method-dispatch-est谩tico"></a></p>
</div>
<div>
<p>Supongamos que queremos extender la clase <code>point</code> del siguiente modo:</p>
<pre><code>Object subclass: #Point
M茅todos de instancia
setX: xValue setY: yValue
    xCoord := xValue.
    yCoord := yValue.

Point subclass: #ColorPoint
M茅todos de instancia
setX: xValue setY: yValue setColor: aColor
    xCoord := xValue.
    yCoord := yValue.
    color  := aColor.
</code></pre>
<p>Duplico c贸digo innecesariamente! En lugar de eso puedo usar <code>super</code>:</p>
<pre><code>Object subclass: #Point
M茅todos de instancia
setX: xValue setY: yValue
    xCoord := xValue.
    yCoord := yValue.

Point subclass: #ColorPoint
M茅todos de instancia
setX: xValue setY: yValue setColor: aColor
    self setX: xValue setY: yValue.
    color  := aColor.
</code></pre>
<p>Ahora supongamos que queremos hacer algo similar y definir el objeto <code>BluePoint</code>:</p>
<pre><code>Object subclass: #Point
M茅todos de instancia
setX: xValue setY: yValue
    xCoord := xValue.
    yCoord := yValue.

Point subclass: #BluePoint
instanceVarNames: 'color'
M茅todos de instancia
setX: xValue setY: yValue
    self setX: xValue setY: yValue.
    color  := 'blue'.
</code></pre>
<p>El problema de esto es que al hacer <code>self setX: _ setY: _</code> entro en un loop
infinito. Antes funcionaba porque ten铆a el constructor de 3 variables y llamo
al de la superclase que usa 2. En este caso sin embargo lo que pasa es que ya
pisamos la implementaci贸n de <code>setX: _ setY: _</code>.</p>
<p>Al usar <code>super</code> de la siguiente manera se arregla:</p>
<pre><code>Point subclass: #ColorPoint
instanceVarNames: 'color'
M茅todos de instancia
setX: xValue setY: yValue
    super setX: xValue setY: yValue.
    color  := 'blue'.
</code></pre>
<p><strong>OJO</strong>, <code>super</code> <strong>tambi茅n hace referencia al objeto receptor del mensaje</strong>, la
diferencia es que <code>super</code> cambia el comienzo del method lookup para que
arranque a buscar desde la clase padre.</p>
</div>
</div>
<h2 id="lenguajes-basados-en-objetos"><a class="header" href="#lenguajes-basados-en-objetos">Lenguajes basados en objetos</a></h2>
<p>O sea lenguajes que <strong>no usan clases</strong>. Tengo constructores para crear objetos particulares:</p>
<pre><code class="language-js">let celda {
    contenido: 0,
    get: function () { return this.contenido; },
    set: function (n) { this.contenido = n; },
}
</code></pre>
<p>Puedo definir procedimientos para generar objetos (es un constructor, pero no una clase):</p>
<pre><code class="language-js">Celda = function () {
    this.contenido = 0;
    this.get = function () { return this.contenido; };
    this.set = function (n) { this.contenido = n; };
}

otracelda = new Celda ();
</code></pre>
<h3 id="prototipado"><a class="header" href="#prototipado">Prototipado</a></h3>
<p>Es la idea de construir instancias concretas que son representantes de las instancias (son los prototipas). Las otras instancias se generan mediante clonaci贸n (es una shallow copy, s贸lo copia la primer linea de atributos y m茅todos. No se mete a fondo):</p>
<pre><code class="language-js">celdaClonada = Object.create(celda);
</code></pre>
<p>Los clones adem谩s se pueden cambiar:</p>
<pre><code class="language-js">celdaClonada.set = function (n) {
    this.contenido = this.contenido + n;
}
</code></pre>
<p>Es posible adem谩s implementar herencia a trav茅s de prototipos (lo veremos m谩s adelante).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c谩lculo-sigma"><a class="header" href="#c谩lculo-sigma">C谩lculo Sigma</a></h1>
<p>Vamos a ver una formalizaci贸n del c谩lculo de objetos (parcial)</p>
<ul>
<li>Basada en la formalizaci贸n de Abadi &amp; Cardelli del 98'</li>
<li>Bas谩da en sem谩ntica operacional big step (recuerdo: son dar pasos grandes para llegar al resultado)</li>
<li><strong>No tipado</strong> (y con un aire a funcional)
<ul>
<li>En el mismo libro de Abadi&amp;Cardelli dan una versi贸n imperativa</li>
</ul>
</li>
<li>Objetos como 煤nica estructura computacional
<ul>
<li>son colecciones de atributos (como los registros del funcional)</li>
<li><strong>todos</strong> los atributos son m茅todos</li>
</ul>
</li>
<li>Cada m茅todo tiene una 煤nica variable ligada que representa a <code>self/this</code> y un cuerpo que produce un resultado.</li>
<li>Los objetos proveen 2 operaciones:
<ul>
<li>env铆o de mensajes</li>
<li>redefinici贸n de un m茅todo (actualizar atributos, a.k.a modificar el estado)</li>
</ul>
</li>
</ul>
<h2 id="sintaxis"><a class="header" href="#sintaxis">Sintaxis</a></h2>
<p>$$
\begin{alignat}{2}
o,b ::=&amp; x\ &amp;\text{variable} \\
|&amp;\ [l_i = \zeta(x_i)b_i^i\in{1\dots n}] \ &amp;\text{objeto} \\
|&amp;\ o.l\ &amp;\text{selecci贸n / env铆o de mensaje} \\
|&amp;\ o.l \leftarrow \zeta(x)b\ &amp;\text{redefinici贸n de m茅todo}
\end{alignat}
$$</p>
<div id="admonition-un-objeto" class="admonition admonish-example">
<div class="admonition-title">
<p>Un objeto</p>
<p><a class="admonition-anchor-link" href="sigma_calc.html#admonition-un-objeto"></a></p>
</div>
<div>
<p>$$
o \stackrel{def}{=} [l_1 = \zeta(x_1)[],\ l_2 = \zeta(x_2).l_1]
$$</p>
<p>\(o\) tiene 2 m茅todos:</p>
<ul>
<li>\(l_1\) retorna un objeto vac铆o \([]\)</li>
<li>\(l_2\) es un m茅todo que env铆a el mensaje \(l_1\) a \(\text{self}\) (representado por \(x_2\))</li>
</ul>
</div>
</div>
<h2 id="atributos-vs-m茅todos"><a class="header" href="#atributos-vs-m茅todos">Atributos vs m茅todos</a></h2>
<p>El c谩lculo \(\sigma\) no incluye expl铆citamente atributos. Peeeeero podemos definir atributos como m茅todos que no usan \(\text{self}\). En el ejemplo anterior, \(l_1\) era un atributo. De esta forma podemos interpretar que</p>
<ul>
<li>un env铆o de mensaje puede ser la selecci贸n de un atributo</li>
<li>redefinir un m茅todo puede ser modificar el atributo</li>
</ul>
<p>Para simplificar la notaci贸n, tomamos algunos atajos:</p>
<ul>
<li>Definici贸n de atributo: \([\dots, l = b, \dots]\) lo usamos como abreviatura de \([\dots, l = \zeta(x)b, \dots]\)</li>
<li>Asignaci贸n de atributo: \(o.l := b\) lo usamos como abreviatura de \(o.l \leftarrow \zeta(x)b\)</li>
</ul>
<h2 id="variables-libres-1"><a class="header" href="#variables-libres-1">Variables Libres</a></h2>
<p>Pdemos ver a \(\zeta\) como el ligador de \(x_i\) en el cuerpo \(b_i\) (similar a como hac铆amos con \(\lambda\) en funcional) de la expresi贸n \(\zeta(x_i)b_i\):</p>
<p>$$
\begin{align}
fv(\zeta(x)b) &amp;= fv(b) \setminus \{x\} \\
fv(x) &amp;= \{x\} \\
fv([l_i = \zeta(x_i)b_i^i\in{1\dots n}]) &amp;= \bigcup^{i\in1\dots n} fv(\zeta(x_i)b_i) \\
fv(o.l) &amp;= fv(o) \\
fv(o.l \leftarrow \zeta(x)b) &amp;= fv(o.l) \cup fv(\zeta(x)b)
\end{align}
$$</p>
<blockquote>
<p>Duda pendiente: en el 煤ltimo caso no tendr铆a que sacarle las que estuviesen
libres previamente en \(o.l\) y no est茅n libres en el m茅todo con el que se
pisa?</p>
</blockquote>
<p>Un t茅rmino se dice <strong>cerrado</strong> si su conjunto de variables libres es vac铆o.</p>
<h2 id="sustituci贸n"><a class="header" href="#sustituci贸n">Sustituci贸n</a></h2>
<p>Asumamos que c es alguna expresi贸n arbitraria.</p>
<p>$$
\begin{align}
x\{c/x\} &amp;= c \\
y\{c/x\} &amp;= y \text{si} x \neq y \\
[l_i = \zeta(x_i)b_i^i\in{1\dots n}]\{c/x\} &amp;= [l_i = (\zeta(x_i)b_i)\{c/x\}^i\in{1\dots n}] \\
o.l\{c/x\} &amp;= (o\{c/x\}).l \\
(o.l \leftarrow \zeta(x)b)\{c/x\} &amp;= (o.l\{c/x\}) \leftarrow (\zeta(x)b\{c/x\}) \\
\zeta(y)b\{c/x\} &amp;= \zeta(y')(b\{y'/y\}\{c/x\}) \\
&amp;\text{si } y' \notin fv(\zeta(y)b) \cup fv(c) \cup \{x\} \\
\end{align}
$$</p>
<p>(Notar que esto es parecido a las alfa conversiones del c谩lculo lambda)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unidad-4---programaci贸n-funcional"><a class="header" href="#unidad-4---programaci贸n-funcional">Unidad 4 - Programaci贸n Funcional</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resoluci贸n-proposicional"><a class="header" href="#resoluci贸n-proposicional">Resoluci贸n Proposicional</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resoluci贸n-en-l贸gica-de-primer-orden"><a class="header" href="#resoluci贸n-en-l贸gica-de-primer-orden">Resoluci贸n en l贸gica de primer orden</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resoluci贸n-sld"><a class="header" href="#resoluci贸n-sld">Resoluci贸n SLD</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prolog"><a class="header" href="#prolog">Prolog</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pr谩cticas"><a class="header" href="#pr谩cticas">Pr谩cticas</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guia-0---repaso-haskell"><a class="header" href="#guia-0---repaso-haskell">Guia 0 - Repaso Haskell</a></h1>
<h2 id="ejercicio-1-1"><a class="header" href="#ejercicio-1-1">Ejercicio 1</a></h2>
<p>Dar el tipo y describir el comportamiento de las siguientes funciones del m贸dulo <code>Prelude</code> de Haskell:</p>
<p>Hago un par nom谩s (recomiendo primero jugar un poco con las funciones y si no les queda claro pueden usar <code>:doc NOMBRE_DE_LA_FUNCIN</code>):</p>
<ul>
<li><code>null</code>:</li>
</ul>
<pre><code class="language-haskell">ghci&gt; :type null
null :: Foldable t =&gt; t a -&gt; Bool
ghci&gt; null []
True
ghci&gt; null [1, 2 , 3]
False
</code></pre>
<p>Devuelve si una estructura est谩 vac铆a o no</p>
<ul>
<li><code>head</code></li>
</ul>
<pre><code class="language-haskell">ghci&gt; :type head
head :: GHC.Stack.Types.HasCallStack =&gt; [a] -&gt; a
ghci&gt; head []
*** Exception: Prelude.head: empty list
CallStack (from HasCallStack):
  error, called at libraries/base/GHC/List.hs:1646:3 in base:GHC.List
  errorEmptyList, called at libraries/base/GHC/List.hs:85:11 in base:GHC.List
  badHead, called at libraries/base/GHC/List.hs:81:28 in base:GHC.List
  head, called at &lt;interactive&gt;:9:1 in interactive:Ghci3
ghci&gt; head [1, 2]
1
</code></pre>
<p>Devuelve el primer elemento de una lista</p>
<ul>
<li><code>take</code></li>
</ul>
<pre><code class="language-haskell">ghci&gt; :type take
take :: Int -&gt; [a] -&gt; [a]
ghci&gt; take 3 [1, 2 , 3, 4]
[1,2,3]
ghci&gt; take 3 [1, 2]
[1,2]
ghci&gt; take 3 []
[]
</code></pre>
<p>Recibe un n煤mero <code>n</code> y una lista, y devuelve los primeros <code>n</code> elementos de dicha lista.</p>
<ul>
<li><code>!!</code></li>
</ul>
<pre><code class="language-haskell">ghci&gt; :type (!!)
(!!) :: GHC.Stack.Types.HasCallStack =&gt; [a] -&gt; Int -&gt; a
ghci&gt; [1, 2, 3, 4] !! 2
3
ghci&gt; [1, 2, 3, 4] !! 3
4
ghci&gt; [1, 2, 3, 4] !! 0
1
</code></pre>
<p>Es el operador de indexado.</p>
<h2 id="ejercicio-2-1"><a class="header" href="#ejercicio-2-1">Ejercicio 2</a></h2>
<p>Definir las siguientes funciones:</p>
<ul>
<li><code>valorAbsoluto :: Float -&gt; Float</code> que dado un n煤mero devuelve su valor absoluto.</li>
</ul>
<pre><code class="language-haskell">valorAbsoluto :: Float -&gt; Float
valorAbsoluto = abs
</code></pre>
<ul>
<li><code>bisiesto :: Int -&gt; Bool</code> que dado un n煤mero que representa un a帽o, indica si el mismo es bisiesto.</li>
</ul>
<pre><code class="language-haskell">bisiesto :: Int -&gt; Bool
bisiesto anio | mod anio 4 == 0 = True
              | otherwise       = False
</code></pre>
<ul>
<li><code>factorial :: Int -&gt; Int</code> definida 煤nicamente para enteros positivos, que computa el factorial.</li>
</ul>
<pre><code class="language-haskell">factorial :: Int -&gt; Int
factorial 1 = 1
factorial n = n * factorial (n-1)
</code></pre>
<ul>
<li><code>cantDivisoresPrimos :: Int -&gt; Int</code>, que dado un entero positivo devuelve la cantidad de divisores primos</li>
</ul>
<pre><code class="language-haskell">valorAbsoluto :: Float -&gt; Float
valorAbsoluto = abs

bisiesto :: Int -&gt; Bool
bisiesto anio | mod anio 4 == 0 = True
              | otherwise       = False

factorial :: Int -&gt; Int
factorial 1 = 1
factorial n = n * factorial (n-1)

cantDivisoresPrimos :: Int -&gt; Int
cantDivisoresPrimos n = cantDivisoresPrimosMenoresA n n

cantDivisoresPrimosMenoresA :: Int -&gt; Int -&gt; Int
cantDivisoresPrimosMenoresA _ 1 = 0
cantDivisoresPrimosMenoresA n divisorCandidato | esPrimo divisorCandidato &amp;&amp; mod n divisorCandidato == 0 = 1 + divisoresMenores
                                               | otherwise                   = divisoresMenores
                                              where divisoresMenores = cantDivisoresPrimosMenoresA n (divisorCandidato - 1)

esPrimo :: Int -&gt; Bool
esPrimo n = cantDivisoresMenoresA n n == 2

cantDivisoresMenoresA :: Int -&gt; Int -&gt; Int
cantDivisoresMenoresA _ 1 = 1
cantDivisoresMenoresA n divisorCandidato | mod n divisorCandidato == 0 = 1 + divisoresMenores
                                         | otherwise                   = divisoresMenores
                                         where divisoresMenores = cantDivisoresMenoresA n (divisorCandidato - 1)
</code></pre>
<h2 id="ejercicio-3-1"><a class="header" href="#ejercicio-3-1">Ejercicio 3</a></h2>
<p>Contamos con los tipos <code>Maybe</code> y <code>Either</code> definidos como sigue:</p>
<pre><code class="language-haskell">data Maybe a = Nothing | Just a
data Either a b = Left a | Right b
</code></pre>
<ul>
<li>Definir la funci贸n <code>inverso :: Float -&gt; Maybe Float</code> que dado un n煤mero devuelve su inverso multiplicativo si est谩 definido, o <code>Nothing</code> en caso contrario.</li>
</ul>
<pre><code class="language-haskell">inverso :: Float -&gt; Maybe Float
inverso 0.0 = Nothing
inverso x = Just (1.0 / x)
</code></pre>
<ul>
<li>Definir la funci贸n <code>aEntero :: Either Int Bool -&gt; Int</code> que convierte a entero una expresi贸n que puede ser booleana o entera. En el caso de los booleanos, el entero que corresponde es 0 para <code>False</code> y 1 para <code>True</code>.</li>
</ul>
<pre><code class="language-haskell">aEntero :: Either Int Bool -&gt; Int
aEntero (Left unEntero) = unEntero
aEntero (Right True) = 1
aEntero (Right False) = 0
</code></pre>
<h2 id="ejercicio-4-1"><a class="header" href="#ejercicio-4-1">Ejercicio 4</a></h2>
<p>Definir las siguientes funciones sobre listas:</p>
<ul>
<li><code>limpiar :: String -&gt; String -&gt; String</code>, que elimina todas las apariciones de cualquier car谩cter de la primera cadena en la segunda. Por ejemplo, <code>limpiar "susto" "puerta"</code> eval煤a a <code>"pera"</code>. Nota: <code>String</code> es un renombre de <code>[Char]</code>. La notaci贸n <code>"hola"</code> es equivalente a <code>['h', 'o', 'l', 'a']</code> y a <code>'h':'o':'l':'a':[]</code></li>
</ul>
<pre><code class="language-haskell">limpiar :: String -&gt; String -&gt; String
limpiar [] fromStr = fromStr 
limpiar (unChar:restoDelPatron) fromStr = limpiar restoDelPatron (filter (/= unChar) fromStr) 
</code></pre>
<ul>
<li><code>difPromedio :: [Float] -&gt; [Float]</code> que dada una lista de n煤meros devuelve la diferencia de cada uno con el promedio general. Por ejemplo, <code>difPromedio [2, 3, 4]</code> eval煤a a <code>[-1, 0, 1]</code>.</li>
</ul>
<pre><code class="language-haskell">difPromedio :: [Float] -&gt; [Float]
difPromedio xs = map (\x -&gt; x - promedioXs) xs
              where promedioXs = promedio xs

promedio :: [Float] -&gt; Float
promedio [] = 0.0
promedio xs = sum xs / fromIntegral (length xs)
</code></pre>
<ul>
<li><code>todosIguales :: [Int] -&gt; Bool</code> que indica si una lista de enteros tiene todos sus elementos iguales.</li>
</ul>
<pre><code class="language-haskell">todosIguales :: [Int] -&gt; Bool
todosIguales [] = True
todosIguales (x:xs) = all (== x) xs
</code></pre>
<h2 id="ejercicio-5-1"><a class="header" href="#ejercicio-5-1">Ejercicio 5</a></h2>
<p>Dado el siguiente modelo para 谩rboles binarios:</p>
<pre><code class="language-haskell">data AB a = Nil | Bin (AB a) a (AB a)
</code></pre>
<p>definir las siguientes funciones:</p>
<ul>
<li><code>vacioAB :: AB a -&gt; Bool</code> que indica si un 谩rbol es vac铆o (i.e. no tiene nodos)</li>
</ul>
<pre><code class="language-haskell">vacioAB :: AB a -&gt; Bool
vacioAB Nil = True
vacioAB _ = False
</code></pre>
<ul>
<li><code>negacionAB :: AB bool -&gt; AB Bool</code> que dado un 谩rbol de booleanos construye otro formulado por la negaci贸n de cada uno de los nodos.</li>
</ul>
<pre><code class="language-haskell">negacionAB :: AB Bool -&gt; AB Bool
negacionAB Nil = Nil
negacionAB (Bin (hijoIzq) nodo (hijoDer)) = Bin (negacionAB hijoIzq) (not nodo) (negacionAB hijoDer)
</code></pre>
<ul>
<li><code>productoAB :: AB Int -&gt; Int</code> que calcula el producto de todos los nodos del 谩rbol</li>
</ul>
<pre><code class="language-haskell">productoAB :: AB Int -&gt; Int
productoAB Nil = 1
productoAB (Bin hijoIzq nodo hijoDer) = productoAB hijoIzq * nodo * productoAB hijoDer
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guia-1---programaci贸n-funcional"><a class="header" href="#guia-1---programaci贸n-funcional">Guia 1 - Programaci贸n funcional</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guia-2---c谩lculo-lambda-tipado"><a class="header" href="#guia-2---c谩lculo-lambda-tipado">Guia 2 - C谩lculo Lambda Tipado</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guia-3---inferencia-de-tipos"><a class="header" href="#guia-3---inferencia-de-tipos">Guia 3 - Inferencia de Tipos</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guia-4---subtipado"><a class="header" href="#guia-4---subtipado">Guia 4 - Subtipado</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guia-5---programaci贸n-orientada-a-objetos"><a class="header" href="#guia-5---programaci贸n-orientada-a-objetos">Guia 5 - Programaci贸n Orientada a Objetos</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guia-6---resoluci贸n-l贸gica"><a class="header" href="#guia-6---resoluci贸n-l贸gica">Guia 6 - Resoluci贸n L贸gica</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guia-7---programaci贸n-l贸gica"><a class="header" href="#guia-7---programaci贸n-l贸gica">Guia 7 - Programaci贸n L贸gica</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bibliograf铆a"><a class="header" href="#bibliograf铆a">Bibliograf铆a</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>
        <script src="theme/pagetoc.js"></script>

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
