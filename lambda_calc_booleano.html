<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Cálculo Lambda Tipado Booleano - Apunte Final Paradigmas de Lenguajes de Programación 2024</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./custom.css">
        <link rel="stylesheet" href="./mdbook-admonish.css">
        <link rel="stylesheet" href="theme/pagetoc.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="unidad_1.html"><strong aria-hidden="true">1.</strong> Unidad 1 - Programación Funcional Con Haskell</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="programacion_funcional.html"><strong aria-hidden="true">1.1.</strong> Intro a Haskell</a></li><li class="chapter-item expanded "><a href="esquemas_de_recursion.html"><strong aria-hidden="true">1.2.</strong> Esquemas de recursión</a></li></ol></li><li class="chapter-item expanded "><a href="unidad_2.html"><strong aria-hidden="true">2.</strong> Unidad 2 - Cálculo Lambda</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lambda_calc_booleano.html" class="active"><strong aria-hidden="true">2.1.</strong> Cálculo Lambda Tipado Booleano</a></li><li class="chapter-item expanded "><a href="lambda_calc_extendido.html"><strong aria-hidden="true">2.2.</strong> Cálculo Lambda Tipado Extendido</a></li><li class="chapter-item expanded "><a href="inferencia_de_tipos.html"><strong aria-hidden="true">2.3.</strong> Inferencia de tipos</a></li><li class="chapter-item expanded "><a href="subtipado.html"><strong aria-hidden="true">2.4.</strong> Subtipado</a></li></ol></li><li class="chapter-item expanded "><a href="unidad_3.html"><strong aria-hidden="true">3.</strong> Unidad 3 - Paradigma de Objetos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="javascript_intro.html"><strong aria-hidden="true">3.1.</strong> Intro a POO</a></li><li class="chapter-item expanded "><a href="sigma_calc.html"><strong aria-hidden="true">3.2.</strong> Cálculo Sigma</a></li></ol></li><li class="chapter-item expanded "><a href="unidad_4.html"><strong aria-hidden="true">4.</strong> Unidad 4 - Programación Lógica</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="prop_solv.html"><strong aria-hidden="true">4.1.</strong> Resolución Proposicional</a></li><li class="chapter-item expanded "><a href="primer_orden_solv.html"><strong aria-hidden="true">4.2.</strong> Resolución en Lógica de primer orden</a></li><li class="chapter-item expanded "><a href="sld_solv.html"><strong aria-hidden="true">4.3.</strong> Resolución SLD</a></li><li class="chapter-item expanded "><a href="prolog.html"><strong aria-hidden="true">4.4.</strong> Prolog</a></li></ol></li><li class="chapter-item expanded "><a href="practicas.html"><strong aria-hidden="true">5.</strong> Prácticas</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="guia_0.html"><strong aria-hidden="true">5.1.</strong> Guia 0 - Repaso Haskell</a></li><li class="chapter-item expanded "><a href="guia_1.html"><strong aria-hidden="true">5.2.</strong> Guia 1 - Programación funcional</a></li><li class="chapter-item expanded "><a href="guia_2.html"><strong aria-hidden="true">5.3.</strong> Guia 2 - Cálculo Lambda Tipado</a></li><li class="chapter-item expanded "><a href="guia_3.html"><strong aria-hidden="true">5.4.</strong> Guia 3 - Inferencia de Tipos</a></li><li class="chapter-item expanded "><a href="guia_4.html"><strong aria-hidden="true">5.5.</strong> Guia 4 - Subtipado</a></li><li class="chapter-item expanded "><a href="guia_5.html"><strong aria-hidden="true">5.6.</strong> Guia 5 - Programación Orientada a Objetos</a></li><li class="chapter-item expanded "><a href="guia_6.html"><strong aria-hidden="true">5.7.</strong> Guia 6 - Resolución Lógica</a></li><li class="chapter-item expanded "><a href="guia_7.html"><strong aria-hidden="true">5.8.</strong> Guia 7 - Programación Lógica</a></li></ol></li><li class="chapter-item expanded "><a href="bibliografía.html"><strong aria-hidden="true">6.</strong> Bibliografía</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Apunte Final Paradigmas de Lenguajes de Programación 2024</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main><div class="sidetoc"><nav class="pagetoc"></nav></div>
                        <p>$$
\newcommand{\lcb}{\lambda^b}
\newcommand{\ifLC}[3]{if\  {#1}\  then\  {#2}\  else\  {#3}}
\newcommand{\lf}[3]{\lambda{#1}:\ {#2}.{#3}}
\newcommand{\apply}[2]{{#1}\ {#2}}
\newcommand{\hastype}[3]{{#1} \triangleright {#2}: {#3}}
\newcommand{\ttrue}[1]{\frac{}{\hastype{#1}{true}{Bool}} (T-True)}
\newcommand{\tfalse}[1]{\frac{}{\hastype{#1}{false}{Bool}} (T-False)}
\newcommand{\tvar}[3]{\frac{{#2}:{#3} \in {#1}}{\hastype{#1}{#2}{#3}} (T-var)}
\newcommand{\tif}[5]{\frac{\hastype{#1}{#2}{Bool}\ \ \hastype{#1}{#3}{#5}\ \ \hastype{#1}{#4}{#5}}{\hastype{#1}{\ifLC{{#2}}{{#3}}{{#4}}}{#5}} (T-If)}
\newcommand{\tabs}[5]{\frac{\hastype{{#1},{#2}:{#3}}{#5}{#4}}{\hastype{#1}{\lf{{#2}}{{#3}}{{#5}}}{{#3} \rightarrow {#4}}} (T-abs)}
\newcommand{\tapp}[5]{\frac{\hastype{#1}{#2}{#3 \rightarrow #4}\ \ \hastype{#1}{#5}{#3}}{\hastype{#1}{\apply{{#2}}{{#5}}}{#4}} (T-app)}
\newcommand{\eiftrue}[2]{\frac{}{\ifLC{true}{#1}{#2} \rightarrow #1} (E-IfTrue)}
\newcommand{\eiffalse}[2]{\frac{}{\ifLC{false}{#1}{#2} \rightarrow #2} (E-IfFalse)}
\newcommand{\eif}[4]{\frac{#1 \rightarrow #2}{\ifLC{#1}{#3}{#4} \rightarrow \ifLC{#2}{#3}{#4}} (E-If)}
\newcommand{\eift}[4]{\frac{\eiftrue{#3}{#4}}{\ifLC{#1}{#3}{#4} \rightarrow \ifLC{#2}{#3}{#4}} (E-If)}
\newcommand{\eiff}[4]{\frac{\eiffalse{#3}{#4}}{\ifLC{#1}{#3}{#4} \rightarrow \ifLC{#2}{#3}{#4}} (E-If)}
$$</p>
<h1 id="cálculo-lambda-tipado-booleano-lcb"><a class="header" href="#cálculo-lambda-tipado-booleano-lcb">Cálculo Lambda Tipado Booleano \(\lcb\)</a></h1>
<h2 id="expresiones-de-tipos"><a class="header" href="#expresiones-de-tipos">Expresiones de tipos</a></h2>
<p>Las expresiones de tipos (o simplemente tipos) de \(\lcb\) son:</p>
<p>$$
\sigma, \tau ::= Bool | \sigma \rightarrow \tau
$$</p>
<p>En criollo,</p>
<ul>
<li>\(Bool\) es el tipo de los booleanos</li>
<li>\(\sigma \rightarrow \tau\) es el tipo de las funciones de tipo
\(\sigma\) en \(\tau\)</li>
</ul>
<p>Por ejemplo, uno puede tener una función \(Bool \rightarrow Bool\)</p>
<h2 id="términos-de-lambdab"><a class="header" href="#términos-de-lambdab">Términos de \(\lambda^b\)</a></h2>
<p>Sea \(\mathcal{X}\) un conjunto infinito enumerable de variables y \(x \in \mathcal{X}\). Los términos de \(\lambda^b\) están definidos por:</p>
<p>$$
\begin{align}
M,N,P,Q ::=&amp; \ x \\
&amp;| \ true \\
&amp;| \ false \\
&amp;| \ \ifLC{M}{P}{Q} \\
&amp;| \ \lf{x}{\sigma}{M} \\
&amp;| \ \apply{M}{N}
\end{align}
$$</p>
<p>Es importante entender que estas reglas <strong>sólo definen cómo construir sintácticamente los términos</strong>, pero no necesariamente te va a dar cosas que tengan sentido ni que sean útiles. Veamos algunos ejemplos de términos válidos:</p>
<ul>
<li>\(\lf{x}{Bool}{x}\)</li>
<li>\(\lf{x}{Bool}{\ifLC{x}{false}{true}}\)</li>
<li>\(\lf{f}{Bool \rightarrow Bool \rightarrow Bool}{\lf{x}{Bool}{\apply{f}{x}}}\)</li>
<li>\((\lf{f}{Bool \rightarrow Bool}{\apply{f}{true}})(\lf{y}{Bool}{y})\)</li>
<li>\(\apply{true}{(\lf{x}{Bool}{x})}\)</li>
<li>\(\apply{x}{y}\)</li>
</ul>
<h2 id="sistema-de-tipado"><a class="header" href="#sistema-de-tipado">Sistema de tipado</a></h2>
<ul>
<li>Es un sistema formal de deducción/derivación que usa axiomas y reglas de
inferencia para caracterizar al conjunto de los conjuntos "bien tipados"</li>
<li>Lo definimos a partir de reglas de inferencia
<ul>
<li>axiomas de tipado para algunos términos</li>
<li>reglas de tipado para otros términos, que derivan (siempre y cuando se
pueda) el tipado de una expresión en base a sus sub-expresiones.</li>
</ul>
</li>
</ul>
<h2 id="variables-libres"><a class="header" href="#variables-libres">Variables libres</a></h2>
<p>Ya vimos que tenemos funciones lambda que se pueden usar en la construcción de
términos. Antes de seguir con otras cosas está bueno definir y distinguir las
<strong>variables libres</strong> de las <strong>variables ligadas</strong>. Una variable \(x\) se dice
que ocurre libre si no está bajo el alcance de alguna ocurrencia de un
\(\lambda x\). En otro caso decimos que ocurre ligada.</p>
<p><img src="./img/var_libre_vs_ligada.png#center" alt="" /></p>
<p>Más formalmente:</p>
<p>$$
\begin{align}
FV(x) &amp;\stackrel{def}{=} \{ x \} \\
FV(true) = FV(false) &amp;\stackrel{def}{=} \emptyset \\
FV(\ifLC{M}{P}{Q}) &amp;\stackrel{def}{=} FV(M) \cup FV(P) \cup FV(Q) \\
FV(\apply{M}{N}) &amp;\stackrel{def}{=} FV(M) \cup FV(N) \\
FV(\lf{x}{\sigma}{M}) &amp;\stackrel{def}{=} FV(M) \setminus \{x\} \\
\end{align}
$$</p>
<h2 id="sistema-de-tipado-1"><a class="header" href="#sistema-de-tipado-1">Sistema de tipado</a></h2>
<p>Un <strong>juicio de tipado</strong> es una expresión de la forma \(\Gamma \triangleright M\ :\ \sigma\) que se lee como: "el término \(M\) tiene tipo \(\sigma\) asumiendo el contexto de tipado \(\Gamma\)"</p>
<p>Un <strong>contexto de tipado</strong> por otro lado es un conjunto de pares \(x_i\ :\ \sigma_i\), anotado \(\{x_1\ :\ \sigma_1, \dots, x_n\ :\ \sigma_n\}\) donde los \(\{x_i\}_{i \in 1 \dots n}\) son distintos. Usamos letras \(\Gamma\), \(\bigtriangleup\), ... para contextos de tiapdo.</p>
<h2 id="axiomas-de-tipado-de-lcb"><a class="header" href="#axiomas-de-tipado-de-lcb">Axiomas de tipado de \(\lcb\)</a></h2>
<p>Obs: están guiadas por la sintáxis!</p>
<p>$$
\ttrue{\Gamma}
$$</p>
<p>$$
\tfalse{\Gamma}
$$</p>
<p>$$
\tvar{\Gamma}{x}{\sigma}
$$</p>
<p>$$
\tif{\Gamma}{M}{P}{Q}{\sigma}
$$</p>
<p>$$
\tabs{\Gamma}{x}{\sigma}{\tau}{M}
$$</p>
<p>$$
\tapp{\Gamma}{M}{\sigma}{\tau}{N}
$$</p>
<ul>
<li>Si \(\hastype{\Gamma}{M}{\sigma}\) puede derivarse usando los axiomas y reglas de tipado decimos que es derivable.</li>
<li>Decimos que \(M\) es tipable si el juicio de tiapdo \(\hastype{\Gamma}{M}{\sigma}\) puede derivarse, para algún \(\Gamma\) y \(\sigma\).</li>
</ul>
<h2 id="resultados-básicos-demostración-con-inducción-estructural"><a class="header" href="#resultados-básicos-demostración-con-inducción-estructural">Resultados básicos (demostración con inducción estructural)</a></h2>
<h3 id="unicidad-de-tipos"><a class="header" href="#unicidad-de-tipos">Unicidad de tipos</a></h3>
<p>Si \(\hastype{\Gamma}{M}{\sigma}\) y \(\hastype{\Gamma}{M}{\tau}\) son derivables, entonces \(\sigma = \tau\).</p>
<h3 id="weakening--strengthening"><a class="header" href="#weakening--strengthening">Weakening + Strengthening</a></h3>
<p>Si \(\hastype{\Gamma}{M}{\sigma}\) es derivable y \(\Gamma \cap \Gamma'\) contiene a todas las variables libres de \(M\), entonces \(\hastype{\Gamma'}{M}{\sigma}\).</p>
<h2 id="semántica-o-sea-qué-hacen-mis-cómputos"><a class="header" href="#semántica-o-sea-qué-hacen-mis-cómputos">Semántica (o sea qué hacen mis cómputos)</a></h2>
<p>Hasta ahora definimos para \(\lcb\) con reglas inductivas:</p>
<ul>
<li>una sintáxis</li>
<li>un sistema de tipado</li>
</ul>
<p>Ahora vamos a darle significado a los términos que para nosotros tengan sentido
(o sea aquellos que estén bien tipados).</p>
<p>Hay distintas formas de definir la semántica, en particular vamos a dar una
<strong>semántica operacional</strong>. Nota: hay otros tipos de semántica, como la
semántica axiomática (similar a lo que vimos en algo 1 con pre-condición y
post-condición, basada en aserciones), denotacional (le das una denotación a
cada término del lenguaje y definís la semántica dando funciones para los
elementos de la sintaxis).</p>
<p>En qué consiste entonces la semántica operacional:</p>
<ul>
<li>interpreto a los términos como estados de una máquina abstracta</li>
<li>defino reglas para hacer evolucionar (reducir) los términos en otros términos
<ul>
<li>también están guiadas por sintaxis</li>
</ul>
</li>
<li>el <strong>significado</strong> de un término \(M\) es el estado final que alcanza la
máquina si comienza con el estado inicial \(M\)</li>
<li>hay dos formas de dar la semántica operacional:
<ul>
<li><strong>small-step</strong>: describo pasos chiquitos. Vamos a ver principalmente
este.</li>
<li><strong>big-step (o natural semantics)</strong>: la función de transición en un paso
reduce al resultado.</li>
</ul>
</li>
<li>definir la semántica tiene que hacerse de forma precisa cosa de poder llevar
todo a una implementación de un intérprete del lenguaje.</li>
</ul>
<h2 id="semántica-small-step"><a class="header" href="#semántica-small-step">Semántica small-step</a></h2>
<ul>
<li>La hacemos a través de <strong>juicios de evaluación</strong>, a.k.a. reglas de reducción que se leen como "el término \(M\) reduce en un paso al término \(N\)":</li>
</ul>
<p>$$
M \rightarrow N
$$</p>
<ul>
<li>Uso axiomas de evaluación + reglas de derivación que establecen que algunos
juicios de evaluación son derivables a partir de otros juicios que también
son derivables.</li>
<li>Además de la función de transición, tenemos que definir los <strong>valores</strong>, que
son los posibles resultados de una evaluación de términos, en tanto sean
cerrados (no tiene variables libres) y estén bien tipados.</li>
</ul>
<h3 id="valores"><a class="header" href="#valores">Valores</a></h3>
<p>Como nuestro lambda cálculo es booleano, nos interesan true y false. O sea que
expresiones complejas también pueden reducir a esos valores. O sea, todo
término bien tiapdo y cerrado de tipo \(Bool\) evalúa en cero o más pasos, a
\(true\) o \(false\).</p>
<p>$$
V ::= true\ |\ false
$$</p>
<h3 id="juicio-de-evaluación-en-un-paso"><a class="header" href="#juicio-de-evaluación-en-un-paso">Juicio de evaluación en un paso</a></h3>
<p>Al If podemos pensarlo como que lo tenemos que reducir por completo el término
del \(if\) hasta un valor, sea \(true\) o \(false\)</p>
<p>$$
\eiftrue{M_2}{M_3}
$$</p>
<p>$$
\eiffalse{M_2}{M_3}
$$</p>
<p>$$
\eif{M_1}{M_1'}{M_2}{M_3}
$$</p>
<div id="admonition-ejemplo" class="admonition admonish-info">
<div class="admonition-title">
<p>Ejemplo</p>
<p><a class="admonition-anchor-link" href="#admonition-ejemplo"></a></p>
</div>
<div>
<p>$$
\eiff{(\ifLC{false}{false}{true})}{true}{false}{true}
$$</p>
<p>Observaciones:</p>
<ul>
<li>No hay \(M\) tal que \(true \rightarrow M\)</li>
<li>Idem con \(false\)</li>
</ul>
</div>
</div>
<h4 id="algunas-propiedades-interesantes"><a class="header" href="#algunas-propiedades-interesantes">Algunas propiedades Interesantes</a></h4>
<ul>
<li><strong>Lema</strong> (Determinismo del juicio de evaluación en un paso): Si las reglas están bien hechas, y \(M \rightarrow M'\) \(M \rightarrow M''\) entonces \(M' = M''\)</li>
<li>Una <strong>forma noraml</strong> es un término que no puede evaluarse más (o sea no existe una regla para reducir).</li>
<li>(recuerdo: un valor es el resultado al que puede evaluar un término bien tipado y cerrado)</li>
<li><strong>Lema</strong>: todo valor está en forma normal. No vale el recíproco en \(\lcb\). Por ejemplo:
<ul>
<li>\(\ifLC{x}{true}{false}\), no tengo cómo reducir porque \(x\) ta libre</li>
<li>\(x\), mismo caso</li>
<li>\(\apply{true}{false}\), no puedo reducir (tampoco tipa...)</li>
</ul>
</li>
<li>Lo vemos en un toque, pero el resultado más fuerte es que si una expresión es cerrada y bien tipada eventualmente puedo reducir hasta llegar a un valor.</li>
</ul>
<h3 id="evaluación-en-muchos-pasos"><a class="header" href="#evaluación-en-muchos-pasos">Evaluación en muchos pasos</a></h3>
<p>El <strong>juicio de evaluación en muchos pasos</strong> \(\twoheadrightarrow\) es la clausura reflexiva y transitiva de \(\rightarrow\). O sea es la menor relación tal que:</p>
<ol>
<li>Si \(M \rightarrow M'\), entonces \(M \twoheadrightarrow M'\)</li>
<li>\(M \twoheadrightarrow M\) para todo \(M\)</li>
<li>Si \(M \twoheadrightarrow M'\) y \(M' \twoheadrightarrow M''\), entonces \(M \twoheadrightarrow M''\)</li>
</ol>
<p>Por ejemplo, tenemos que:</p>
<p>$$
\ifLC{true}{(\ifLC{false}{false}{true})}{true} \twoheadrightarrow true
$$</p>
<h4 id="propiedades"><a class="header" href="#propiedades">Propiedades</a></h4>
<p>Para el cálculo de expresiones booleanas valen:</p>
<ul>
<li><strong>Lema</strong> (Unicidad de formas normales): Si \(M \twoheadrightarrow U\) y \(M \twoheadrightarrow V\), con \(U, V\) formas normales, entonces \(U = V\)</li>
<li><strong>Lema</strong> (Terminación): Para todo \(M\) existe una forma normal \(N\) tal que \(M \twoheadrightarrow \).
<ul>
<li>esto es bueno porque me aseguro que mi algoritmo de evaluación no tiene loops infinitos</li>
</ul>
</li>
</ul>
<h2 id="semántica-operacional-de-lcb"><a class="header" href="#semántica-operacional-de-lcb">Semántica Operacional de \(\lcb\)</a></h2>
<p>Ya hablamos antes de que en haskell por ejemplo, las funciones también pueden ser resultados de una evaluación (eso de first class citizen, yada yada yada...). Así que por qué no extendemos nuestro conjunto de valores:</p>
<p>$$
V ::= true\ false\ \lf{x}{\sigma}{M}
$$</p>
<p>Vamos a extender nuestro sistema tal que valgan los lemas previos, pero además valga el siguiente resultado:</p>
<div id="admonition-teorema" class="admonition admonish-abstract">
<div class="admonition-title">
<p>Teorema</p>
<p><a class="admonition-anchor-link" href="#admonition-teorema"></a></p>
</div>
<div>
<p>Para todo término bien tipado y cerrado de tipo:</p>
<ul>
<li>\(Bool\) evalúa, en cero o más pasos, a \(true, false\).</li>
<li>\(\sigma \rightarrow \tau\) evalúa, en cero o más pasos, a \(\lf{x}{\sigma}{M}\), para alguna variable \(x\) y algún término \(M\)
<ul>
<li>en castellano: si tipa como una función eventualmente lo puedo reducir a la forma de una lambda con una variable y un término</li>
</ul>
</li>
</ul>
</div>
</div>
<h3 id="juicio-de-evaluación-en-un-paso-1"><a class="header" href="#juicio-de-evaluación-en-un-paso-1">Juicio de evaluación en un paso</a></h3>
<ul>
<li>Primero, una regla que me haga reducir lo más que pueda la "función" que quiero evaluar:</li>
</ul>
<p>$$
\frac{M_1 \rightarrow M_1'}{\apply{M_1}{M_2} \rightarrow \apply{M_1'}{M_2}} (E-App1 / \mu)
$$</p>
<ul>
<li>Segundo, una regla que me haga reducir lo más que pueda al argumento:</li>
</ul>
<p>$$
\frac{M_2 \rightarrow M_2'}{\apply{(\lf{x}{\sigma}{M})}{M_2} \rightarrow \apply{(\lf{x}{\sigma}{M})}{M_2'}} (E-App1 / v)
$$</p>
<ul>
<li>Por último, una regla que se encargue del reemplazo de la evaluación</li>
</ul>
<p>$$
\frac{}{\apply{(\lf{x}{\sigma}{M})}{V} \rightarrow M \{x \leftarrow V\}} (E-AppAbs / \beta)
$$</p>
<ul>
<li>Esto último quiere decir agarrar la función lambda, y reemplazar sintácticamente las ocurrencias de \(x\) por \(V\)
<ul>
<li>sustituyo únicamente las ocurrencias <strong>libres</strong> de \(x\)</li>
<li>le da semántica a la aplicación de funciones</li>
<li>hay que tener cuidado con los ligadores de variable (los \(\lambda x\))</li>
</ul>
</li>
</ul>
<p>Podemos dar una definición basada en la sintaxis:</p>
<p>$$
\begin{align}
x \{x \leftarrow N\} &amp;\stackrel{def}{=} N \\
a \{x \leftarrow N\} &amp;\stackrel{def}{=} a \text{si a } \notin \{true, false\} \cup \mathcal{X} \setminus \{x\} \\
\ifLC{M}{P}{Q} \{x \leftarrow N\} &amp;\stackrel{def}{=} \ifLC{M\{x \leftarrow N\}}{P\{x \leftarrow N\}}{Q\{x \leftarrow N\}} \\
(\apply{M_1}{M_2}) \{x \leftarrow N\} &amp;\stackrel{def}{=} \apply{M_1\{x \leftarrow N\}}{M_2\{x \leftarrow N\}} \\
\lf{y}{\sigma}{M} \{x \leftarrow N\} &amp;\stackrel{def}{=} ? \\
\end{align}
$$</p>
<p>Y ese último? Imaginemos el caso de la sustitución:</p>
<p>$$
\lf{z}{\sigma}{x} \{x \leftarrow N\} \stackrel{def}{=} \lf{z}{\sigma}{z}
$$</p>
<p>La convertimos de la función constante en la función identidad! Pero bueno, a
priori no importa qué nombre tenga la variable ligada, no? Entonces, lo que
podemos hacer es renombrar (o asumir que se hizo el renombre para estas
reglas), de manera tal que la variable que se liga en la función lambda <strong>no
ocurre libre</strong> en \(N\). De ser así la regla nos queda:</p>
<p>$$
\lf{y}{\sigma}{M} \{x \leftarrow N\} \stackrel{def}{=} \lf{y}{\sigma}{M\{x \leftarrow N\}}\ \ x \neq y, y \notin FV(N) \\
$$</p>
<p>Para formalizar esto aparece el concepto de \(\alpha\)-equivalencia. Dos
términos son \(\alpha\)-equivalentes si <strong>únicamente difieren en el nombre de
sus variables ligadas</strong>. Es una relación de equivalencia.</p>
<div id="admonition-algunos-ejemplos" class="admonition admonish-example">
<div class="admonition-title">
<p>Algunos ejemplos</p>
<p><a class="admonition-anchor-link" href="#admonition-algunos-ejemplos"></a></p>
</div>
<div>
<ul>
<li>\(\lf{x}{Bool}{x} =_{\alpha} \lf{y}{Bool}{y}\)</li>
<li>\(\lf{x}{Bool}{y} =_{\alpha} \lf{z}{Bool}{y}\)
<ul>
<li>acá \(y\) es variable libre en ambos casos</li>
</ul>
</li>
<li>\(\lf{x}{Bool}{y} \neq_{\alpha} \lf{x}{Bool}{z}\)
<ul>
<li>acá tanto \(y\) como \(z\) son variables libres y son distintas en cada término.</li>
</ul>
</li>
<li>\(\lf{x}{Bool}{\lf{x}{Bool}{x}} \neq_{\alpha} \lf{y}{Bool}{\lf{x}{Bool}{y}}\)
<ul>
<li>acá la lambda interna tiene en su subtérmino a la \(x\) ligada, mientras que del lado derecho no.</li>
</ul>
</li>
</ul>
<p>Llevado a la práctica, esto quiere decir que mientras hagamos las reducciones,
podemos tener que hacer el reemplazo por un término \(\alpha\)-equivalente y
después aplicar la sustitución.</p>
</div>
</div>
<h2 id="estado-de-error"><a class="header" href="#estado-de-error">Estado de error</a></h2>
<ul>
<li>Es un estado (término) que <strong>no es</strong> un valor, pero en el que la evaluación está <strong>trabada</strong>.</li>
<li>Representa un estado en el cual el sistema de runtime en una implementación real generaría una excepción</li>
<li>Ejemplos:
<ul>
<li>\(\ifLC{x}{M}{N}\)
<ul>
<li>obs: no es cerrado</li>
</ul>
</li>
<li>\(\apply{true}{M}\)
<ul>
<li>obs: no es tipable</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="objetivo-de-un-sistema-de-tipos"><a class="header" href="#objetivo-de-un-sistema-de-tipos">Objetivo de un sistema de tipos</a></h2>
<p>Queremos garantizar la <strong>ausencia</strong> de estados de error. Decimos que un término
<strong>termina</strong> o que es <strong>fuertemente normalizante</strong> si no hay cadenas de
reducción infinitas a partir de él.</p>
<div id="admonition-teorema-1" class="admonition admonish-note">
<div class="admonition-title">
<p>Teorema</p>
<p><a class="admonition-anchor-link" href="#admonition-teorema-1"></a></p>
</div>
<div>
<ul>
<li>Todo término bien tipado termina</li>
<li>Si un término cerrado está bien tipado, entonces evalúa a un valor</li>
</ul>
</div>
</div>
<p>Tenemos algunas propiedades que nos garantizan este teorema:</p>
<ul>
<li>Progreso: Si \(M\) es cerrado y bien tipado, entonces:
<ul>
<li>\(M\) es un valor</li>
<li>o bien existe \(M'\) tal que \(M \rightarrow M'\) (o sea no se traba si los términos son cerrados y bien tipados, y no son valores)</li>
</ul>
</li>
<li>Preservación (de tipo): Si \(\hastype{\Gamma}{M}{\sigma}\) y \(M \rightarrow N\), entonces \(\hastype{\Gamma}{N}{\sigma}\) (o sea que la reducción/evaluación preserva tipos).</li>
</ul>
<blockquote>
<p><strong>Observación</strong>: parto de progreso. O bien es un valor, o tengo el término al
que reducir. Luego por preservación de tipos, aplicar la reducción nos dice
que el nuevo término está bien tipado, y sigue siendo cerrado.</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="unidad_2.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="lambda_calc_extendido.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="unidad_2.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="lambda_calc_extendido.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>
        <script src="theme/pagetoc.js"></script>


    </div>
    </body>
</html>
