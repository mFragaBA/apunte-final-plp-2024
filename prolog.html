<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Prolog - Apunte Final Paradigmas de Lenguajes de Programación 2024</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./custom.css">
        <link rel="stylesheet" href="./mdbook-admonish.css">
        <link rel="stylesheet" href="theme/pagetoc.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="unidad_1.html"><strong aria-hidden="true">1.</strong> Unidad 1 - Programación Funcional Con Haskell</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="programacion_funcional.html"><strong aria-hidden="true">1.1.</strong> Intro a Haskell</a></li><li class="chapter-item expanded "><a href="esquemas_de_recursion.html"><strong aria-hidden="true">1.2.</strong> Esquemas de recursión</a></li></ol></li><li class="chapter-item expanded "><a href="unidad_2.html"><strong aria-hidden="true">2.</strong> Unidad 2 - Cálculo Lambda</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lambda_calc_booleano.html"><strong aria-hidden="true">2.1.</strong> Cálculo Lambda Tipado Booleano</a></li><li class="chapter-item expanded "><a href="lambda_calc_extendido.html"><strong aria-hidden="true">2.2.</strong> Cálculo Lambda Tipado Extendido</a></li><li class="chapter-item expanded "><a href="inferencia_de_tipos.html"><strong aria-hidden="true">2.3.</strong> Inferencia de tipos</a></li><li class="chapter-item expanded "><a href="subtipado.html"><strong aria-hidden="true">2.4.</strong> Subtipado</a></li></ol></li><li class="chapter-item expanded "><a href="unidad_3.html"><strong aria-hidden="true">3.</strong> Unidad 3 - Paradigma de Objetos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="javascript_intro.html"><strong aria-hidden="true">3.1.</strong> Intro a POO</a></li><li class="chapter-item expanded "><a href="sigma_calc.html"><strong aria-hidden="true">3.2.</strong> Cálculo Sigma</a></li></ol></li><li class="chapter-item expanded "><a href="unidad_4.html"><strong aria-hidden="true">4.</strong> Unidad 4 - Programación Lógica</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="prop_solv.html"><strong aria-hidden="true">4.1.</strong> Resolución Proposicional</a></li><li class="chapter-item expanded "><a href="primer_orden_solv.html"><strong aria-hidden="true">4.2.</strong> Resolución en Lógica de primer orden</a></li><li class="chapter-item expanded "><a href="sld_solv.html"><strong aria-hidden="true">4.3.</strong> Resolución SLD</a></li><li class="chapter-item expanded "><a href="prolog.html" class="active"><strong aria-hidden="true">4.4.</strong> Prolog</a></li></ol></li><li class="chapter-item expanded "><a href="practicas.html"><strong aria-hidden="true">5.</strong> Prácticas</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="guia_0.html"><strong aria-hidden="true">5.1.</strong> Guia 0 - Repaso Haskell</a></li><li class="chapter-item expanded "><a href="guia_1.html"><strong aria-hidden="true">5.2.</strong> Guia 1 - Programación funcional</a></li><li class="chapter-item expanded "><a href="guia_2.html"><strong aria-hidden="true">5.3.</strong> Guia 2 - Cálculo Lambda Tipado</a></li><li class="chapter-item expanded "><a href="guia_3.html"><strong aria-hidden="true">5.4.</strong> Guia 3 - Inferencia de Tipos</a></li><li class="chapter-item expanded "><a href="guia_4.html"><strong aria-hidden="true">5.5.</strong> Guia 4 - Subtipado</a></li><li class="chapter-item expanded "><a href="guia_5.html"><strong aria-hidden="true">5.6.</strong> Guia 5 - Programación Orientada a Objetos</a></li><li class="chapter-item expanded "><a href="guia_6.html"><strong aria-hidden="true">5.7.</strong> Guia 6 - Resolución Lógica</a></li><li class="chapter-item expanded "><a href="guia_7.html"><strong aria-hidden="true">5.8.</strong> Guia 7 - Programación Lógica</a></li></ol></li><li class="chapter-item expanded "><a href="bibliografía.html"><strong aria-hidden="true">6.</strong> Bibliografía</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Apunte Final Paradigmas de Lenguajes de Programación 2024</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main><div class="sidetoc"><nav class="pagetoc"></nav></div>
                        <p>$$
\newcommand{\true}{\mathbf{T}}
\newcommand{\false}{\mathbf{F}}
\newcommand{\satisf}{\models}
\newcommand{\notsatisf}{\nvDash}
\newcommand{\set}[1]{\lbrace #1 \rbrace}
\newcommand{\tuple}[1]{&lt; #1 &gt;}
$$</p>
<h1 id="prolog"><a class="header" href="#prolog">Prolog</a></h1>
<p>Prolog usa el mecanismo de <a href="./sld_solv.html">resolución SLD</a> con algunas restricciones más para achicar el espacio de búsqueda:</p>
<ul>
<li>regla de búsqueda (recuerdo: qué cláusulas elegir para la resolvente?): se seleccionan las cláusulas de programa de arriba hacia abajo en el orden en el que son introducidas.</li>
<li>regla de selección (recuerdo: qué literales elimino una vez elegidas las cláusulas?): seleccionar el átomo de más a la izquierda</li>
</ul>
<blockquote>
<p>Nota: la suma de regla de búsqueda y regla de sellección se conoce como
<strong>estrategia</strong>, y cada estrategia te determina un árbol de búsqueda o <strong>árbol
SLD</strong>.</p>
</blockquote>
<h2 id="arbol-sld"><a class="header" href="#arbol-sld">Arbol SLD</a></h2>
<p>Debido a la estrategia usada por prolog, es posible que al elegir una de las
cláusulas de definición no "lleguemos a buen puerto". O sea que llegue a un
punto en donde se "traba" porque no puedo elegir otra cláusula para unificar /
vuelvo a un paso anterior. Ahí es donde la estrategia a usar es la de un
backtracking. Si unifiqué con la cláusula de más arriba y no me anduvo pruebo
con la siguiente.</p>
<p>Esto lo podemos ver entonces con un arbol de backtracking en el que vamos
llegando a hojas en donde falla, y hojas en donde se llega a una refutación
(usamos el camino de la raíz a la hoja).</p>
<p><img src="./img/arbol_sld.png#center" alt="" /></p>
<p>Esto significa que si construyo el árbol SLD obtengo como resultado un conjunto
de instanciaciones/sustituciones que muestran que la fórmula es
insatisfactible. Pero más aún, con cada uno podría construir distintos valores
que satisfacen la fórmula que quiero (recuerdo que yo quiero saber si algo es
satisfactible y pruebo la insatisfactibilidad para su negación).</p>
<p>Notar que el árbol se construye en base a qué cláusula uso para la resolvente,
pero no para cuál elimino (la regla de selección). Ahora, qué cambio variando
la regla de selección? obtengo nuevos árboles. O sea que la regla de búsqueda
me arma el árbol y la regla de selección me arma distintos árboles. Si vemos el
mismo ejemplo de antes, pero ahora eligiendo en la regla de búsqueda el término
de más a la derecha:</p>
<p><img src="./img/arbol_sld_derecha.png#center" alt="" /></p>
<blockquote>
<p>Esto deja en claro cómo la regla de búsqueda impacta en la performance! Si
sigo siempre usando la misma regla de búsqueda en este caso diverge.</p>
</blockquote>
<p>Otra cosa a observar es que si bien en algunos casos puede diverger, el árbol
eventualmente va a generar las mismas soluciones.</p>
<h2 id="programas-lógicos"><a class="header" href="#programas-lógicos">Programas lógicos</a></h2>
<p>Recuerdo que SLD parte de un conjunto de cláusulas \(S = P \cup \set{G}\) donde</p>
<ul>
<li>\(P\) es un conjunto de cláusulas de definición con exactamente un literal positivo</li>
<li>\(G\) es una cláusula negativa llamada el goal.</li>
</ul>
<p>Si nos concentramos un momento en \(P\) podemos ver de qué pinta son las cláusulas:</p>
<p>$$
\begin{align}
V \lor \neg A_1 \lor \dots \lor \neg A_n &amp;\iff \neg(A_1 \land \dots \land A_n) \lor B \\
&amp;\iff (A_1 \land \dots \land A_n) \supset B
\end{align}
$$</p>
<p>Por lo tanto en prolog vamos a definirlos como:</p>
<ul>
<li><code>B :- A_1, ..., A_n.</code> (reglas)</li>
<li><code>B.</code> (hechos)</li>
</ul>
<p>Es decir que los programas de prolog codifican implicaciones.</p>
<p>Luego, si miramos el goal lo que hacemos con prolog es probar alguna propiedad. Por ejemplo "existe V tal que ...". En ese caso lo que terminamos intentando demostrar es que <strong>los programas previamente definidos implican esa propiedad</strong>. Supongamos que la propiedad es un \(\bar{Q} = \exists x_1. \dots \exists x_n. Q\). En ese caso:</p>
<p>$$
\begin{align}
P \implies \bar{Q} \text{ es satisfactible } &amp;\iff \neg(P \implies \bar{Q}) \text{ es insatisfactible } \\
&amp;\iff \neg(\neg P \lor \bar{Q}) \\
&amp;\iff P \land \neg \bar{Q} \\
&amp;\iff P \land Q' \text{ donde } Q' = \forall x_1. \dots \forall x_n. \neg Q \\
\end{align}
$$</p>
<p>Ese \(Q'\) pasa a ser el goal de la resolución SLD y tenemos \(S = P \cup Q'\)</p>
<h3 id="ejemplo-ya-en-notación-prolog"><a class="header" href="#ejemplo-ya-en-notación-prolog">Ejemplo (ya en notación prolog)</a></h3>
<pre><code class="language-prolog">add(U,0,U).
add(X,succ(Y),succ(Z)) :- add(X,Y,Z). % Si X + Y = Z =&gt; X + succ(Y) = succ(Z)
</code></pre>
<p>Ingresamos el goal</p>
<pre><code class="language-prolog">?- add(succ(0), V, succ(succ(0))). % Existe un V tal que 1 + V = 2?
</code></pre>
<p>La respuesta es:</p>
<pre><code class="language-prolog">V = succ(0)
</code></pre>
<p>En prolog te da una solución pero le podés ir pidiendo más, a lo que prolog va a ir generando el árbol SLD hasta que no queden más soluciones.</p>
<h3 id="ejemplo-2"><a class="header" href="#ejemplo-2">Ejemplo 2</a></h3>
<pre><code class="language-prolog">hijo(fred, sally).
hijo(tina, sally).
hijo(sally, john).
hijo(sally, diane).
hijo(sam, bill).
hermanos(A, B) :- hijo(X, A), hijo(X, B), A \= B
</code></pre>
<p>Ingresamos el goal</p>
<pre><code class="language-prolog">?- hermanos(john, X)
</code></pre>
<p>En ese caso la resolución SLD da como resultado la sustitución <code>{ X &lt;- diane }</code></p>
<h3 id="corrección-y-completitud"><a class="header" href="#corrección-y-completitud">Corrección y completitud</a></h3>
<p>El sistema de prolog también es correcto y completo sobre los predicados que
respetan el formato de \(P \cup \set{G}\) (recuerdo: Prolog era una versión
aún más restringida de la resolución SLD antes vista)</p>
<h3 id="búsquedas-de-refutaciones-sld-en-prolog"><a class="header" href="#búsquedas-de-refutaciones-sld-en-prolog">Búsquedas de refutaciones SLD en prolog</a></h3>
<ul>
<li>prolog recorre el árbol SLD en profundidad (dfs)!</li>
<li>eso significa que se puede implementar de forma eficiente
<ul>
<li>usa una pila para los átomos del goal
<ul>
<li>push del resolvente del átomo del tope de la pila con la cláusula de definición</li>
<li>pop cuando el átomo del tope de la pila no unifica con ninguna cláusula</li>
</ul>
</li>
</ul>
</li>
<li>una desventaja clara es que puede no encontrar una refutación SLD aunque exista porque se queda loopeando infinitamente</li>
</ul>
<h2 id="bonus-track"><a class="header" href="#bonus-track">Bonus Track</a></h2>
<p>Prolog ofrece 2 mecanismos extra lógicos que interactúan con la forma que tiene prolog de demostrar cosas.</p>
<ul>
<li><code>Cut</code>, que permite realizar podas al árbol SDL (ya sea para evitar loops infinitos o simplemente evitar caminos innecesarios).</li>
<li>Deducción de información negativa <code>Not</code>, que nos permite poder hablar de negaciones (hasta ahora todo lo que vimos para las cláusulas de los programas es todo positivo, algo es verdadero o algo implica algo).</li>
</ul>
<h3 id="cut"><a class="header" href="#cut"><code>Cut</code></a></h3>
<ul>
<li>Es un predicado 0-ario (notado <code>!</code>), siempre unifica y no necesita de otra cláusula para avanzar. Directamente es consumido.</li>
<li>sólo tiene éxito la primera vez que se invoca</li>
<li>decimos que es extra-lógico porque no se corresponde con un predicado estándar de la lógica
<ul>
<li>considerando que poda el árbol de soluciones, podemos estar perdiendo soluciones. Por ende hay que usar con cuidado.</li>
</ul>
</li>
</ul>
<h4 id="ejemplo-1---usar-para-podar-soluciones"><a class="header" href="#ejemplo-1---usar-para-podar-soluciones">Ejemplo 1 - Usar para podar soluciones</a></h4>
<pre><code class="language-prolog">1. p(a).
2. p(b).
3. p(c).
4. q(a, e).
5. q(a, f).
6. q(b, f).
</code></pre>
<p>Qué pasa si hiciéramos <code>p(x)</code>?</p>
<pre><code class="language-prolog">?- p(x).
x=a; x=b; x=c;
no
</code></pre>
<p>Si hiciéramos <code>p(x), !.</code>?</p>
<pre><code class="language-prolog">?- p(x), !.
x=a;
no
</code></pre>
<blockquote>
<p>por qué? Porque la primera vez que buscamos resolver <code>{ ! }</code> (inicialmente se
unificó <code>p(x)</code> con <code>p(a)</code>), se resuelve ok y se llega a la refutación pero el
resto de las veces falla. Por ende nos quedamos únicamente con la primer
solución.</p>
<p><img src="./img/cut_sld_1.png#center" alt="" /></p>
</blockquote>
<p>Y <code>p(x), q(X,Y).</code>?</p>
<pre><code class="language-prolog">?- p(x), q(x, y).
x=a, y=e;
x=a, y=f;
x=b, y=f;
no
</code></pre>
<p><code>p(x), !, q(X,Y).</code>?</p>
<pre><code class="language-prolog">?- p(x), !, q(x, y).
x=a, y=e;
x=a, y=f;
no
</code></pre>
<blockquote>
<p>en este caso, se unifica <code>p(x)</code> y le sigue el cut. Eso medio que tiene como
resultado que el x quede fijo, y sólo se desarrolla el subárbol SLD con <code>x = a</code></p>
<p><img src="./img/cut_sld_2.png#center" alt="" /></p>
</blockquote>
<p>TODO: Ver este ejemplo</p>
<pre><code class="language-prolog">
1. p(a).
2. p(b).
3. p(c).
4. q(a, e).
5. q(a, f).
6. q(b, f).
7. r(x, y) :- p(x), !, q(x, y).
</code></pre>
<h3 id="ejemplo-2---usar-a-modo-de-optimización"><a class="header" href="#ejemplo-2---usar-a-modo-de-optimización">Ejemplo 2 - usar a modo de optimización</a></h3>
<p>Veamos la siguiente definición de <code>max</code>:</p>
<pre><code class="language-prolog">max1(X, Y, Y) :- X =&lt; Y.
max1(X, Y, X) :- X &gt; Y.
</code></pre>
<p>Es ineficiente, pero por qué?</p>
<h3 id="cut---generalidades"><a class="header" href="#cut---generalidades">Cut - Generalidades</a></h3>
<ul>
<li>Cuando se selecciona un cut, tiene éxito inmediatamente</li>
<li>Si, debido a backtracking, se vuelve a ese cut, su efecto es el de hacer fallar el goal que le dio origen</li>
<li>El efecto resultante es descartar soluciones de:
<ul>
<li>otras cláusulas del goal padre</li>
<li>cualquier goal que ocurre a la izquierda del corte en la cláusula que contiene el corte</li>
<li>todos los objetivos intermedios que se ejecutaron durante la ejecución de los goals precedentes</li>
</ul>
</li>
</ul>
<h3 id="negación-por-falla"><a class="header" href="#negación-por-falla">Negación por falla</a></h3>
<p>Motivación: En el programa \(P\), puedo escribir hechos o reglas (que son implicaciones). Pero no tengo forma de escribir la negación para decir que algo no ocurre.</p>
<ul>
<li>Se dice que un árbol SLD falla finitamente si es finito y no tiene ramas de éxito</li>
<li>Dado un programa \(P\) el conjunto de falla finita de P son los átomos cerrados tales que si armo el árbol SLD usando el átomo como raíz no tengo ramas de éxito.
<ul>
<li>todos esos átomos cerrados implican la negación del átomo</li>
</ul>
</li>
</ul>
<p>Esto nos habilita una forma nueva de razonar que en prolog se implementa con el predicado not:</p>
<pre><code class="language-prolog">not(G) :- call(G), !, fail.
not(G).
</code></pre>
<p>Esto lo que dice es:</p>
<ul>
<li>Si unificás con la primer regla
<ul>
<li>primero intentá evaluar <code>G</code>.</li>
<li>en caso de poder resolverlo, hacés un cut e inmediatamente después fallás.</li>
<li>como agregaste el cut, eso ya te corta todas las otras posibilidades de backtracking.</li>
</ul>
</li>
<li>Si unificás con la otra regla automáticamente vale eso
<ul>
<li>per sólo voy a unificar con la segunda regla si no pude hacer válido el <code>G</code> (porque si no el <code>!</code> me cortaba cualquier otro chequeo)</li>
</ul>
</li>
</ul>
<div id="admonition-ejemplo" class="admonition admonish-example">
<div class="admonition-title">
<p>Ejemplo</p>
<p><a class="admonition-anchor-link" href="#admonition-ejemplo"></a></p>
</div>
<div>
<p>Puedo deducir <code>not(student(mary))</code> a partir de</p>
<pre><code class="language-prolog">student(joe).
student(bill).
student(jim).
teacher(mary).
</code></pre>
</div>
</div>
<h4 id="negación-por-falla-no-es-negación-lógica"><a class="header" href="#negación-por-falla-no-es-negación-lógica">Negación por falla <strong>no</strong> es negación lógica</a></h4>
<p>Veamos este ejemplo:</p>
<pre><code class="language-prolog">animal(perro).
animal(gato).
vegetal(X) :- not(animal(X)).
</code></pre>
<ul>
<li>La consulta <code>vegetal(perro)</code> da false, como es esperado</li>
<li>La consulta <code>vegetal(pasto)</code> da si, como es esperado</li>
<li>Qué devuelve la consulta <code>vegetal(X)</code>? Devuelve <code>false</code>
<ul>
<li>Nos gustaría que nos devuelva por ejemplo <code>lechuga</code>, pero no hay
definido. El problema es que si recordamos, necesitamos el término
cerrado de la negación por falla. Al hacer <code>vegetal(X)</code> permitimos que se
instancie con cualquier valor.</li>
</ul>
</li>
<li>Qué pasa con <code>not(not(animal(X)))</code>? <code>true</code></li>
</ul>
<p>TLDR: Estos predicados que usan el <code>not</code> de la negación por falla requieren que esté instanciado lo que yo quiero negar.</p>
<p>Otro ejemplo:</p>
<pre><code class="language-prolog">firefighter_candidate(X) :- not ( pyromaniac(X) ), punctual(X).
pyromaniac(attila).
punctual(jeanne_d_arc).
</code></pre>
<p>Qué devuelve <code>firefighter_candidate(W)</code>?</p>
<p>De vuelta tengo el problema de llamar al not con algo que no está instanciado! Me da <code>false</code>!</p>
<p>Y si lo doy vuelta?</p>
<pre><code class="language-prolog">firefighter_candidate(X) :- punctual(X), not ( pyromaniac(X) ).
pyromaniac(attila).
punctual(jeanne_d_arc).
</code></pre>
<p>Ahora el <code>punctual(X)</code> me instancia primero el <code>X</code> y después se resuelve de la forma esperada devolviendo <code>X = jeanne_d_arc</code></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="sld_solv.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="practicas.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="sld_solv.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="practicas.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>
        <script src="theme/pagetoc.js"></script>


    </div>
    </body>
</html>
