<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Apunte Final Paradigmas de Lenguajes de Programaci贸n 2024</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./custom.css">
        <link rel="stylesheet" href="./mdbook-admonish.css">
        <link rel="stylesheet" href="theme/pagetoc.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="unidad_1.html"><strong aria-hidden="true">1.</strong> Unidad 1 - Programaci贸n Funcional Con Haskell</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="programacion_funcional.html"><strong aria-hidden="true">1.1.</strong> Intro a Haskell</a></li><li class="chapter-item expanded "><a href="esquemas_de_recursion.html"><strong aria-hidden="true">1.2.</strong> Esquemas de recursi贸n</a></li></ol></li><li class="chapter-item expanded "><a href="unidad_2.html"><strong aria-hidden="true">2.</strong> Unidad 2 - C谩lculo Lambda</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lambda_calc_booleano.html"><strong aria-hidden="true">2.1.</strong> C谩lculo Lambda Tipado Booleano</a></li><li class="chapter-item expanded "><a href="lambda_calc_extendido.html"><strong aria-hidden="true">2.2.</strong> C谩lculo Lambda Tipado Extendido</a></li><li class="chapter-item expanded "><a href="inferencia_de_tipos.html"><strong aria-hidden="true">2.3.</strong> Inferencia de tipos</a></li><li class="chapter-item expanded "><a href="subtipado.html"><strong aria-hidden="true">2.4.</strong> Subtipado</a></li></ol></li><li class="chapter-item expanded "><a href="unidad_3.html"><strong aria-hidden="true">3.</strong> Unidad 3 - Paradigma de Objetos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="javascript_intro.html"><strong aria-hidden="true">3.1.</strong> Intro a Javascript</a></li><li class="chapter-item expanded "><a href="sigma_calc.html"><strong aria-hidden="true">3.2.</strong> C谩lculo Sigma</a></li></ol></li><li class="chapter-item expanded "><a href="unidad_4.html"><strong aria-hidden="true">4.</strong> Unidad 4 - Programaci贸n L贸gica</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="prop_solv.html"><strong aria-hidden="true">4.1.</strong> Resoluci贸n Proposicional</a></li><li class="chapter-item expanded "><a href="primer_orden_solv.html"><strong aria-hidden="true">4.2.</strong> Resoluci贸n en l贸gica de primer orden</a></li><li class="chapter-item expanded "><a href="sld_solv.html"><strong aria-hidden="true">4.3.</strong> Resoluci贸n SLD</a></li><li class="chapter-item expanded "><a href="prolog.html"><strong aria-hidden="true">4.4.</strong> Prolog</a></li></ol></li><li class="chapter-item expanded "><a href="practicas.html"><strong aria-hidden="true">5.</strong> Pr谩cticas</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="guia_0.html"><strong aria-hidden="true">5.1.</strong> Guia 0 - Repaso Haskell</a></li><li class="chapter-item expanded "><a href="guia_1.html"><strong aria-hidden="true">5.2.</strong> Guia 1 - Programaci贸n funcional</a></li><li class="chapter-item expanded "><a href="guia_2.html"><strong aria-hidden="true">5.3.</strong> Guia 2 - C谩lculo Lambda Tipado</a></li><li class="chapter-item expanded "><a href="guia_3.html"><strong aria-hidden="true">5.4.</strong> Guia 3 - Inferencia de Tipos</a></li><li class="chapter-item expanded "><a href="guia_4.html"><strong aria-hidden="true">5.5.</strong> Guia 4 - Subtipado</a></li><li class="chapter-item expanded "><a href="guia_5.html"><strong aria-hidden="true">5.6.</strong> Guia 5 - Programaci贸n Orientada a Objetos</a></li><li class="chapter-item expanded "><a href="guia_6.html"><strong aria-hidden="true">5.7.</strong> Guia 6 - Resoluci贸n L贸gica</a></li><li class="chapter-item expanded "><a href="guia_7.html"><strong aria-hidden="true">5.8.</strong> Guia 7 - Programaci贸n L贸gica</a></li></ol></li><li class="chapter-item expanded "><a href="bibliograf铆a.html"><strong aria-hidden="true">6.</strong> Bibliograf铆a</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Apunte Final Paradigmas de Lenguajes de Programaci贸n 2024</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main><div class="sidetoc"><nav class="pagetoc"></nav></div>
                        <h1 id="unidad-1---paradigma-funcional"><a class="header" href="#unidad-1---paradigma-funcional">Unidad 1 - Paradigma funcional</a></h1>
<p><img src="./img/hold_up.png" alt="" /></p>
<p>La materia se llama "Paradigmas de Programaci贸n. Qu茅 es un paradigma de programaci贸n:</p>
<ul>
<li><strong>paradigma</strong>: es una forma de pensamiento (a.k.a un marco te贸rico, un
conjunto de creencias).</li>
<li><strong>lenguaje de programaci贸n</strong>: el lenguaje que usamos para comunicar
instrucciones a una computadora.
<ul>
<li>describen <strong>c贸mputos</strong> (m谩s de a qu茅 me refiero con esto adelante)</li>
<li>es <strong>turing completo</strong> si puede expresar todas las funciones computables
(LyC war flashbacks). Los DSLs son ejemplos de lenguajes de programaci贸n
que no necesariamente son turing completos.</li>
<li>tiene que poder describir lo que hay que hacer de forma expl铆cita y no
ambigua.</li>
</ul>
</li>
<li>Entonces un <strong>paradigma de lenguaje de programaci贸n</strong> lo vamos a entender
como un estilo de programaci贸n, que impacta en la forma en la que se encaran
las soluciones
<ul>
<li>Est谩 muuuuuy vinculado al <strong>modelo de c贸mputo</strong>
<ul>
<li>A partir de un estado inicial llegar a un estado final.</li>
<li>En orga, por ejemplo parto de un estado inicial <strong>y aplico secuencias
de instrucciones para modificar el estado</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Entender de paradigmas de programaci贸n es una herramienta muy 煤til a la hora de
decidir qu茅 lenguaje elijo para resulver un problema.</p>
<p>En este resumen (y porque es lo visto en clase) voy a hablar de los paradigmas:</p>
<ul>
<li>imperativo</li>
<li>funcional (vamos a usar haskell)</li>
<li>orientado a objetos (javascript)</li>
<li>l贸gico (vamos a usar prolog)</li>
</ul>
<p>Pero sepan que exiten m谩s: concurrente, eventos, basado en continuaciones,
probabil铆stico, cu谩ntico. Adem谩s, hoy en d铆a los lenguajes m谩s modernos suelen
tomar features de distintos paradigmas (por ejemplo: rust . Otro ejemplo es
la incorporaci贸n de funciones an贸nimas en los distintos lenguajes, que antes
estaba medio reservado a los lenguajes funcionales) entonces la linea entre un
paradigma y otro dentro de un lenguaje se vuelve m谩s difusa.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="programaci贸n-funcional"><a class="header" href="#programaci贸n-funcional">Programaci贸n Funcional</a></h1>
<p>Si bien vamos a ver todo con lenguaje "haskelloso", la mayor铆a de conceptos
aplican a los lenguajes funcionales en general. Vamos a ver m谩s formal el
modelo de c贸mputo de lenguajes funcionales cuando veamos c谩lculo lambda.</p>
<ul>
<li>
<p>Programar: Definir funciones</p>
</li>
<li>
<p>Ejecutar: Evaluar expresiones</p>
<pre><code># Programando
factorial(1) = 1
factorial(n) = factorial(n - 1) * n


# Evaluando
factorial(4) =&gt; factorial(3) * 4 
             =&gt; factorial(2) * 3 * 4 
             =&gt; factorial(1) * 2 * 3 * 4
             =&gt; 1 * 2 * 3 * 4
             =&gt; 6 * 4
             =&gt; 24
</code></pre>
</li>
<li>
<p>Un programa es un conjunto de ecuaciones</p>
</li>
<li>
<p>Expresiones</p>
<ul>
<li>Si se puede definir, toda expresi贸n denota un valor</li>
<li>El valor depende 煤nicamente del valor de sus subexpresiones</li>
<li>Evaluar/Reducir una expresi贸n es obtener su valor (en el ejemplo <code>factorial(4) ~&gt; 24</code>)</li>
<li>No toda expresi贸n denota un valor (si no puedo reducir no tengo un valor)</li>
</ul>
</li>
<li>
<p>Valores</p>
<ul>
<li>Los podemos pensar como expresiones que no se pueden seguir reduciendo</li>
</ul>
</li>
</ul>
<h2 id="tipos"><a class="header" href="#tipos">Tipos</a></h2>
<p>En Haskell organizamos los valores en <strong>tipos</strong>. El tipo tiene operaciones asociadas. En haskell se tienen:</p>
<ul>
<li>tipos b谩sicos: <code>Int</code>, <code>Char</code>, <code>Float</code>, <code>Bool</code></li>
<li>tipos compuestos:
<ul>
<li>Listas: <code>[Int]</code></li>
<li>Tuplas: <code>(Int, Bool)</code></li>
<li>Funciones: <code>Int -&gt; Int</code></li>
</ul>
</li>
<li><strong>todo expresi贸n bien formada tiene un tipo asociado</strong> (esto tambi茅n, m谩s
adelante vamos a ver que si no se le puede otorgar tipo a una expresi贸n
entonces no se va a poder reducir) y el tipo depende del tipo de sus
subexpresiones.</li>
</ul>
<h2 id="funciones"><a class="header" href="#funciones">Funciones</a></h2>
<div id="admonition-definici贸n" class="admonition admonish-note">
<div class="admonition-title">
<p>Definici贸n</p>
<p><a class="admonition-anchor-link" href="programacion_funcional.html#admonition-definici贸n"></a></p>
</div>
<div>
<ul>
<li>
<p>Definici贸n con ecuaci贸n orientada:</p>
<pre><code class="language-haskell">doble :: Int -&gt; Int
doble x = x + x
</code></pre>
</li>
<li>
<p>Definici贸n con guardas:</p>
<pre><code class="language-haskell">signo :: Int -&gt; Bool
signo n | n &gt;= 0    = True
        | otherwise = False
</code></pre>
</li>
<li>
<p>Definiciones locales:</p>
<pre><code class="language-haskell">f(x, y) = g x + y
        where g z = z + 2
</code></pre>
</li>
<li>
<p>Expresiones Lambda:</p>
<pre><code class="language-haskell">-- con un par谩metro
\x -&gt; x + 1
-- con muchos par谩metros
\x -&gt; \y -&gt; x + y
-- escritura m谩s simple, separo par谩metros con espacios
\x y -&gt; x + y
</code></pre>
</li>
</ul>
</div>
</div>
<h2 id="polimorfismo-param茅trico"><a class="header" href="#polimorfismo-param茅trico">Polimorfismo param茅trico</a></h2>
<p>Dada la siguiente funci贸n <code>id</code>, cu谩l es su tipo?</p>
<pre><code class="language-haskell">id x = x
</code></pre>
<p>Rta: <code>id :: a -&gt; a</code>, donde <code>a</code> es una variable de tipo (es algo as铆 como un meta-tipo)</p>
<h2 id="clases-de-tipos"><a class="header" href="#clases-de-tipos">Clases de Tipos</a></h2>
<p>Cu谩l es el tipo de <code>m谩ximo</code>?</p>
<pre><code class="language-haskell">maximo x y | x &gt; y      = x
maximo _ y              = y
</code></pre>
<p>Puedo probar de evaluar a <code>m谩ximo</code>:</p>
<pre><code class="language-bash"># La eval煤o con enteros y funciona
&gt; maximo 1 2
2
# La eval煤o con decimales y tambi茅n funciona
&gt; maximo 1.2 3.4
3.4
</code></pre>
<p>Una <strong>clase</strong> es una suerte de interface que define un conjunto de operaciones. Por ejemplo:</p>
<ul>
<li><code>Eq</code>: <code>(==)</code>, <code>(/=)</code></li>
<li><code>Ord</code>: <code>(&lt;)</code>, <code>(&lt;=)</code>, <code>(&gt;=)</code>, <code>(&gt;)</code>, <code>max</code>, <code>min</code>, <code>compare</code></li>
</ul>
<p>pVolviendo a <code>maximo</code>, tenemos que <code>maximo :: Ord a =&gt; a -&gt; a -&gt; a</code>. O sea que
en m谩ximo puedo recibir cualquier tipo en tanto pertenezca a la clase <code>Ord</code>
(cosa de tener el comparador)</p>
<h2 id="instancia-de-una-clase-de-tipos"><a class="header" href="#instancia-de-una-clase-de-tipos">Instancia de una clase de tipos</a></h2>
<p>Notar que haskell permite usar el <code>deriving</code> que deriva autom谩ticamente una
"implementaci贸n por default" de todas las funciones de <code>Eq</code>. En el caso de <code>Eq</code>
compara cada caso, si es <code>Circulo</code> compara el valor, y si es <code>Rectangulo</code>
compara ambos valores.</p>
<pre><code class="language-haskell">data Figura = Circulo Float | Rectangulo Float Float
deriving Eq
</code></pre>
<p>Pero tambi茅n se pueden definir instancias con la l贸gica que quiera:</p>
<pre><code class="language-haskell">instance Ord Figura where
    (&lt;=) = \x -&gt; \y -&gt; area x &lt;= area y
</code></pre>
<h2 id="alto-orden"><a class="header" href="#alto-orden">Alto Orden</a></h2>
<p>En haskell, las funciones son lo que se conoce como first-class citizens, eso
significa que las funciones <strong>son un valor m谩s</strong>. O sea que pod茅s pasarlas como
par谩metro, pueden ser el resultado de una funci贸n.</p>
<p>Por ejemplo, a <code>id</code> le puedo pasar <code>id</code>. Entonces, cu谩l ser铆a el tipo de <code>id id</code>?</p>
<p>El tipo es <code>(id id) :: a -&gt; a</code></p>
<h2 id="currificaci贸n"><a class="header" href="#currificaci贸n">Currificaci贸n</a></h2>
<p>Ve谩moslo con 2 ejemplos:</p>
<pre><code class="language-haskell">suma :: ??
suma x y = x + y

suma' :: ??
suma' (x, y) = x + y
</code></pre>
<p>Si reviso los tipos obtengo que:</p>
<pre><code class="language-haskell">suma :: Int -&gt; Int -&gt; Int
suma' :: (Int, Int) -&gt; Int
</code></pre>
<p>Cu谩l es la diferencia? Que la primera implementaci贸n puedo hacer por ejemplo
<code>suma 5</code> y obtengo una funci贸n que incrementa en 5. Eso no lo puedo hacer con
<code>suma'</code>. Esta feature de poder evaluar parcialmente las funciones es lo que se
conoce como <strong>currificaci贸n</strong>.</p>
<p><img src="./img/currification.png#center" alt="" /></p>
<p>(No, ese Curry no...)</p>
<p>Veamos c贸mo se ve esto en ghci:</p>
<pre><code>&gt; :type suma
suma :: Int -&gt; Int -&gt; Int
&gt; :type suma 4
(suma 4) :: Int -&gt; Int
</code></pre>
<p>O sea que puedo definir por ejemplo <code>inc = suma 1</code></p>
<h3 id="viendo-curryuncurry-como-una-funci贸n"><a class="header" href="#viendo-curryuncurry-como-una-funci贸n">Viendo curry/uncurry como una funci贸n</a></h3>
<pre><code class="language-haskell">curry :: ((a, b) -&gt; c) -&gt; (a -&gt; (b -&gt; c))
curry f = \x -&gt; \y -&gt; f (x,y)
-- versi贸n alternativa --
curry f x = \y -&gt; f (x, y)

uncurry :: (a -&gt; b -&gt; c) -&gt; ((a, b) -&gt; c)
uncurry f (a, b) = f x y
</code></pre>
<h2 id="tipos-algebr谩icos"><a class="header" href="#tipos-algebr谩icos">Tipos Algebr谩icos</a></h2>
<p>Puedo definir los tipos por enumeraci贸n definiendo:</p>
<ul>
<li>el nombre del tipo</li>
<li>los constructores</li>
</ul>
<pre><code class="language-haskell">data Dia = Lunes | Martes | Miercoles | Jueves | Viernes | Sabado | Domingo

data Bool = True | False
</code></pre>
<p>Los constructores tambi茅n pueden tener par谩metros. En la definici贸n tengo que aclarar los tipos de sus argumentos:</p>
<pre><code class="language-haskell">data Figura = Circulo Float | Rectangulo Float Float
</code></pre>
<p>Algunos ejemplos de tipos:</p>
<ul>
<li><code>Lunes :: Dia</code></li>
<li><code>Circulo 1.0 :: Figura</code></li>
<li><code>Circulo :: Float -&gt; Figura</code></li>
</ul>
<h2 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern matching</a></h2>
<p>Es un mecanismo para comparar un valor con un patr贸n y deconstruir un valor en
sus partes. Por ejemplo:</p>
<pre><code class="language-haskell">area :: Figura -&gt; Float
area (Circulo radio) = PI * radio^2 
area (Rectangulo base altura) = base * altura
</code></pre>
<p>Si no hay un match directo, lo que va a hacer haskell es seguir reduciendo.
Eventualmente va a matchear o no se va a poder reducir la expresi贸n (y vamos a
tener un error).</p>
<div id="admonition-el-patr贸n-debe-ser-lineal" class="admonition admonish-info">
<div class="admonition-title">
<p>El patr贸n debe ser lineal</p>
<p><a class="admonition-anchor-link" href="programacion_funcional.html#admonition-el-patr贸n-debe-ser-lineal"></a></p>
</div>
<div>
<ul>
<li>
<p><strong>Lineal</strong> quiere decir que una variable debe aparecer una 煤nica vez a la izquierda.</p>
<pre><code class="language-haskell">esCuadrado :: Figura -&gt; Bool
esCuadrado (Circulo _) = False
esCuadrado (Rectangulo x y) | x == y =&gt;     = True
                            | otherwise     = False
-- alternativa
esCuadrado (Rectangulo x y) | x == y =&gt;     = True
esCuadrado _                                = False

-- alternativa tambi茅n valida
esCuadrado (Rectangulo x y) = x == y
esCuadrado _                = False
</code></pre>
</li>
<li>
<p><code>esCuadrado (Rectangulo x x)</code> ser铆a m谩s simple pero no est谩 permitido en
haskell (ej: en erlang/elixir esto es posible)</p>
</li>
</ul>
<p>Observaciones:</p>
<ul>
<li>
<p><code>_</code> coincide con cualquier forma (ver que en la alternativa agarro tanto el caso de <code>Circulo</code> como el de <code>Rectangulo</code> que no es cuadrado)</p>
</li>
<li>
<p>los casos se eval煤an en el orden que est谩n escritos</p>
</li>
<li>
<p>Puedo definir funciones parciales:</p>
<pre><code class="language-haskell">-- en este caso radio (Rectangulo _ _) va a dar error
radio (Circulo radio) = radio
</code></pre>
</li>
</ul>
</div>
</div>
<h2 id="tipos-recursivos"><a class="header" href="#tipos-recursivos">Tipos Recursivos</a></h2>
<p>La definici贸n de un tipo tpuede tener uno o m谩s par谩metros de tipo:</p>
<pre><code class="language-haskell">data Natural = Zero | Succ Natural

Zero :: Natural
Succ Zero :: Natural
Succ (Succ (Succ Zero)) :: Natural
</code></pre>
<h2 id="listas"><a class="header" href="#listas">Listas</a></h2>
<p>Es un tipo algebr谩ico param茅trico y recursivo con 2 constructores:</p>
<pre><code class="language-haskell">[] :: [a]               -- Constructor de la lista vac铆a
(:) :: a -&gt; [a] -&gt; [a]  -- Append Front
</code></pre>
<p>Ejemplos de pattern matching:</p>
<pre><code class="language-haskell">esVacia :: [a] -&gt; Bool
esVacia [] = True
esVacia _ = False
</code></pre>
<pre><code class="language-haskell">longitud :: [a] -&gt; Int
longitud [] = 0
longitud (x:xs) _ = 1 + longitud xs
</code></pre>
<h2 id="no-terminaci贸n-y-orden-de-evaluaci贸n"><a class="header" href="#no-terminaci贸n-y-orden-de-evaluaci贸n">No terminaci贸n y orden de evaluaci贸n</a></h2>
<p>Veamos la siguiente funci贸n:</p>
<pre><code class="language-haskell">inf1 :: [Int]
inf1 = 1 : inf1
</code></pre>
<p>Se reduce infinitamente, entonces para qu茅 quiero tener algo as铆? De qu茅 me sirve? Veamos esta funci贸n:</p>
<pre><code class="language-haskell">const :: a -&gt; b -&gt; a
const x y = x
</code></pre>
<p>Qu茅 pasa si hago <code>const 42 inf1</code>? Da 42. Pero en realidad depende del mecanismo
de reducci贸n que tenga el lenguaje, porque haskell resuelve primero el pattern
matching en lugar de reducir los par谩metros. Si no me quedaba reduciendo
infinitamente.</p>
<h3 id="evaluaci贸n-lazy-orden-normal"><a class="header" href="#evaluaci贸n-lazy-orden-normal">Evaluaci贸n Lazy (Orden Normal)</a></h3>
<ul>
<li>Tiene que ver con el modelo de c贸mputo que usa haskell, que es el de la
<code>Reducci贸n</code>
<ul>
<li>Se reemplaza un redex (expresi贸n reducible) por otra usando las
ecuaciones orientadas. Un redex es una sub-expresi贸n que no est茅 en forma
normal.</li>
<li>El redex tiene que ser una instancia del lado izquiero de alguna de las
ecuaciones (si no da error), y se reemplaza por el lado derecho asociando
las variables correspondientes.</li>
<li>El resto de la expresi贸n no cambia</li>
</ul>
</li>
<li>La evaluaci贸n Lazy, consiste en seleccionar las funciones m谩s externas y
luego los argumentos (pero s贸lo si se necesitan)</li>
</ul>
<h2 id="ejercicios"><a class="header" href="#ejercicios">Ejercicios</a></h2>
<h3 id="ejercicio-1"><a class="header" href="#ejercicio-1">Ejercicio 1</a></h3>
<p>Definir <code>dobleL :: [Float] -&gt; Float</code> tal que <code>doble xs</code> es la lista que contiene el doble de cada elemento en xs</p>
<pre><code class="language-haskell">doble [] = []
doble x:xs = (x * 2) : (doble xs)
</code></pre>
<h3 id="ejercicio-2"><a class="header" href="#ejercicio-2">Ejercicio 2</a></h3>
<p>Definir <code>esPar :: [Int] -&gt; [Bool]</code> tal que <code>esParL xs</code> indica si el correspondiente elemento en xs es par o no</p>
<pre><code class="language-haskell">esPar [] = []
esPar x:xs = (even x) : (esPar xs)
</code></pre>
<h3 id="ejercicio-3"><a class="header" href="#ejercicio-3">Ejercicio 3</a></h3>
<p>Definir <code>longL :: [[a]] -&gt; [Int]</code> tal que <code>longL xs</code> es la lista que contiene las longitudes de las listas en xs</p>
<pre><code class="language-haskell">longL [] = []
longL x:xs = (length x) : (longL xs)
</code></pre>
<div id="admonition-generalizando" class="admonition admonish-note">
<div class="admonition-title">
<p>Generalizando...</p>
<p><a class="admonition-anchor-link" href="programacion_funcional.html#admonition-generalizando"></a></p>
</div>
<div>
<ul>
<li>
<p>Notar que en los ejercicios el patr贸n era siempre el mismo con la diferencia de que en el primero hac铆amos <code>* 2</code>, en el segundo <code>even x</code> y en el tercero <code>length x</code></p>
</li>
<li>
<p>Podemos generalizar este comportamiento (gracias funciones de alto orden!) en la siguiente funci贸n:</p>
<pre><code class="language-haskell">map :: (a -&gt; b) -&gt; [a] -&gt; [b]
map _ [] = []
map f x:xs = (f x) : (map f xs)
</code></pre>
</li>
<li>
<p>Podemos redefinir las funciones de antes con <code>map</code>:</p>
<pre><code class="language-haskell">-- Ni tengo que agregar el par谩metro a la definici贸n!
doble = map (\x -&gt; 2 * x)
esPar = map even
longL = map length
</code></pre>
</li>
</ul>
</div>
</div>
<h3 id="ejercicio-4"><a class="header" href="#ejercicio-4">Ejercicio 4</a></h3>
<p>Definir <code>negativos :: [Float] -&gt; [Float]</code> tal que <code>negativos xs</code> contiene los elementos negativos de xs</p>
<pre><code class="language-haskell">negativos [] = []
negativos x:xs  | x &lt; 0     = x : (negativos xs)
                | otherwise = negativos xs
</code></pre>
<h3 id="ejercicio-5"><a class="header" href="#ejercicio-5">Ejercicio 5</a></h3>
<p>Definir <code>noVacias :: [[a]] -&gt; [[a]]</code> tal que <code>noVacias xs</code> contiene las listas no vac铆as de <code>xs</code></p>
<pre><code class="language-haskell">noVacias [] = []
noVacias x:xs   | length x &gt; 0     = x : (noVacias xs)
                | otherwise = noVacias xs
</code></pre>
<div id="admonition-generalizando-1" class="admonition admonish-note">
<div class="admonition-title">
<p>Generalizando...</p>
<p><a class="admonition-anchor-link" href="programacion_funcional.html#admonition-generalizando-1"></a></p>
</div>
<div>
<ul>
<li>
<p>Notar que en los ejercicios el patr贸n era siempre el mismo: el caso base
devuelve vac铆o, y para el otro chequeo una condici贸n booleana para saber si
agregar o no.</p>
</li>
<li>
<p>Podemos generalizar este comportamiento (gracias funciones de alto orden again!) en
la siguiente funci贸n:</p>
<pre><code class="language-haskell">filter :: (a -&gt; Bool) -&gt; [a] -&gt; [b]
filter _ [] = []
filter f x:xs   | (f x)     = x : (filter f xs)
                | otherwise = filter f xs
</code></pre>
</li>
<li>
<p>Podemos redefinir las funciones de antes con <code>filter</code>:</p>
<pre><code class="language-haskell">-- Ni tengo que agregar el par谩metro a la definici贸n!
negativos = filter (\x -&gt; x &lt; 0)
noVacias = filter (\x -&gt; length x &gt; 0)
</code></pre>
</li>
</ul>
</div>
</div>
<h2 id="transparencia-referencial"><a class="header" href="#transparencia-referencial">Transparencia referencial</a></h2>
<p>Una propiedad de haskell (y otros lenguajes funcionales) es la de la
<strong>transparencia referencial</strong>. Esto qu茅 significa? Que el resultado de evaluar
una expresi贸n s贸lo depende de sus subexpresiones. Eso tiene la implicancia de
que si yo tengo 2 veces la misma subexpresi贸n ambas van a evaluar al mismo
valor.</p>
<p>Un ejemplo para ver qu茅 no tiene transparencia referencial es en un lenguaje imperativo como C puedo hacer:</p>
<pre><code class="language-c">algunaFuncion(x++, x++);
</code></pre>
<p>Estoy llamando a <code>algunaFuncion</code> y los par谩metros son ambos <code>x++</code> pero no van a
tener el mismo valor.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="esquemas-de-recursi贸n"><a class="header" href="#esquemas-de-recursi贸n">Esquemas de recursi贸n</a></h1>
<h2 id="esquemas-de-recursi贸n-sobre-listas"><a class="header" href="#esquemas-de-recursi贸n-sobre-listas">Esquemas de recursi贸n sobre listas</a></h2>
<h3 id="recursi贸n-estructural"><a class="header" href="#recursi贸n-estructural">Recursi贸n estructural</a></h3>
<p>Pensemos un par de funciones sobre listas:</p>
<ul>
<li>
<p><code>sumaL</code>: la suma de todos los valores de una lista de enteros</p>
<pre><code class="language-haskell">-- alguna def con tipos
sumaL [] = 0
sumaL (x:xs) = x + sumaL(xs)
</code></pre>
</li>
<li>
<p><code>concat</code>: la concatenaci贸n de todos los elementos de una lista de listas</p>
<pre><code class="language-haskell">-- alguna def con tipos
concat [] = []
concat (x:xs) = x ++ concat xs
</code></pre>
</li>
<li>
<p><code>reverso</code>: el reverso de una lista</p>
<pre><code class="language-haskell">reverso [] = []
reverso (x:xs) = reverso xs ++ [x]
</code></pre>
</li>
</ul>
<div id="admonition-generalizando" class="admonition admonish-info">
<div class="admonition-title">
<p>Generalizando...</p>
<p><a class="admonition-anchor-link" href="esquemas_de_recursion.html#admonition-generalizando"></a></p>
</div>
<div>
<p><strong>El approach es siempre el mismo</strong>. Asumo que se calcular el resultado para el
caso m谩s chico y hago alguna operaci贸n para combinar todo, y el resultado puede
ser otra cosa distinta, no necesariamente una lista. Sumado a eso tenemos un
caso base distinguido.</p>
<pre><code class="language-haskell">g :: [a] -&gt; b
-- caso base distinguido
g [] = z
g (x:xs) = f x (g xs)
</code></pre>
<p>Generalizando, obtenemos el fold:</p>
<p><img src="./img/foldr_scheme.png#center" alt="" /></p>
<pre><code class="language-haskell">-- recibimos una funci贸n, un elemento para el caso base y una lista
-- la funci贸n recibe un elemnto de la lista, y lo otro de tipo b es el resultado parcial
foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b
foldr _ z [] = z
foldr f z (x:xs) = f x (foldr f z xs)
</code></pre>
</div>
</div>
<h4 id="algunos-ejemplos-con-foldr"><a class="header" href="#algunos-ejemplos-con-foldr">Algunos ejemplos con <code>foldr</code></a></h4>
<p>Podemos repensar las funciones de antes usando <code>foldr</code>:</p>
<pre><code class="language-haskell">-- a = b = Int =&gt; (+) :: Int -&gt; Int -&gt; Int === a -&gt; b -&gt; b
sumaL = foldr (+) 0
-- a = b = [a'] =&gt; (++) :: [a'] -&gt; [a'] -&gt; [a'] === a -&gt; b -&gt; b
concat = foldr (++) []
-- a = a', b = [a'] =&gt; (:) :: a' -&gt; [a'] -&gt; [a'] === a -&gt; b -&gt; b
-- flip toma una funci贸n de 2 par谩metros y les invierte el orden
-- al componerlo con (:[]) lo que hace es al primer par谩metro (a')
-- lo mete en la lista vac铆a. Luego se pasa a flip (++) que va a 
-- hacer el ++ usando el primer par谩metro como segundo
reverso = foldr ((flip (++)) . (:[])) []
-- alternativa m谩s legible en mi opini贸n
reverso = foldr (\elem -&gt; \partial -&gt; partial ++ [elem]) []
</code></pre>
<p>Y tambi茅n podemos reimplementar <code>map</code> y <code>filter</code> usando <code>foldr</code>:</p>
<pre><code class="language-haskell">map f = foldr (\elem -&gt; \partial -&gt; (f elem):partial) []
-- alternativa: (:) es una funci贸n a -&gt; [a] -&gt; [a]. 
-- La compongo con f (sobre el primer elemento) y gan茅
-- map f = foldr ((:) . f) []
filter f = foldr (\elem -&gt; \partial -&gt; if f elem then (elem:partial) else partial) []
</code></pre>
<p>Podemos implementar <code>(++)</code> usando <code>foldr</code>?</p>
<pre><code class="language-haskell">(++) :: [a] -&gt; [a] -&gt; [a]
xs ++ ys = foldr (:) ys xs
</code></pre>
<p>Ahora probemos algo m谩s complicado. Definamos <code>sumaLong</code> que calcula la
longitud y la suma en una 煤nca pasada sobre una lista.</p>
<pre><code class="language-haskell">sumaLong :: [Int] -&gt; (Int, Int)
-- hago pattern matching contra una tupla
sumaLong = foldr (\elem -&gt; \(recLong, recSum) -&gt; (recLong + elem, recSum + 1)) (0, 0)
</code></pre>
<p>Por 煤ltimo, podemos definir <code>dropWhile</code> usando foldr? Ej de uso: <code>dropWhile even [2, 4, 1, 6] = [1, 6]</code>. La definici贸n "cl谩sica" es:</p>
<pre><code class="language-haskell">dropWhile :: (a -&gt; Bool) -&gt; [a] -&gt; [a]
dropWhile _ [] = []
dropWhile p (x:xs) = if p x then dropWhile p xs else x:xs
</code></pre>
<p>La intuici贸n me dice de que esto no se va a poder, porque ahora no tenemos el
final de la recursi贸n cuando se nos acaba la lista, si no que depende de los
elementos. Igual intentemos:</p>
<pre><code class="language-haskell">dropWhile = foldr (\x rec -&gt; ????????) []
</code></pre>
<p>Tengo un problema... Si justo ten铆a que cortar en <code>x</code>, no tengo forma de
"decirle" al caso recursivo que no tiene que filtrar, y tampoco tengo c贸mo
recuperar lo que falta de la lista.</p>
<p>C贸mo puedo sobreponerme a esto? Bueno, por algo vimos el ejemplo anterior de
<code>SumaLong</code>. Podr铆a hacer que mi funci贸n devuelva una tupla, en donde el primer
elemento es el resultado del <code>dropWhile</code> y el segundo es la lista sin filtrar.</p>
<pre><code class="language-haskell">dropWhile p = fst (foldr (\x (droppedRec, undroppedRec) -&gt; 
        if p x then (undroppedRec, x:undroppedRec) 
        else (x:droppedRec, x:undroppedRec)) ([], []))
-- alternativa
dropWhile p = fst (foldr (\x (droppedRec, undroppedRec) -&gt; 
        (if p x then undroppedRec else x:droppedRec, x:undroppedRec)) ([], []))
-- alternativa: llamo a lo de arriba sin el fst dropWhileTupla y despu茅s dropWhile p xs = fst (dropWhileTupla p xs)
</code></pre>
<h3 id="recursi贸n-primitiva"><a class="header" href="#recursi贸n-primitiva">Recursi贸n Primitiva</a></h3>
<p>Tomando este problema que tuvimos con <code>foldr</code> para implementar <code>dropWhile</code>, por
qu茅 no nos definimos otra funci贸n que si tenga en cuenta el <code>xs</code> del resto de
la lista?</p>
<p>El esquema de <code>dropWhile</code> ser铆a:</p>
<pre><code class="language-haskell">g :: [a] -&gt; b
-- caso base
g [] = z
-- recursi贸n
g (x:xs) = f x xs (g xs)
</code></pre>
<p>Y la generalizaci贸n la llamamos <code>recr</code>:</p>
<pre><code class="language-haskell">recr :: b -&gt; (a -&gt; [a] -&gt; b -&gt; b) -&gt; [a] -&gt; b
recr z _ [] = z
recr z f (x:xs) = f x xs (recr z f xs)
</code></pre>
<div id="admonition-sobre-funciones-primitivas-recursivas" class="admonition admonish-info">
<div class="admonition-title">
<p>Sobre funciones Primitivas Recursivas</p>
<p><a class="admonition-anchor-link" href="esquemas_de_recursion.html#admonition-sobre-funciones-primitivas-recursivas"></a></p>
</div>
<div>
<p>Las funciones Primitivas Recursivas son un conjunto de funciones que vemos en
L贸gica y Computabilidad, y en particular tienen un esquema de recursi贸n muy
parecido a este que acabamos de ver. Dicho eso, sabemos que no son todas las
funciones computables debido a que por ejemplo <a href="https://planetmath.org/ackermannfunctionisnotprimitiverecursive">no existe una primitiva recursiva que pueda calcular la funci贸n de Ackermann</a>.</p>
<p>Sin embargo, es posible con <code>foldr</code> implementar la funci贸n de Ackermann. Esto
da cuenta realmente del poder de expresividad de <code>foldr</code>.</p>
</div>
</div>
<p>Podemos reimplementar <code>dropWhile</code> usando <code>recr</code>?</p>
<pre><code class="language-haskell">dropWhile p = recr [] (\x xs rec -&gt; if p x then xs else x:rec)
</code></pre>
<p>Mucho m谩s simple!</p>
<p>Podemos escribir <code>foldr</code> usando <code>recr</code>?</p>
<pre><code class="language-haskell">foldr f z = recr z (\x xs rec -&gt; f x rec)
</code></pre>
<p>Y <code>recr</code> en t茅rminos de <code>foldr</code>?</p>
<pre><code class="language-haskell">-- Uso el mismo truco de antes, devuelvo la tupla manteniendo en el segundo elemento
recr z f = fst . (foldr (\x (rec, xs) -&gt; (f x xs rec, x:xs)) (z, []))
</code></pre>
<div id="admonition-foldl" class="admonition admonish-info">
<div class="admonition-title">
<p>foldl</p>
<p><a class="admonition-anchor-link" href="esquemas_de_recursion.html#admonition-foldl"></a></p>
</div>
<div>
<p>Una alternativa a <code>foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b</code> es <code>foldl</code> (notar
que se invierte el orden de los tipos en la funci贸n):</p>
<pre><code class="language-haskell">foldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b
foldl _ z [] = z
foldl f z (x:xs) = foldl f (f z x) xs
</code></pre>
<p>La lista ahora se "recorre" de adelante hacia atr谩s:</p>
<p><img src="./img/foldl_scheme.png" alt="" /></p>
<p>Otro detalle es que ahora el llamado recursivo no es parte de la <code>f</code>. Si
volvemos a revisar <code>foldr</code> vamos a notar que si <code>xs</code> era una lista infinita,
pero <code>f</code> ignora la lista no pasa nada. En cambio ac谩 si ten茅s problemas porque
se consume la lista entera incluso si <code>f</code> no la usa.</p>
<p>Notar que en <code>foldl</code> el <code>z</code> es el resultado parcial, no el caso base (o m谩s
bien, es el caso base en el primer elemento y despu茅s es el resultado parcial
acumulado).</p>
<p>Si queremos ver un ejemplo, tomemos <code>sumaL</code>:</p>
<pre><code class="language-haskell">sumaL = foldl (+) 0
</code></pre>
<p>Es igual! Pero el orden de evaluaci贸n cambia:</p>
<pre><code class="language-haskell">foldl (+) 0 [1, 2]
foldl (+) ((+) 0 1) [2]
foldl (+) ((+) ((+) 0 1) 2) []
((+) ((+) 0 1) 2)
((+) 1 2)
3
</code></pre>
<p>Otro ejemplo, el reverse!:</p>
<pre><code class="language-haskell">reverse = foldl (\acc x -&gt; x:acc) []
-- equivalentemente
reverse = foldl (flip (:)) []
</code></pre>
</div>
</div>
<h3 id="foldl-vs-foldr"><a class="header" href="#foldl-vs-foldr"><code>foldl</code> vs <code>foldr</code></a></h3>
<ul>
<li>En listas infinitas? Us谩 <code>foldr</code></li>
<li>Puedo escribir <code>foldl</code> usando <code>foldr</code>?</li>
</ul>
<pre><code class="language-haskell">-- galerazo: en lugar de acumular y listo, devuelvo una funci贸n 
-- que cuando la aplique va a tomar el orden del foldl (asumamos 
-- que g es alguna funci贸n que toma un elemento)
foldl f z xs = foldr (\x recf -&gt; (\ac -&gt; recf (f ac x))) (g) 
</code></pre>
<p>Creo que ayuda m谩s a entender si lo vemos con un ejemplo y lo expandimos:</p>
<pre><code class="language-haskell">-- supongamos que hacemos foldl f g [x, y]
-- al final de la recursi贸n tenemos:
(\ac -&gt; g (f ac y))
-- cuando se vuelve de la recursi贸n y se aplica el siguiente paso
(\ac' -&gt; (\ac -&gt; g (f ac y)) (f ac' x))
-- Si hacemos el reemplazo en la evaluaci贸n:
(\ac' -&gt; g (f (f ac' x) y))
-- ah铆 se puede ver que si ac' es el caso base z, tendr铆a la evaluaci贸n en el orden del foldl
</code></pre>
<p>Por 煤ltimo entonces, alcanza con notar que si <code>g = id</code> ya gan茅. O sea que queda definida como:</p>
<pre><code class="language-haskell">foldl f z xs = foldr (\x recf -&gt; (\ac -&gt; recf (f ac x))) id z
</code></pre>
<ul>
<li>Puedo escribir <code>foldr</code> usando <code>foldl</code>? No, pero si para listas finitas</li>
</ul>
<h1 id="esquemas-de-recursi贸n-sobre-tipos-de-datos-algebr谩icos"><a class="header" href="#esquemas-de-recursi贸n-sobre-tipos-de-datos-algebr谩icos">Esquemas de recursi贸n sobre tipos de datos algebr谩icos</a></h1>
<h2 id="rboles-binarios"><a class="header" href="#rboles-binarios">rboles binarios</a></h2>
<p>Recuerdo, yo pod铆a definir un 谩rbol binario como:</p>
<pre><code class="language-haskell">data Arbol a = Hoja a | Nodo a (Arbol a) (Arbol a)
</code></pre>
<p>Y podr铆a querer por ejemplo aplicar una funci贸n a todos los nodos. A qu茅 te
suena eso? As铆 es, al <code>map</code>. En el caso de 谩rboles tendr铆amos un <code>map</code> definido
como:</p>
<pre><code class="language-haskell">mapA :: (a -&gt; b) -&gt; Arbol a -&gt; Arbol b
mapA f (Hoja x) = Hoja (f x)
mapA f (Nodo a (sai) (sad)) = (Nodo (f a) (mapA f sai) (mapA f sad))
</code></pre>
<p>As铆 como puedo hacer <code>map</code>, puedo hacer <code>fold</code> tambi茅n:</p>
<pre><code class="language-haskell">-- recibo una funci贸n para aplicar en el caso base y otra 
-- para la combinaci贸n. La segunda recibe los resultados del
-- fold para ambas ramas
foldA :: (a -&gt; b) -&gt; (a -&gt; b -&gt; b -&gt; b) -&gt; Arbol a -&gt; b
foldA f g (Hoja x) = f x
foldA f g (Nodo x izq der) = g x (foldA f g izq) (foldA f g der)
</code></pre>
<h3 id="algunas-operaciones-interesantes"><a class="header" href="#algunas-operaciones-interesantes">Algunas operaciones interesantes</a></h3>
<pre><code class="language-haskell">-- no te suena al foldr (:) = id?
-- obs: fold aplicado a los constructores es la identidad
id = foldA Hoja Nodo

sumaA = foldA id (\x izq der -&gt; x + izq + der)

altura = fold (\x -&gt; 1) (\x izq der -&gt; max izq der + 1)
</code></pre>
<h2 id="rboles-generales"><a class="header" href="#rboles-generales">rboles Generales</a></h2>
<pre><code class="language-haskell">data AG a = NodoAG a [AG a]
</code></pre>
<p>La pregunta es c贸mo hago <code>fold</code>/<code>map</code> con esto?</p>
<pre><code class="language-haskell">mapAG :: (a -&gt; b) -&gt; AG a -&gt; AG b
-- uso tanto map como mapAG!!!
mapAG f (NodoAG a as) = NodoAG (f a) (map (mapAG f) as)
</code></pre>
<pre><code class="language-haskell">-- No tengo "caso base" porque map _ [] = []. 
-- Ya est谩 impl铆cito el caso base
foldAG :: (a -&gt; [b] -&gt; b) -&gt; AG a -&gt; b
-- notar que es igual a antes, pero en lugar de aplicar al nodo 
-- izquierdo o derecho lo aplico a todos los nodos de la lista
foldAG f (NodoAG a as) = f a (map (foldAG f) as)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unidad-2---c谩lculo-lambda"><a class="header" href="#unidad-2---c谩lculo-lambda">Unidad 2 - C谩lculo Lambda</a></h1>
<div style="float:right;margin-left:2rem;margin-bottom:2rem;width:330px">
<p><img src="./img/church.png" alt="" /></p>
</div>
<ul>
<li>El C谩lculo Lambda es un modelo de c贸mputo basado en <strong>funciones</strong>, que es la
base para el paradigma funcional.</li>
<li>Fue introducido por Alonzo Church en el 34', cuando quer铆a responder a la
pregunta de si hab铆a un proceso mec谩nico para demostrar si una f贸rmula era
teorema o no.
<ul>
<li>Alonzo formaliz贸 en el lambda c谩lculo esta idea de computar cosas.</li>
</ul>
</li>
<li>Si bien lo introduce en el 34', nosotros vamos a ver el <strong>C谩lculo Lambda Tipado</strong>, tambi茅n desarrollado por Church pero en el 41'.
<ul>
<li>las expresiones tienen tipos</li>
</ul>
</li>
<li>El lambda c谩lculo es tambi茅n computacionalmente completo, a.k.a <strong>Turing Completo</strong>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>$$
\newcommand{\lcb}{\lambda^b}
\newcommand{\ifLC}[3]{if\  {#1}\  then\  {#2}\  else\  {#3}}
\newcommand{\lf}[3]{\lambda{#1}:\ {#2}.{#3}}
\newcommand{\apply}[2]{{#1}\ {#2}}
\newcommand{\hastype}[3]{{#1} \triangleright {#2}: {#3}}
\newcommand{\ttrue}[1]{\frac{}{\hastype{#1}{true}{Bool}} (T-True)}
\newcommand{\tfalse}[1]{\frac{}{\hastype{#1}{false}{Bool}} (T-False)}
\newcommand{\tvar}[3]{\frac{{#2}:{#3} \in {#1}}{\hastype{#1}{#2}{#3}} (T-var)}
\newcommand{\tif}[5]{\frac{\hastype{#1}{#2}{Bool}\ \ \hastype{#1}{#3}{#5}\ \ \hastype{#1}{#4}{#5}}{\hastype{#1}{\ifLC{{#2}}{{#3}}{{#4}}}{#5}} (T-If)}
\newcommand{\tabs}[5]{\frac{\hastype{{#1},{#2}:{#3}}{#5}{#4}}{\hastype{#1}{\lf{{#2}}{{#3}}{{#5}}}{{#3} \rightarrow {#4}}} (T-abs)}
\newcommand{\tapp}[5]{\frac{\hastype{#1}{#2}{#3 \rightarrow #4}\ \ \hastype{#1}{#5}{#3}}{\hastype{#1}{\apply{{#2}}{{#5}}}{#4}} (T-app)}
\newcommand{\eiftrue}[2]{\frac{}{\ifLC{true}{#1}{#2} \rightarrow #1} (E-IfTrue)}
\newcommand{\eiffalse}[2]{\frac{}{\ifLC{false}{#1}{#2} \rightarrow #2} (E-IfFalse)}
\newcommand{\eif}[4]{\frac{#1 \rightarrow #2}{\ifLC{#1}{#3}{#4} \rightarrow \ifLC{#2}{#3}{#4}} (E-If)}
\newcommand{\eift}[4]{\frac{\eiftrue{#3}{#4}}{\ifLC{#1}{#3}{#4} \rightarrow \ifLC{#2}{#3}{#4}} (E-If)}
\newcommand{\eiff}[4]{\frac{\eiffalse{#3}{#4}}{\ifLC{#1}{#3}{#4} \rightarrow \ifLC{#2}{#3}{#4}} (E-If)}
$$</p>
<h1 id="c谩lculo-lambda-tipado-booleano-lcb"><a class="header" href="#c谩lculo-lambda-tipado-booleano-lcb">C谩lculo Lambda Tipado Booleano \(\lcb\)</a></h1>
<h2 id="expresiones-de-tipos"><a class="header" href="#expresiones-de-tipos">Expresiones de tipos</a></h2>
<p>Las expresiones de tipos (o simplemente tipos) de \(\lcb\) son:</p>
<p>$$
\sigma, \tau ::= Bool | \sigma \rightarrow \tau
$$</p>
<p>En criollo,</p>
<ul>
<li>\(Bool\) es el tipo de los booleanos</li>
<li>\(\sigma \rightarrow \tau\) es el tipo de las funciones de tipo
\(\sigma\) en \(\tau\)</li>
</ul>
<p>Por ejemplo, uno puede tener una funci贸n \(Bool \rightarrow Bool\)</p>
<h2 id="t茅rminos-de-lambdab"><a class="header" href="#t茅rminos-de-lambdab">T茅rminos de \(\lambda^b\)</a></h2>
<p>Sea \(\mathcal{X}\) un conjunto infinito enumerable de variables y \(x \in \mathcal{X}\). Los t茅rminos de \(\lambda^b\) est谩n definidos por:</p>
<p>$$
\begin{align}
M,N,P,Q ::=&amp; \ x \\
&amp;| \ true \\
&amp;| \ false \\
&amp;| \ \ifLC{M}{P}{Q} \\
&amp;| \ \lf{x}{\sigma}{M} \\
&amp;| \ \apply{M}{N}
\end{align}
$$</p>
<p>Es importante entender que estas reglas <strong>s贸lo definen c贸mo construir sint谩cticamente los t茅rminos</strong>, pero no necesariamente te va a dar cosas que tengan sentido ni que sean 煤tiles. Veamos algunos ejemplos de t茅rminos v谩lidos:</p>
<ul>
<li>\(\lf{x}{Bool}{x}\)</li>
<li>\(\lf{x}{Bool}{\ifLC{x}{false}{true}}\)</li>
<li>\(\lf{f}{Bool \rightarrow Bool \rightarrow Bool}{\lf{x}{Bool}{\apply{f}{x}}}\)</li>
<li>\((\lf{f}{Bool \rightarrow Bool}{\apply{f}{true}})(\lf{y}{Bool}{y})\)</li>
<li>\(\apply{true}{(\lf{x}{Bool}{x})}\)</li>
<li>\(\apply{x}{y}\)</li>
</ul>
<h2 id="sistema-de-tipado"><a class="header" href="#sistema-de-tipado">Sistema de tipado</a></h2>
<ul>
<li>Es un sistema formal de deducci贸n/derivaci贸n que usa axiomas y reglas de
inferencia para caracterizar al conjunto de los conjuntos "bien tipados"</li>
<li>Lo definimos a partir de reglas de inferencia
<ul>
<li>axiomas de tipado para algunos t茅rminos</li>
<li>reglas de tipado para otros t茅rminos, que derivan (siempre y cuando se
pueda) el tipado de una expresi贸n en base a sus sub-expresiones.</li>
</ul>
</li>
</ul>
<h2 id="variables-libres"><a class="header" href="#variables-libres">Variables libres</a></h2>
<p>Ya vimos que tenemos funciones lambda que se pueden usar en la construcci贸n de
t茅rminos. Antes de seguir con otras cosas est谩 bueno definir y distinguir las
<strong>variables libres</strong> de las <strong>variables ligadas</strong>. Una variable \(x\) se dice
que ocurre libre si no est谩 bajo el alcance de alguna ocurrencia de un
\(\lambda x\). En otro caso decimos que ocurre ligada.</p>
<p><img src="./img/var_libre_vs_ligada.png#center" alt="" /></p>
<p>M谩s formalmente:</p>
<p>$$
\begin{align}
FV(x) &amp;\stackrel{def}{=} \{ x \} \\
FV(true) = FV(false) &amp;\stackrel{def}{=} \emptyset \\
FV(\ifLC{M}{P}{Q}) &amp;\stackrel{def}{=} FV(M) \cup FV(P) \cup FV(Q) \\
FV(\apply{M}{N}) &amp;\stackrel{def}{=} FV(M) \cup FV(N) \\
FV(\lf{x}{\sigma}{M}) &amp;\stackrel{def}{=} FV(M) \setminus \{x\} \\
\end{align}
$$</p>
<h2 id="sistema-de-tipado-1"><a class="header" href="#sistema-de-tipado-1">Sistema de tipado</a></h2>
<p>Un <strong>juicio de tipado</strong> es una expresi贸n de la forma \(\Gamma \triangleright M\ :\ \sigma\) que se lee como: "el t茅rmino \(M\) tiene tipo \(\sigma\) asumiendo el contexto de tipado \(\Gamma\)"</p>
<p>Un <strong>contexto de tipado</strong> por otro lado es un conjunto de pares \(x_i\ :\ \sigma_i\), anotado \(\{x_1\ :\ \sigma_1, \dots, x_n\ :\ \sigma_n\}\) donde los \(\{x_i\}_{i \in 1 \dots n}\) son distintos. Usamos letras \(\Gamma\), \(\bigtriangleup\), ... para contextos de tiapdo.</p>
<h2 id="axiomas-de-tipado-de-lcb"><a class="header" href="#axiomas-de-tipado-de-lcb">Axiomas de tipado de \(\lcb\)</a></h2>
<p>Obs: est谩n guiadas por la sint谩xis!</p>
<p>$$
\ttrue{\Gamma}
$$</p>
<p>$$
\tfalse{\Gamma}
$$</p>
<p>$$
\tvar{\Gamma}{x}{\sigma}
$$</p>
<p>$$
\tif{\Gamma}{M}{P}{Q}{\sigma}
$$</p>
<p>$$
\tabs{\Gamma}{x}{\sigma}{\tau}{M}
$$</p>
<p>$$
\tapp{\Gamma}{M}{\sigma}{\tau}{N}
$$</p>
<ul>
<li>Si \(\hastype{\Gamma}{M}{\sigma}\) puede derivarse usando los axiomas y reglas de tipado decimos que es derivable.</li>
<li>Decimos que \(M\) es tipable si el juicio de tiapdo \(\hastype{\Gamma}{M}{\sigma}\) puede derivarse, para alg煤n \(\Gamma\) y \(\sigma\).</li>
</ul>
<h2 id="resultados-b谩sicos-demostraci贸n-con-inducci贸n-estructural"><a class="header" href="#resultados-b谩sicos-demostraci贸n-con-inducci贸n-estructural">Resultados b谩sicos (demostraci贸n con inducci贸n estructural)</a></h2>
<h3 id="unicidad-de-tipos"><a class="header" href="#unicidad-de-tipos">Unicidad de tipos</a></h3>
<p>Si \(\hastype{\Gamma}{M}{\sigma}\) y \(\hastype{\Gamma}{M}{\tau}\) son derivables, entonces \(\sigma = \tau\).</p>
<h3 id="weakening--strengthening"><a class="header" href="#weakening--strengthening">Weakening + Strengthening</a></h3>
<p>Si \(\hastype{\Gamma}{M}{\sigma}\) es derivable y \(\Gamma \cap \Gamma'\) contiene a todas las variables libres de \(M\), entonces \(\hastype{\Gamma'}{M}{\sigma}\).</p>
<h2 id="sem谩ntica-o-sea-qu茅-hacen-mis-c贸mputos"><a class="header" href="#sem谩ntica-o-sea-qu茅-hacen-mis-c贸mputos">Sem谩ntica (o sea qu茅 hacen mis c贸mputos)</a></h2>
<p>Hasta ahora definimos para \(\lcb\) con reglas inductivas:</p>
<ul>
<li>una sint谩xis</li>
<li>un sistema de tipado</li>
</ul>
<p>Ahora vamos a darle significado a los t茅rminos que para nosotros tengan sentido
(o sea aquellos que est茅n bien tipados).</p>
<p>Hay distintas formas de definir la sem谩ntica, en particular vamos a dar una
<strong>sem谩ntica operacional</strong>. Nota: hay otros tipos de sem谩ntica, como la
sem谩ntica axiom谩tica (similar a lo que vimos en algo 1 con pre-condici贸n y
post-condici贸n, basada en aserciones), denotacional (le das una denotaci贸n a
cada t茅rmino del lenguaje y defin铆s la sem谩ntica dando funciones para los
elementos de la sintaxis).</p>
<p>En qu茅 consiste entonces la sem谩ntica operacional:</p>
<ul>
<li>interpreto a los t茅rminos como estados de una m谩quina abstracta</li>
<li>defino reglas para hacer evolucionar (reducir) los t茅rminos en otros t茅rminos
<ul>
<li>tambi茅n est谩n guiadas por sintaxis</li>
</ul>
</li>
<li>el <strong>significado</strong> de un t茅rmino \(M\) es el estado final que alcanza la
m谩quina si comienza con el estado inicial \(M\)</li>
<li>hay dos formas de dar la sem谩ntica operacional:
<ul>
<li><strong>small-step</strong>: describo pasos chiquitos. Vamos a ver principalmente
este.</li>
<li><strong>big-step (o natural semantics)</strong>: la funci贸n de transici贸n en un paso
reduce al resultado.</li>
</ul>
</li>
<li>definir la sem谩ntica tiene que hacerse de forma precisa cosa de poder llevar
todo a una implementaci贸n de un int茅rprete del lenguaje.</li>
</ul>
<h2 id="sem谩ntica-small-step"><a class="header" href="#sem谩ntica-small-step">Sem谩ntica small-step</a></h2>
<ul>
<li>La hacemos a trav茅s de <strong>juicios de evaluaci贸n</strong>, a.k.a. reglas de reducci贸n que se leen como "el t茅rmino \(M\) reduce en un paso al t茅rmino \(N\)":</li>
</ul>
<p>$$
M \rightarrow N
$$</p>
<ul>
<li>Uso axiomas de evaluaci贸n + reglas de derivaci贸n que establecen que algunos
juicios de evaluaci贸n son derivables a partir de otros juicios que tambi茅n
son derivables.</li>
<li>Adem谩s de la funci贸n de transici贸n, tenemos que definir los <strong>valores</strong>, que
son los posibles resultados de una evaluaci贸n de t茅rminos, en tanto sean
cerrados (no tiene variables libres) y est茅n bien tipados.</li>
</ul>
<h3 id="valores"><a class="header" href="#valores">Valores</a></h3>
<p>Como nuestro lambda c谩lculo es booleano, nos interesan true y false. O sea que
expresiones complejas tambi茅n pueden reducir a esos valores. O sea, todo
t茅rmino bien tiapdo y cerrado de tipo \(Bool\) eval煤a en cero o m谩s pasos, a
\(true\) o \(false\).</p>
<p>$$
V ::= true\ |\ false
$$</p>
<h3 id="juicio-de-evaluaci贸n-en-un-paso"><a class="header" href="#juicio-de-evaluaci贸n-en-un-paso">Juicio de evaluaci贸n en un paso</a></h3>
<p>Al If podemos pensarlo como que lo tenemos que reducir por completo el t茅rmino
del \(if\) hasta un valor, sea \(true\) o \(false\)</p>
<p>$$
\eiftrue{M_2}{M_3}
$$</p>
<p>$$
\eiffalse{M_2}{M_3}
$$</p>
<p>$$
\eif{M_1}{M_1'}{M_2}{M_3}
$$</p>
<div id="admonition-ejemplo" class="admonition admonish-info">
<div class="admonition-title">
<p>Ejemplo</p>
<p><a class="admonition-anchor-link" href="lambda_calc_booleano.html#admonition-ejemplo"></a></p>
</div>
<div>
<p>$$
\eiff{(\ifLC{false}{false}{true})}{true}{false}{true}
$$</p>
<p>Observaciones:</p>
<ul>
<li>No hay \(M\) tal que \(true \rightarrow M\)</li>
<li>Idem con \(false\)</li>
</ul>
</div>
</div>
<h4 id="algunas-propiedades-interesantes"><a class="header" href="#algunas-propiedades-interesantes">Algunas propiedades Interesantes</a></h4>
<ul>
<li><strong>Lema</strong> (Determinismo del juicio de evaluaci贸n en un paso): Si las reglas est谩n bien hechas, y \(M \rightarrow M'\) \(M \rightarrow M''\) entonces \(M' = M''\)</li>
<li>Una <strong>forma noraml</strong> es un t茅rmino que no puede evaluarse m谩s (o sea no existe una regla para reducir).</li>
<li>(recuerdo: un valor es el resultado al que puede evaluar un t茅rmino bien tipado y cerrado)</li>
<li><strong>Lema</strong>: todo valor est谩 en forma normal. No vale el rec铆proco en \(\lcb\). Por ejemplo:
<ul>
<li>\(\ifLC{x}{true}{false}\), no tengo c贸mo reducir porque \(x\) ta libre</li>
<li>\(x\), mismo caso</li>
<li>\(\apply{true}{false}\), no puedo reducir (tampoco tipa...)</li>
</ul>
</li>
<li>Lo vemos en un toque, pero el resultado m谩s fuerte es que si una expresi贸n es cerrada y bien tipada eventualmente puedo reducir hasta llegar a un valor.</li>
</ul>
<h3 id="evaluaci贸n-en-muchos-pasos"><a class="header" href="#evaluaci贸n-en-muchos-pasos">Evaluaci贸n en muchos pasos</a></h3>
<p>El <strong>juicio de evaluaci贸n en muchos pasos</strong> \(\twoheadrightarrow\) es la clausura reflexiva y transitiva de \(\rightarrow\). O sea es la menor relaci贸n tal que:</p>
<ol>
<li>Si \(M \rightarrow M'\), entonces \(M \twoheadrightarrow M'\)</li>
<li>\(M \twoheadrightarrow M\) para todo \(M\)</li>
<li>Si \(M \twoheadrightarrow M'\) y \(M' \twoheadrightarrow M''\), entonces \(M \twoheadrightarrow M''\)</li>
</ol>
<p>Por ejemplo, tenemos que:</p>
<p>$$
\ifLC{true}{(\ifLC{false}{false}{true})}{true} \twoheadrightarrow true
$$</p>
<h4 id="propiedades"><a class="header" href="#propiedades">Propiedades</a></h4>
<p>Para el c谩lculo de expresiones booleanas valen:</p>
<ul>
<li><strong>Lema</strong> (Unicidad de formas normales): Si \(M \twoheadrightarrow U\) y \(M \twoheadrightarrow V\), con \(U, V\) formas normales, entonces \(U = V\)</li>
<li><strong>Lema</strong> (Terminaci贸n): Para todo \(M\) existe una forma normal \(N\) tal que \(M \twoheadrightarrow \).
<ul>
<li>esto es bueno porque me aseguro que mi algoritmo de evaluaci贸n no tiene loops infinitos</li>
</ul>
</li>
</ul>
<h2 id="sem谩ntica-operacional-de-lcb"><a class="header" href="#sem谩ntica-operacional-de-lcb">Sem谩ntica Operacional de \(\lcb\)</a></h2>
<p>Ya hablamos antes de que en haskell por ejemplo, las funciones tambi茅n pueden ser resultados de una evaluaci贸n (eso de first class citizen, yada yada yada...). As铆 que por qu茅 no extendemos nuestro conjunto de valores:</p>
<p>$$
V ::= true\ false\ \lf{x}{\sigma}{M}
$$</p>
<p>Vamos a extender nuestro sistema tal que valgan los lemas previos, pero adem谩s valga el siguiente resultado:</p>
<div id="admonition-teorema" class="admonition admonish-abstract">
<div class="admonition-title">
<p>Teorema</p>
<p><a class="admonition-anchor-link" href="lambda_calc_booleano.html#admonition-teorema"></a></p>
</div>
<div>
<p>Para todo t茅rmino bien tipado y cerrado de tipo:</p>
<ul>
<li>\(Bool\) eval煤a, en cero o m谩s pasos, a \(true, false\).</li>
<li>\(\sigma \rightarrow \tau\) eval煤a, en cero o m谩s pasos, a \(\lf{x}{\sigma}{M}\), para alguna variable \(x\) y alg煤n t茅rmino \(M\)
<ul>
<li>en castellano: si tipa como una funci贸n eventualmente lo puedo reducir a la forma de una lambda con una variable y un t茅rmino</li>
</ul>
</li>
</ul>
</div>
</div>
<h3 id="juicio-de-evaluaci贸n-en-un-paso-1"><a class="header" href="#juicio-de-evaluaci贸n-en-un-paso-1">Juicio de evaluaci贸n en un paso</a></h3>
<ul>
<li>Primero, una regla que me haga reducir lo m谩s que pueda la "funci贸n" que quiero evaluar:</li>
</ul>
<p>$$
\frac{M_1 \rightarrow M_1'}{\apply{M_1}{M_2} \rightarrow \apply{M_1'}{M_2}} (E-App1 / \mu)
$$</p>
<ul>
<li>Segundo, una regla que me haga reducir lo m谩s que pueda al argumento:</li>
</ul>
<p>$$
\frac{M_2 \rightarrow M_2'}{\apply{(\lf{x}{\sigma}{M})}{M_2} \rightarrow \apply{(\lf{x}{\sigma}{M})}{M_2'}} (E-App1 / v)
$$</p>
<ul>
<li>Por 煤ltimo, una regla que se encargue del reemplazo de la evaluaci贸n</li>
</ul>
<p>$$
\frac{M_2 \rightarrow M_2'}{\apply{(\lf{x}{\sigma}{M})}{V} \rightarrow M \{x \leftarrow V\}} (E-AppAbs / \beta)
$$</p>
<ul>
<li>Esto 煤ltimo quiere decir agarrar la funci贸n lambda, y reemplazar sint谩cticamente las ocurrencias de \(x\) por \(V\)
<ul>
<li>sustituyo 煤nicamente las ocurrencias <strong>libres</strong> de \(x\)</li>
<li>le da sem谩ntica a la aplicaci贸n de funciones</li>
<li>hay que tener cuidado con los ligadores de variable (los \(\lambda x\))</li>
</ul>
</li>
</ul>
<p>Podemos dar una definici贸n basada en la sintaxis:</p>
<p>$$
\begin{align}
x \{x \leftarrow N\} &amp;\stackrel{def}{=} N \\
a \{x \leftarrow N\} &amp;\stackrel{def}{=} a \text{si a } \notin \{true, false\} \cup \mathcal{X} \setminus \{x\} \\
\ifLC{M}{P}{Q} \{x \leftarrow N\} &amp;\stackrel{def}{=} \ifLC{M\{x \leftarrow N\}}{P\{x \leftarrow N\}}{Q\{x \leftarrow N\}} \\
(\apply{M_1}{M_2}) \{x \leftarrow N\} &amp;\stackrel{def}{=} \apply{M_1\{x \leftarrow N\}}{M_2\{x \leftarrow N\}} \\
\lf{y}{\sigma}{M} \{x \leftarrow N\} &amp;\stackrel{def}{=} ? \\
\end{align}
$$</p>
<p>Y ese 煤ltimo? Imaginemos el caso de la sustituci贸n:</p>
<p>$$
\lf{z}{\sigma}{x} \{x \leftarrow N\} \stackrel{def}{=} \lf{z}{\sigma}{z}
$$</p>
<p>La convertimos de la funci贸n constante en la funci贸n identidad! Pero bueno, a
priori no importa qu茅 nombre tenga la variable ligada, no? Entonces, lo que
podemos hacer es renombrar (o asumir que se hizo el renombre para estas
reglas), de manera tal que la variable que se liga en la funci贸n lambda <strong>no
ocurre libre</strong> en \(N\). De ser as铆 la regla nos queda:</p>
<p>$$
\lf{y}{\sigma}{M} \{x \leftarrow N\} \stackrel{def}{=} \lf{y}{\sigma}{M\{x \leftarrow N\}}\ \ x \neq y, y \notin FV(N) \\
$$</p>
<p>Para formalizar esto aparece el concepto de \(\alpha\)-equivalencia. Dos
t茅rminos son \(\alpha\)-equivalentes si <strong>煤nicamente difieren en el nombre de
sus variables ligadas</strong>. Es una relaci贸n de equivalencia.</p>
<div id="admonition-algunos-ejemplos" class="admonition admonish-example">
<div class="admonition-title">
<p>Algunos ejemplos</p>
<p><a class="admonition-anchor-link" href="lambda_calc_booleano.html#admonition-algunos-ejemplos"></a></p>
</div>
<div>
<ul>
<li>\(\lf{x}{Bool}{x} =_{\alpha} \lf{y}{Bool}{y}\)</li>
<li>\(\lf{x}{Bool}{y} =_{\alpha} \lf{z}{Bool}{y}\)
<ul>
<li>ac谩 \(y\) es variable libre en ambos casos</li>
</ul>
</li>
<li>\(\lf{x}{Bool}{y} \neq_{\alpha} \lf{x}{Bool}{z}\)
<ul>
<li>ac谩 tanto \(y\) como \(z\) son variables libres y son distintas en cada t茅rmino.</li>
</ul>
</li>
<li>\(\lf{x}{Bool}{\lf{x}{Bool}{x}} \neq_{\alpha} \lf{y}{Bool}{\lf{x}{Bool}{y}}\)
<ul>
<li>ac谩 la lambda interna tiene en su subt茅rmino a la \(x\) ligada, mientras que del lado derecho no.</li>
</ul>
</li>
</ul>
<p>Llevado a la pr谩ctica, esto quiere decir que mientras hagamos las reducciones,
podemos tener que hacer el reemplazo por un t茅rmino \(\alpha\)-equivalente y
despu茅s aplicar la sustituci贸n.</p>
</div>
</div>
<h2 id="estado-de-error"><a class="header" href="#estado-de-error">Estado de error</a></h2>
<ul>
<li>Es un estado (t茅rmino) que <strong>no es</strong> un valor, pero en el que la evaluaci贸n est谩 <strong>trabada</strong>.</li>
<li>Representa un estado en el cual el sistema de runtime en una implementaci贸n real generar铆a una excepci贸n</li>
<li>Ejemplos:
<ul>
<li>\(\ifLC{x}{M}{N}\)
<ul>
<li>obs: no es cerrado</li>
</ul>
</li>
<li>\(\apply{true}{M}\)
<ul>
<li>obs: no es tipable</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="objetivo-de-un-sistema-de-tipos"><a class="header" href="#objetivo-de-un-sistema-de-tipos">Objetivo de un sistema de tipos</a></h2>
<p>Queremos garantizar la <strong>ausencia</strong> de estados de error. Decimos que un t茅rmino
<strong>termina</strong> o que es <strong>fuertemente normalizante</strong> si no hay cadenas de
reducci贸n infinitas a partir de 茅l.</p>
<div id="admonition-teorema-1" class="admonition admonish-note">
<div class="admonition-title">
<p>Teorema</p>
<p><a class="admonition-anchor-link" href="lambda_calc_booleano.html#admonition-teorema-1"></a></p>
</div>
<div>
<ul>
<li>Todo t茅rmino bien tipado termina</li>
<li>Si un t茅rmino cerrado est谩 bien tipado, entonces eval煤a a un valor</li>
</ul>
</div>
</div>
<p>Tenemos algunas propiedades que nos garantizan este teorema:</p>
<ul>
<li>Progreso: Si \(M\) es cerrado y bien tipado, entonces:
<ul>
<li>\(M\) es un valor</li>
<li>o bien existe \(M'\) tal que \(M \rightarrow M'\) (o sea no se traba si los t茅rminos son cerrados y bien tipados, y no son valores)</li>
</ul>
</li>
<li>Preservaci贸n (de tipo): Si \(\hastype{\Gamma}{M}{\sigma}\) y \(M \rightarrow N\), entonces \(\hastype{\Gamma}{N}{\sigma}\) (o sea que la reducci贸n/evaluaci贸n preserva tipos).</li>
</ul>
<blockquote>
<p><strong>Observaci贸n</strong>: parto de progreso. O bien es un valor, o tengo el t茅rmino al
que reducir. Luego por preservaci贸n de tipos, aplicar la reducci贸n nos dice
que el nuevo t茅rmino est谩 bien tipado, y sigue siendo cerrado.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c谩lculo-lambda-tipado-extendido"><a class="header" href="#c谩lculo-lambda-tipado-extendido">C谩lculo Lambda Tipado Extendido</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inferencia-de-tipos"><a class="header" href="#inferencia-de-tipos">Inferencia de tipos</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subtipado"><a class="header" href="#subtipado">Subtipado</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unidad-3---programaci贸n-funcional"><a class="header" href="#unidad-3---programaci贸n-funcional">Unidad 3 - Programaci贸n Funcional</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c谩lculo-sigma"><a class="header" href="#c谩lculo-sigma">C谩lculo Sigma</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c谩lculo-sigma-1"><a class="header" href="#c谩lculo-sigma-1">C谩lculo Sigma</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unidad-4---programaci贸n-funcional"><a class="header" href="#unidad-4---programaci贸n-funcional">Unidad 4 - Programaci贸n Funcional</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resoluci贸n-proposicional"><a class="header" href="#resoluci贸n-proposicional">Resoluci贸n Proposicional</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resoluci贸n-en-l贸gica-de-primer-orden"><a class="header" href="#resoluci贸n-en-l贸gica-de-primer-orden">Resoluci贸n en l贸gica de primer orden</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resoluci贸n-sld"><a class="header" href="#resoluci贸n-sld">Resoluci贸n SLD</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prolog"><a class="header" href="#prolog">Prolog</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pr谩cticas"><a class="header" href="#pr谩cticas">Pr谩cticas</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guia-0---repaso-haskell"><a class="header" href="#guia-0---repaso-haskell">Guia 0 - Repaso Haskell</a></h1>
<h2 id="ejercicio-1-1"><a class="header" href="#ejercicio-1-1">Ejercicio 1</a></h2>
<p>Dar el tipo y describir el comportamiento de las siguientes funciones del m贸dulo <code>Prelude</code> de Haskell:</p>
<p>Hago un par nom谩s (recomiendo primero jugar un poco con las funciones y si no les queda claro pueden usar <code>:doc NOMBRE_DE_LA_FUNCIN</code>):</p>
<ul>
<li><code>null</code>:</li>
</ul>
<pre><code class="language-haskell">ghci&gt; :type null
null :: Foldable t =&gt; t a -&gt; Bool
ghci&gt; null []
True
ghci&gt; null [1, 2 , 3]
False
</code></pre>
<p>Devuelve si una estructura est谩 vac铆a o no</p>
<ul>
<li><code>head</code></li>
</ul>
<pre><code class="language-haskell">ghci&gt; :type head
head :: GHC.Stack.Types.HasCallStack =&gt; [a] -&gt; a
ghci&gt; head []
*** Exception: Prelude.head: empty list
CallStack (from HasCallStack):
  error, called at libraries/base/GHC/List.hs:1646:3 in base:GHC.List
  errorEmptyList, called at libraries/base/GHC/List.hs:85:11 in base:GHC.List
  badHead, called at libraries/base/GHC/List.hs:81:28 in base:GHC.List
  head, called at &lt;interactive&gt;:9:1 in interactive:Ghci3
ghci&gt; head [1, 2]
1
</code></pre>
<p>Devuelve el primer elemento de una lista</p>
<ul>
<li><code>take</code></li>
</ul>
<pre><code class="language-haskell">ghci&gt; :type take
take :: Int -&gt; [a] -&gt; [a]
ghci&gt; take 3 [1, 2 , 3, 4]
[1,2,3]
ghci&gt; take 3 [1, 2]
[1,2]
ghci&gt; take 3 []
[]
</code></pre>
<p>Recibe un n煤mero <code>n</code> y una lista, y devuelve los primeros <code>n</code> elementos de dicha lista.</p>
<ul>
<li><code>!!</code></li>
</ul>
<pre><code class="language-haskell">ghci&gt; :type (!!)
(!!) :: GHC.Stack.Types.HasCallStack =&gt; [a] -&gt; Int -&gt; a
ghci&gt; [1, 2, 3, 4] !! 2
3
ghci&gt; [1, 2, 3, 4] !! 3
4
ghci&gt; [1, 2, 3, 4] !! 0
1
</code></pre>
<p>Es el operador de indexado.</p>
<h2 id="ejercicio-2-1"><a class="header" href="#ejercicio-2-1">Ejercicio 2</a></h2>
<p>Definir las siguientes funciones:</p>
<ul>
<li><code>valorAbsoluto :: Float -&gt; Float</code> que dado un n煤mero devuelve su valor absoluto.</li>
</ul>
<pre><code class="language-haskell">valorAbsoluto :: Float -&gt; Float
valorAbsoluto = abs
</code></pre>
<ul>
<li><code>bisiesto :: Int -&gt; Bool</code> que dado un n煤mero que representa un a帽o, indica si el mismo es bisiesto.</li>
</ul>
<pre><code class="language-haskell">bisiesto :: Int -&gt; Bool
bisiesto anio | mod anio 4 == 0 = True
              | otherwise       = False
</code></pre>
<ul>
<li><code>factorial :: Int -&gt; Int</code> definida 煤nicamente para enteros positivos, que computa el factorial.</li>
</ul>
<pre><code class="language-haskell">factorial :: Int -&gt; Int
factorial 1 = 1
factorial n = n * factorial (n-1)
</code></pre>
<ul>
<li><code>cantDivisoresPrimos :: Int -&gt; Int</code>, que dado un entero positivo devuelve la cantidad de divisores primos</li>
</ul>
<pre><code class="language-haskell">valorAbsoluto :: Float -&gt; Float
valorAbsoluto = abs

bisiesto :: Int -&gt; Bool
bisiesto anio | mod anio 4 == 0 = True
              | otherwise       = False

factorial :: Int -&gt; Int
factorial 1 = 1
factorial n = n * factorial (n-1)

cantDivisoresPrimos :: Int -&gt; Int
cantDivisoresPrimos n = cantDivisoresPrimosMenoresA n n

cantDivisoresPrimosMenoresA :: Int -&gt; Int -&gt; Int
cantDivisoresPrimosMenoresA _ 1 = 0
cantDivisoresPrimosMenoresA n divisorCandidato | esPrimo divisorCandidato &amp;&amp; mod n divisorCandidato == 0 = 1 + divisoresMenores
                                               | otherwise                   = divisoresMenores
                                              where divisoresMenores = cantDivisoresPrimosMenoresA n (divisorCandidato - 1)

esPrimo :: Int -&gt; Bool
esPrimo n = cantDivisoresMenoresA n n == 2

cantDivisoresMenoresA :: Int -&gt; Int -&gt; Int
cantDivisoresMenoresA _ 1 = 1
cantDivisoresMenoresA n divisorCandidato | mod n divisorCandidato == 0 = 1 + divisoresMenores
                                         | otherwise                   = divisoresMenores
                                         where divisoresMenores = cantDivisoresMenoresA n (divisorCandidato - 1)
</code></pre>
<h2 id="ejercicio-3-1"><a class="header" href="#ejercicio-3-1">Ejercicio 3</a></h2>
<p>Contamos con los tipos <code>Maybe</code> y <code>Either</code> definidos como sigue:</p>
<pre><code class="language-haskell">data Maybe a = Nothing | Just a
data Either a b = Left a | Right b
</code></pre>
<ul>
<li>Definir la funci贸n <code>inverso :: Float -&gt; Maybe Float</code> que dado un n煤mero devuelve su inverso multiplicativo si est谩 definido, o <code>Nothing</code> en caso contrario.</li>
</ul>
<pre><code class="language-haskell">inverso :: Float -&gt; Maybe Float
inverso 0.0 = Nothing
inverso x = Just (1.0 / x)
</code></pre>
<ul>
<li>Definir la funci贸n <code>aEntero :: Either Int Bool -&gt; Int</code> que convierte a entero una expresi贸n que puede ser booleana o entera. En el caso de los booleanos, el entero que corresponde es 0 para <code>False</code> y 1 para <code>True</code>.</li>
</ul>
<pre><code class="language-haskell">aEntero :: Either Int Bool -&gt; Int
aEntero (Left unEntero) = unEntero
aEntero (Right True) = 1
aEntero (Right False) = 0
</code></pre>
<h2 id="ejercicio-4-1"><a class="header" href="#ejercicio-4-1">Ejercicio 4</a></h2>
<p>Definir las siguientes funciones sobre listas:</p>
<ul>
<li><code>limpiar :: String -&gt; String -&gt; String</code>, que elimina todas las apariciones de cualquier car谩cter de la primera cadena en la segunda. Por ejemplo, <code>limpiar "susto" "puerta"</code> eval煤a a <code>"pera"</code>. Nota: <code>String</code> es un renombre de <code>[Char]</code>. La notaci贸n <code>"hola"</code> es equivalente a <code>['h', 'o', 'l', 'a']</code> y a <code>'h':'o':'l':'a':[]</code></li>
</ul>
<pre><code class="language-haskell">limpiar :: String -&gt; String -&gt; String
limpiar [] fromStr = fromStr 
limpiar (unChar:restoDelPatron) fromStr = limpiar restoDelPatron (filter (/= unChar) fromStr) 
</code></pre>
<ul>
<li><code>difPromedio :: [Float] -&gt; [Float]</code> que dada una lista de n煤meros devuelve la diferencia de cada uno con el promedio general. Por ejemplo, <code>difPromedio [2, 3, 4]</code> eval煤a a <code>[-1, 0, 1]</code>.</li>
</ul>
<pre><code class="language-haskell">difPromedio :: [Float] -&gt; [Float]
difPromedio xs = map (\x -&gt; x - promedioXs) xs
              where promedioXs = promedio xs

promedio :: [Float] -&gt; Float
promedio [] = 0.0
promedio xs = sum xs / fromIntegral (length xs)
</code></pre>
<ul>
<li><code>todosIguales :: [Int] -&gt; Bool</code> que indica si una lista de enteros tiene todos sus elementos iguales.</li>
</ul>
<pre><code class="language-haskell">todosIguales :: [Int] -&gt; Bool
todosIguales [] = True
todosIguales (x:xs) = all (== x) xs
</code></pre>
<h2 id="ejercicio-5-1"><a class="header" href="#ejercicio-5-1">Ejercicio 5</a></h2>
<p>Dado el siguiente modelo para 谩rboles binarios:</p>
<pre><code class="language-haskell">data AB a = Nil | Bin (AB a) a (AB a)
</code></pre>
<p>definir las siguientes funciones:</p>
<ul>
<li><code>vacioAB :: AB a -&gt; Bool</code> que indica si un 谩rbol es vac铆o (i.e. no tiene nodos)</li>
</ul>
<pre><code class="language-haskell">vacioAB :: AB a -&gt; Bool
vacioAB Nil = True
vacioAB _ = False
</code></pre>
<ul>
<li><code>negacionAB :: AB bool -&gt; AB Bool</code> que dado un 谩rbol de booleanos construye otro formulado por la negaci贸n de cada uno de los nodos.</li>
</ul>
<pre><code class="language-haskell">negacionAB :: AB Bool -&gt; AB Bool
negacionAB Nil = Nil
negacionAB (Bin (hijoIzq) nodo (hijoDer)) = Bin (negacionAB hijoIzq) (not nodo) (negacionAB hijoDer)
</code></pre>
<ul>
<li><code>productoAB :: AB Int -&gt; Int</code> que calcula el producto de todos los nodos del 谩rbol</li>
</ul>
<pre><code class="language-haskell">productoAB :: AB Int -&gt; Int
productoAB Nil = 1
productoAB (Bin hijoIzq nodo hijoDer) = productoAB hijoIzq * nodo * productoAB hijoDer
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guia-1---programaci贸n-funcional"><a class="header" href="#guia-1---programaci贸n-funcional">Guia 1 - Programaci贸n funcional</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guia-2---c谩lculo-lambda-tipado"><a class="header" href="#guia-2---c谩lculo-lambda-tipado">Guia 2 - C谩lculo Lambda Tipado</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guia-3---inferencia-de-tipos"><a class="header" href="#guia-3---inferencia-de-tipos">Guia 3 - Inferencia de Tipos</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guia-4---subtipado"><a class="header" href="#guia-4---subtipado">Guia 4 - Subtipado</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guia-5---programaci贸n-orientada-a-objetos"><a class="header" href="#guia-5---programaci贸n-orientada-a-objetos">Guia 5 - Programaci贸n Orientada a Objetos</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guia-6---resoluci贸n-l贸gica"><a class="header" href="#guia-6---resoluci贸n-l贸gica">Guia 6 - Resoluci贸n L贸gica</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guia-7---programaci贸n-l贸gica"><a class="header" href="#guia-7---programaci贸n-l贸gica">Guia 7 - Programaci贸n L贸gica</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bibliograf铆a"><a class="header" href="#bibliograf铆a">Bibliograf铆a</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>
        <script src="theme/pagetoc.js"></script>

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
