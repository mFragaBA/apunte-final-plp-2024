<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Apunte Final Paradigmas de Lenguajes de Programación 2024</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./custom.css">
        <link rel="stylesheet" href="./mdbook-admonish.css">
        <link rel="stylesheet" href="theme/pagetoc.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="unidad_1.html"><strong aria-hidden="true">1.</strong> Unidad 1 - Programación Funcional Con Haskell</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="programacion_funcional.html"><strong aria-hidden="true">1.1.</strong> Intro a Haskell</a></li><li class="chapter-item expanded "><a href="esquemas_de_recursion.html"><strong aria-hidden="true">1.2.</strong> Esquemas de recursión</a></li></ol></li><li class="chapter-item expanded "><a href="unidad_2.html"><strong aria-hidden="true">2.</strong> Unidad 2 - Cálculo Lambda</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lambda_calc_booleano.html"><strong aria-hidden="true">2.1.</strong> Cálculo Lambda Tipado Booleano</a></li><li class="chapter-item expanded "><a href="lambda_calc_extendido.html"><strong aria-hidden="true">2.2.</strong> Cálculo Lambda Tipado Extendido</a></li><li class="chapter-item expanded "><a href="inferencia_de_tipos.html"><strong aria-hidden="true">2.3.</strong> Inferencia de tipos</a></li><li class="chapter-item expanded "><a href="subtipado.html"><strong aria-hidden="true">2.4.</strong> Subtipado</a></li></ol></li><li class="chapter-item expanded "><a href="unidad_3.html"><strong aria-hidden="true">3.</strong> Unidad 3 - Paradigma de Objetos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="javascript_intro.html"><strong aria-hidden="true">3.1.</strong> Intro a POO</a></li><li class="chapter-item expanded "><a href="sigma_calc.html"><strong aria-hidden="true">3.2.</strong> Cálculo Sigma</a></li></ol></li><li class="chapter-item expanded "><a href="unidad_4.html"><strong aria-hidden="true">4.</strong> Unidad 4 - Programación Lógica</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="prop_solv.html"><strong aria-hidden="true">4.1.</strong> Resolución Proposicional</a></li><li class="chapter-item expanded "><a href="primer_orden_solv.html"><strong aria-hidden="true">4.2.</strong> Resolución en lógica de primer orden</a></li><li class="chapter-item expanded "><a href="sld_solv.html"><strong aria-hidden="true">4.3.</strong> Resolución SLD</a></li><li class="chapter-item expanded "><a href="prolog.html"><strong aria-hidden="true">4.4.</strong> Prolog</a></li></ol></li><li class="chapter-item expanded "><a href="practicas.html"><strong aria-hidden="true">5.</strong> Prácticas</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="guia_0.html"><strong aria-hidden="true">5.1.</strong> Guia 0 - Repaso Haskell</a></li><li class="chapter-item expanded "><a href="guia_1.html"><strong aria-hidden="true">5.2.</strong> Guia 1 - Programación funcional</a></li><li class="chapter-item expanded "><a href="guia_2.html"><strong aria-hidden="true">5.3.</strong> Guia 2 - Cálculo Lambda Tipado</a></li><li class="chapter-item expanded "><a href="guia_3.html"><strong aria-hidden="true">5.4.</strong> Guia 3 - Inferencia de Tipos</a></li><li class="chapter-item expanded "><a href="guia_4.html"><strong aria-hidden="true">5.5.</strong> Guia 4 - Subtipado</a></li><li class="chapter-item expanded "><a href="guia_5.html"><strong aria-hidden="true">5.6.</strong> Guia 5 - Programación Orientada a Objetos</a></li><li class="chapter-item expanded "><a href="guia_6.html"><strong aria-hidden="true">5.7.</strong> Guia 6 - Resolución Lógica</a></li><li class="chapter-item expanded "><a href="guia_7.html"><strong aria-hidden="true">5.8.</strong> Guia 7 - Programación Lógica</a></li></ol></li><li class="chapter-item expanded "><a href="bibliografía.html"><strong aria-hidden="true">6.</strong> Bibliografía</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Apunte Final Paradigmas de Lenguajes de Programación 2024</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main><div class="sidetoc"><nav class="pagetoc"></nav></div>
                        <h1 id="unidad-1---paradigma-funcional"><a class="header" href="#unidad-1---paradigma-funcional">Unidad 1 - Paradigma funcional</a></h1>
<p><img src="./img/hold_up.png" alt="" /></p>
<p>La materia se llama "Paradigmas de Programación. Qué es un paradigma de programación:</p>
<ul>
<li><strong>paradigma</strong>: es una forma de pensamiento (a.k.a un marco teórico, un
conjunto de creencias).</li>
<li><strong>lenguaje de programación</strong>: el lenguaje que usamos para comunicar
instrucciones a una computadora.
<ul>
<li>describen <strong>cómputos</strong> (más de a qué me refiero con esto adelante)</li>
<li>es <strong>turing completo</strong> si puede expresar todas las funciones computables
(LyC war flashbacks). Los DSLs son ejemplos de lenguajes de programación
que no necesariamente son turing completos.</li>
<li>tiene que poder describir lo que hay que hacer de forma explícita y no
ambigua.</li>
</ul>
</li>
<li>Entonces un <strong>paradigma de lenguaje de programación</strong> lo vamos a entender
como un estilo de programación, que impacta en la forma en la que se encaran
las soluciones
<ul>
<li>Está muuuuuy vinculado al <strong>modelo de cómputo</strong>
<ul>
<li>A partir de un estado inicial llegar a un estado final.</li>
<li>En orga, por ejemplo parto de un estado inicial <strong>y aplico secuencias
de instrucciones para modificar el estado</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Entender de paradigmas de programación es una herramienta muy útil a la hora de
decidir qué lenguaje elijo para resulver un problema.</p>
<p>En este resumen (y porque es lo visto en clase) voy a hablar de los paradigmas:</p>
<ul>
<li>imperativo</li>
<li>funcional (vamos a usar haskell)</li>
<li>orientado a objetos (javascript)</li>
<li>lógico (vamos a usar prolog)</li>
</ul>
<p>Pero sepan que exiten más: concurrente, eventos, basado en continuaciones,
probabilístico, cuántico. Además, hoy en día los lenguajes más modernos suelen
tomar features de distintos paradigmas (por ejemplo: rust 🦀. Otro ejemplo es
la incorporación de funciones anónimas en los distintos lenguajes, que antes
estaba medio reservado a los lenguajes funcionales) entonces la linea entre un
paradigma y otro dentro de un lenguaje se vuelve más difusa.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="programación-funcional"><a class="header" href="#programación-funcional">Programación Funcional</a></h1>
<p>Si bien vamos a ver todo con lenguaje "haskelloso", la mayoría de conceptos
aplican a los lenguajes funcionales en general. Vamos a ver más formal el
modelo de cómputo de lenguajes funcionales cuando veamos cálculo lambda.</p>
<ul>
<li>
<p>Programar: Definir funciones</p>
</li>
<li>
<p>Ejecutar: Evaluar expresiones</p>
<pre><code># Programando
factorial(1) = 1
factorial(n) = factorial(n - 1) * n


# Evaluando
factorial(4) =&gt; factorial(3) * 4 
             =&gt; factorial(2) * 3 * 4 
             =&gt; factorial(1) * 2 * 3 * 4
             =&gt; 1 * 2 * 3 * 4
             =&gt; 6 * 4
             =&gt; 24
</code></pre>
</li>
<li>
<p>Un programa es un conjunto de ecuaciones</p>
</li>
<li>
<p>Expresiones</p>
<ul>
<li>Si se puede definir, toda expresión denota un valor</li>
<li>El valor depende únicamente del valor de sus subexpresiones</li>
<li>Evaluar/Reducir una expresión es obtener su valor (en el ejemplo <code>factorial(4) ~&gt; 24</code>)</li>
<li>No toda expresión denota un valor (si no puedo reducir no tengo un valor)</li>
</ul>
</li>
<li>
<p>Valores</p>
<ul>
<li>Los podemos pensar como expresiones que no se pueden seguir reduciendo</li>
</ul>
</li>
</ul>
<h2 id="tipos"><a class="header" href="#tipos">Tipos</a></h2>
<p>En Haskell organizamos los valores en <strong>tipos</strong>. El tipo tiene operaciones asociadas. En haskell se tienen:</p>
<ul>
<li>tipos básicos: <code>Int</code>, <code>Char</code>, <code>Float</code>, <code>Bool</code></li>
<li>tipos compuestos:
<ul>
<li>Listas: <code>[Int]</code></li>
<li>Tuplas: <code>(Int, Bool)</code></li>
<li>Funciones: <code>Int -&gt; Int</code></li>
</ul>
</li>
<li><strong>todo expresión bien formada tiene un tipo asociado</strong> (esto también, más
adelante vamos a ver que si no se le puede otorgar tipo a una expresión
entonces no se va a poder reducir) y el tipo depende del tipo de sus
subexpresiones.</li>
</ul>
<h2 id="funciones"><a class="header" href="#funciones">Funciones</a></h2>
<div id="admonition-definición" class="admonition admonish-note">
<div class="admonition-title">
<p>Definición</p>
<p><a class="admonition-anchor-link" href="programacion_funcional.html#admonition-definición"></a></p>
</div>
<div>
<ul>
<li>
<p>Definición con ecuación orientada:</p>
<pre><code class="language-haskell">doble :: Int -&gt; Int
doble x = x + x
</code></pre>
</li>
<li>
<p>Definición con guardas:</p>
<pre><code class="language-haskell">signo :: Int -&gt; Bool
signo n | n &gt;= 0    = True
        | otherwise = False
</code></pre>
</li>
<li>
<p>Definiciones locales:</p>
<pre><code class="language-haskell">f(x, y) = g x + y
        where g z = z + 2
</code></pre>
</li>
<li>
<p>Expresiones Lambda:</p>
<pre><code class="language-haskell">-- con un parámetro
\x -&gt; x + 1
-- con muchos parámetros
\x -&gt; \y -&gt; x + y
-- escritura más simple, separo parámetros con espacios
\x y -&gt; x + y
</code></pre>
</li>
</ul>
</div>
</div>
<h2 id="polimorfismo-paramétrico"><a class="header" href="#polimorfismo-paramétrico">Polimorfismo paramétrico</a></h2>
<p>Dada la siguiente función <code>id</code>, cuál es su tipo?</p>
<pre><code class="language-haskell">id x = x
</code></pre>
<p>Rta: <code>id :: a -&gt; a</code>, donde <code>a</code> es una variable de tipo (es algo así como un meta-tipo)</p>
<h2 id="clases-de-tipos"><a class="header" href="#clases-de-tipos">Clases de Tipos</a></h2>
<p>Cuál es el tipo de <code>máximo</code>?</p>
<pre><code class="language-haskell">maximo x y | x &gt; y      = x
maximo _ y              = y
</code></pre>
<p>Puedo probar de evaluar a <code>máximo</code>:</p>
<pre><code class="language-bash"># La evalúo con enteros y funciona
&gt; maximo 1 2
2
# La evalúo con decimales y también funciona
&gt; maximo 1.2 3.4
3.4
</code></pre>
<p>Una <strong>clase</strong> es una suerte de interface que define un conjunto de operaciones. Por ejemplo:</p>
<ul>
<li><code>Eq</code>: <code>(==)</code>, <code>(/=)</code></li>
<li><code>Ord</code>: <code>(&lt;)</code>, <code>(&lt;=)</code>, <code>(&gt;=)</code>, <code>(&gt;)</code>, <code>max</code>, <code>min</code>, <code>compare</code></li>
</ul>
<p>pVolviendo a <code>maximo</code>, tenemos que <code>maximo :: Ord a =&gt; a -&gt; a -&gt; a</code>. O sea que
en máximo puedo recibir cualquier tipo en tanto pertenezca a la clase <code>Ord</code>
(cosa de tener el comparador)</p>
<h2 id="instancia-de-una-clase-de-tipos"><a class="header" href="#instancia-de-una-clase-de-tipos">Instancia de una clase de tipos</a></h2>
<p>Notar que haskell permite usar el <code>deriving</code> que deriva automáticamente una
"implementación por default" de todas las funciones de <code>Eq</code>. En el caso de <code>Eq</code>
compara cada caso, si es <code>Circulo</code> compara el valor, y si es <code>Rectangulo</code>
compara ambos valores.</p>
<pre><code class="language-haskell">data Figura = Circulo Float | Rectangulo Float Float
deriving Eq
</code></pre>
<p>Pero también se pueden definir instancias con la lógica que quiera:</p>
<pre><code class="language-haskell">instance Ord Figura where
    (&lt;=) = \x -&gt; \y -&gt; area x &lt;= area y
</code></pre>
<h2 id="alto-orden"><a class="header" href="#alto-orden">Alto Orden</a></h2>
<p>En haskell, las funciones son lo que se conoce como first-class citizens, eso
significa que las funciones <strong>son un valor más</strong>. O sea que podés pasarlas como
parámetro, pueden ser el resultado de una función.</p>
<p>Por ejemplo, a <code>id</code> le puedo pasar <code>id</code>. Entonces, cuál sería el tipo de <code>id id</code>?</p>
<p>El tipo es <code>(id id) :: a -&gt; a</code></p>
<h2 id="currificación"><a class="header" href="#currificación">Currificación</a></h2>
<p>Veámoslo con 2 ejemplos:</p>
<pre><code class="language-haskell">suma :: ??
suma x y = x + y

suma' :: ??
suma' (x, y) = x + y
</code></pre>
<p>Si reviso los tipos obtengo que:</p>
<pre><code class="language-haskell">suma :: Int -&gt; Int -&gt; Int
suma' :: (Int, Int) -&gt; Int
</code></pre>
<p>Cuál es la diferencia? Que la primera implementación puedo hacer por ejemplo
<code>suma 5</code> y obtengo una función que incrementa en 5. Eso no lo puedo hacer con
<code>suma'</code>. Esta feature de poder evaluar parcialmente las funciones es lo que se
conoce como <strong>currificación</strong>.</p>
<p><img src="./img/currification.png#center" alt="" /></p>
<p>(No, ese Curry no...)</p>
<p>Veamos cómo se ve esto en ghci:</p>
<pre><code>&gt; :type suma
suma :: Int -&gt; Int -&gt; Int
&gt; :type suma 4
(suma 4) :: Int -&gt; Int
</code></pre>
<p>O sea que puedo definir por ejemplo <code>inc = suma 1</code></p>
<h3 id="viendo-curryuncurry-como-una-función"><a class="header" href="#viendo-curryuncurry-como-una-función">Viendo curry/uncurry como una función</a></h3>
<pre><code class="language-haskell">curry :: ((a, b) -&gt; c) -&gt; (a -&gt; (b -&gt; c))
curry f = \x -&gt; \y -&gt; f (x,y)
-- versión alternativa --
curry f x = \y -&gt; f (x, y)

uncurry :: (a -&gt; b -&gt; c) -&gt; ((a, b) -&gt; c)
uncurry f (a, b) = f x y
</code></pre>
<h2 id="tipos-algebráicos"><a class="header" href="#tipos-algebráicos">Tipos Algebráicos</a></h2>
<p>Puedo definir los tipos por enumeración definiendo:</p>
<ul>
<li>el nombre del tipo</li>
<li>los constructores</li>
</ul>
<pre><code class="language-haskell">data Dia = Lunes | Martes | Miercoles | Jueves | Viernes | Sabado | Domingo

data Bool = True | False
</code></pre>
<p>Los constructores también pueden tener parámetros. En la definición tengo que aclarar los tipos de sus argumentos:</p>
<pre><code class="language-haskell">data Figura = Circulo Float | Rectangulo Float Float
</code></pre>
<p>Algunos ejemplos de tipos:</p>
<ul>
<li><code>Lunes :: Dia</code></li>
<li><code>Circulo 1.0 :: Figura</code></li>
<li><code>Circulo :: Float -&gt; Figura</code></li>
</ul>
<h2 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern matching</a></h2>
<p>Es un mecanismo para comparar un valor con un patrón y deconstruir un valor en
sus partes. Por ejemplo:</p>
<pre><code class="language-haskell">area :: Figura -&gt; Float
area (Circulo radio) = PI * radio^2 
area (Rectangulo base altura) = base * altura
</code></pre>
<p>Si no hay un match directo, lo que va a hacer haskell es seguir reduciendo.
Eventualmente va a matchear o no se va a poder reducir la expresión (y vamos a
tener un error).</p>
<div id="admonition-el-patrón-debe-ser-lineal" class="admonition admonish-info">
<div class="admonition-title">
<p>El patrón debe ser lineal</p>
<p><a class="admonition-anchor-link" href="programacion_funcional.html#admonition-el-patrón-debe-ser-lineal"></a></p>
</div>
<div>
<ul>
<li>
<p><strong>Lineal</strong> quiere decir que una variable debe aparecer una única vez a la izquierda.</p>
<pre><code class="language-haskell">esCuadrado :: Figura -&gt; Bool
esCuadrado (Circulo _) = False
esCuadrado (Rectangulo x y) | x == y =&gt;     = True
                            | otherwise     = False
-- alternativa
esCuadrado (Rectangulo x y) | x == y =&gt;     = True
esCuadrado _                                = False

-- alternativa también valida
esCuadrado (Rectangulo x y) = x == y
esCuadrado _                = False
</code></pre>
</li>
<li>
<p><code>esCuadrado (Rectangulo x x)</code> sería más simple pero no está permitido en
haskell (ej: en erlang/elixir esto es posible)</p>
</li>
</ul>
<p>Observaciones:</p>
<ul>
<li>
<p><code>_</code> coincide con cualquier forma (ver que en la alternativa agarro tanto el caso de <code>Circulo</code> como el de <code>Rectangulo</code> que no es cuadrado)</p>
</li>
<li>
<p>los casos se evalúan en el orden que están escritos</p>
</li>
<li>
<p>Puedo definir funciones parciales:</p>
<pre><code class="language-haskell">-- en este caso radio (Rectangulo _ _) va a dar error
radio (Circulo radio) = radio
</code></pre>
</li>
</ul>
</div>
</div>
<h2 id="tipos-recursivos"><a class="header" href="#tipos-recursivos">Tipos Recursivos</a></h2>
<p>La definición de un tipo tpuede tener uno o más parámetros de tipo:</p>
<pre><code class="language-haskell">data Natural = Zero | Succ Natural

Zero :: Natural
Succ Zero :: Natural
Succ (Succ (Succ Zero)) :: Natural
</code></pre>
<h2 id="listas"><a class="header" href="#listas">Listas</a></h2>
<p>Es un tipo algebráico paramétrico y recursivo con 2 constructores:</p>
<pre><code class="language-haskell">[] :: [a]               -- Constructor de la lista vacía
(:) :: a -&gt; [a] -&gt; [a]  -- Append Front
</code></pre>
<p>Ejemplos de pattern matching:</p>
<pre><code class="language-haskell">esVacia :: [a] -&gt; Bool
esVacia [] = True
esVacia _ = False
</code></pre>
<pre><code class="language-haskell">longitud :: [a] -&gt; Int
longitud [] = 0
longitud (x:xs) _ = 1 + longitud xs
</code></pre>
<h2 id="no-terminación-y-orden-de-evaluación"><a class="header" href="#no-terminación-y-orden-de-evaluación">No terminación y orden de evaluación</a></h2>
<p>Veamos la siguiente función:</p>
<pre><code class="language-haskell">inf1 :: [Int]
inf1 = 1 : inf1
</code></pre>
<p>Se reduce infinitamente, entonces para qué quiero tener algo así? De qué me sirve? Veamos esta función:</p>
<pre><code class="language-haskell">const :: a -&gt; b -&gt; a
const x y = x
</code></pre>
<p>Qué pasa si hago <code>const 42 inf1</code>? Da 42. Pero en realidad depende del mecanismo
de reducción que tenga el lenguaje, porque haskell resuelve primero el pattern
matching en lugar de reducir los parámetros. Si no me quedaba reduciendo
infinitamente.</p>
<h3 id="evaluación-lazy-orden-normal"><a class="header" href="#evaluación-lazy-orden-normal">Evaluación Lazy (Orden Normal)</a></h3>
<ul>
<li>Tiene que ver con el modelo de cómputo que usa haskell, que es el de la
<code>Reducción</code>
<ul>
<li>Se reemplaza un redex (expresión reducible) por otra usando las
ecuaciones orientadas. Un redex es una sub-expresión que no esté en forma
normal.</li>
<li>El redex tiene que ser una instancia del lado izquiero de alguna de las
ecuaciones (si no da error), y se reemplaza por el lado derecho asociando
las variables correspondientes.</li>
<li>El resto de la expresión no cambia</li>
</ul>
</li>
<li>La evaluación Lazy, consiste en seleccionar las funciones más externas y
luego los argumentos (pero sólo si se necesitan)</li>
</ul>
<h2 id="ejercicios"><a class="header" href="#ejercicios">Ejercicios</a></h2>
<h3 id="ejercicio-1"><a class="header" href="#ejercicio-1">Ejercicio 1</a></h3>
<p>Definir <code>dobleL :: [Float] -&gt; Float</code> tal que <code>doble xs</code> es la lista que contiene el doble de cada elemento en xs</p>
<pre><code class="language-haskell">doble [] = []
doble x:xs = (x * 2) : (doble xs)
</code></pre>
<h3 id="ejercicio-2"><a class="header" href="#ejercicio-2">Ejercicio 2</a></h3>
<p>Definir <code>esPar :: [Int] -&gt; [Bool]</code> tal que <code>esParL xs</code> indica si el correspondiente elemento en xs es par o no</p>
<pre><code class="language-haskell">esPar [] = []
esPar x:xs = (even x) : (esPar xs)
</code></pre>
<h3 id="ejercicio-3"><a class="header" href="#ejercicio-3">Ejercicio 3</a></h3>
<p>Definir <code>longL :: [[a]] -&gt; [Int]</code> tal que <code>longL xs</code> es la lista que contiene las longitudes de las listas en xs</p>
<pre><code class="language-haskell">longL [] = []
longL x:xs = (length x) : (longL xs)
</code></pre>
<div id="admonition-generalizando" class="admonition admonish-note">
<div class="admonition-title">
<p>Generalizando...</p>
<p><a class="admonition-anchor-link" href="programacion_funcional.html#admonition-generalizando"></a></p>
</div>
<div>
<ul>
<li>
<p>Notar que en los ejercicios el patrón era siempre el mismo con la diferencia de que en el primero hacíamos <code>* 2</code>, en el segundo <code>even x</code> y en el tercero <code>length x</code></p>
</li>
<li>
<p>Podemos generalizar este comportamiento (gracias funciones de alto orden!) en la siguiente función:</p>
<pre><code class="language-haskell">map :: (a -&gt; b) -&gt; [a] -&gt; [b]
map _ [] = []
map f x:xs = (f x) : (map f xs)
</code></pre>
</li>
<li>
<p>Podemos redefinir las funciones de antes con <code>map</code>:</p>
<pre><code class="language-haskell">-- Ni tengo que agregar el parámetro a la definición!
doble = map (\x -&gt; 2 * x)
esPar = map even
longL = map length
</code></pre>
</li>
</ul>
</div>
</div>
<h3 id="ejercicio-4"><a class="header" href="#ejercicio-4">Ejercicio 4</a></h3>
<p>Definir <code>negativos :: [Float] -&gt; [Float]</code> tal que <code>negativos xs</code> contiene los elementos negativos de xs</p>
<pre><code class="language-haskell">negativos [] = []
negativos x:xs  | x &lt; 0     = x : (negativos xs)
                | otherwise = negativos xs
</code></pre>
<h3 id="ejercicio-5"><a class="header" href="#ejercicio-5">Ejercicio 5</a></h3>
<p>Definir <code>noVacias :: [[a]] -&gt; [[a]]</code> tal que <code>noVacias xs</code> contiene las listas no vacías de <code>xs</code></p>
<pre><code class="language-haskell">noVacias [] = []
noVacias x:xs   | length x &gt; 0     = x : (noVacias xs)
                | otherwise = noVacias xs
</code></pre>
<div id="admonition-generalizando-1" class="admonition admonish-note">
<div class="admonition-title">
<p>Generalizando...</p>
<p><a class="admonition-anchor-link" href="programacion_funcional.html#admonition-generalizando-1"></a></p>
</div>
<div>
<ul>
<li>
<p>Notar que en los ejercicios el patrón era siempre el mismo: el caso base
devuelve vacío, y para el otro chequeo una condición booleana para saber si
agregar o no.</p>
</li>
<li>
<p>Podemos generalizar este comportamiento (gracias funciones de alto orden again!) en
la siguiente función:</p>
<pre><code class="language-haskell">filter :: (a -&gt; Bool) -&gt; [a] -&gt; [b]
filter _ [] = []
filter f x:xs   | (f x)     = x : (filter f xs)
                | otherwise = filter f xs
</code></pre>
</li>
<li>
<p>Podemos redefinir las funciones de antes con <code>filter</code>:</p>
<pre><code class="language-haskell">-- Ni tengo que agregar el parámetro a la definición!
negativos = filter (\x -&gt; x &lt; 0)
noVacias = filter (\x -&gt; length x &gt; 0)
</code></pre>
</li>
</ul>
</div>
</div>
<h2 id="transparencia-referencial"><a class="header" href="#transparencia-referencial">Transparencia referencial</a></h2>
<p>Una propiedad de haskell (y otros lenguajes funcionales) es la de la
<strong>transparencia referencial</strong>. Esto qué significa? Que el resultado de evaluar
una expresión sólo depende de sus subexpresiones. Eso tiene la implicancia de
que si yo tengo 2 veces la misma subexpresión ambas van a evaluar al mismo
valor.</p>
<p>Un ejemplo para ver qué no tiene transparencia referencial es en un lenguaje imperativo como C puedo hacer:</p>
<pre><code class="language-c">algunaFuncion(x++, x++);
</code></pre>
<p>Estoy llamando a <code>algunaFuncion</code> y los parámetros son ambos <code>x++</code> pero no van a
tener el mismo valor.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="esquemas-de-recursión"><a class="header" href="#esquemas-de-recursión">Esquemas de recursión</a></h1>
<h2 id="esquemas-de-recursión-sobre-listas"><a class="header" href="#esquemas-de-recursión-sobre-listas">Esquemas de recursión sobre listas</a></h2>
<h3 id="recursión-estructural"><a class="header" href="#recursión-estructural">Recursión estructural</a></h3>
<p>Pensemos un par de funciones sobre listas:</p>
<ul>
<li>
<p><code>sumaL</code>: la suma de todos los valores de una lista de enteros</p>
<pre><code class="language-haskell">-- alguna def con tipos
sumaL [] = 0
sumaL (x:xs) = x + sumaL(xs)
</code></pre>
</li>
<li>
<p><code>concat</code>: la concatenación de todos los elementos de una lista de listas</p>
<pre><code class="language-haskell">-- alguna def con tipos
concat [] = []
concat (x:xs) = x ++ concat xs
</code></pre>
</li>
<li>
<p><code>reverso</code>: el reverso de una lista</p>
<pre><code class="language-haskell">reverso [] = []
reverso (x:xs) = reverso xs ++ [x]
</code></pre>
</li>
</ul>
<div id="admonition-generalizando" class="admonition admonish-info">
<div class="admonition-title">
<p>Generalizando...</p>
<p><a class="admonition-anchor-link" href="esquemas_de_recursion.html#admonition-generalizando"></a></p>
</div>
<div>
<p><strong>El approach es siempre el mismo</strong>. Asumo que se calcular el resultado para el
caso más chico y hago alguna operación para combinar todo, y el resultado puede
ser otra cosa distinta, no necesariamente una lista. Sumado a eso tenemos un
caso base distinguido.</p>
<pre><code class="language-haskell">g :: [a] -&gt; b
-- caso base distinguido
g [] = z
g (x:xs) = f x (g xs)
</code></pre>
<p>Generalizando, obtenemos el fold:</p>
<p><img src="./img/foldr_scheme.png#center" alt="" /></p>
<pre><code class="language-haskell">-- recibimos una función, un elemento para el caso base y una lista
-- la función recibe un elemnto de la lista, y lo otro de tipo b es el resultado parcial
foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b
foldr _ z [] = z
foldr f z (x:xs) = f x (foldr f z xs)
</code></pre>
</div>
</div>
<h4 id="algunos-ejemplos-con-foldr"><a class="header" href="#algunos-ejemplos-con-foldr">Algunos ejemplos con <code>foldr</code></a></h4>
<p>Podemos repensar las funciones de antes usando <code>foldr</code>:</p>
<pre><code class="language-haskell">-- a = b = Int =&gt; (+) :: Int -&gt; Int -&gt; Int === a -&gt; b -&gt; b
sumaL = foldr (+) 0
-- a = b = [a'] =&gt; (++) :: [a'] -&gt; [a'] -&gt; [a'] === a -&gt; b -&gt; b
concat = foldr (++) []
-- a = a', b = [a'] =&gt; (:) :: a' -&gt; [a'] -&gt; [a'] === a -&gt; b -&gt; b
-- flip toma una función de 2 parámetros y les invierte el orden
-- al componerlo con (:[]) lo que hace es al primer parámetro (a')
-- lo mete en la lista vacía. Luego se pasa a flip (++) que va a 
-- hacer el ++ usando el primer parámetro como segundo
reverso = foldr ((flip (++)) . (:[])) []
-- alternativa más legible en mi opinión
reverso = foldr (\elem -&gt; \partial -&gt; partial ++ [elem]) []
</code></pre>
<p>Y también podemos reimplementar <code>map</code> y <code>filter</code> usando <code>foldr</code>:</p>
<pre><code class="language-haskell">map f = foldr (\elem -&gt; \partial -&gt; (f elem):partial) []
-- alternativa: (:) es una función a -&gt; [a] -&gt; [a]. 
-- La compongo con f (sobre el primer elemento) y gané
-- map f = foldr ((:) . f) []
filter f = foldr (\elem -&gt; \partial -&gt; if f elem then (elem:partial) else partial) []
</code></pre>
<p>Podemos implementar <code>(++)</code> usando <code>foldr</code>?</p>
<pre><code class="language-haskell">(++) :: [a] -&gt; [a] -&gt; [a]
xs ++ ys = foldr (:) ys xs
</code></pre>
<p>Ahora probemos algo más complicado. Definamos <code>sumaLong</code> que calcula la
longitud y la suma en una únca pasada sobre una lista.</p>
<pre><code class="language-haskell">sumaLong :: [Int] -&gt; (Int, Int)
-- hago pattern matching contra una tupla
sumaLong = foldr (\elem -&gt; \(recLong, recSum) -&gt; (recLong + elem, recSum + 1)) (0, 0)
</code></pre>
<p>Por último, podemos definir <code>dropWhile</code> usando foldr? Ej de uso: <code>dropWhile even [2, 4, 1, 6] = [1, 6]</code>. La definición "clásica" es:</p>
<pre><code class="language-haskell">dropWhile :: (a -&gt; Bool) -&gt; [a] -&gt; [a]
dropWhile _ [] = []
dropWhile p (x:xs) = if p x then dropWhile p xs else x:xs
</code></pre>
<p>La intuición me dice de que esto no se va a poder, porque ahora no tenemos el
final de la recursión cuando se nos acaba la lista, si no que depende de los
elementos. Igual intentemos:</p>
<pre><code class="language-haskell">dropWhile = foldr (\x rec -&gt; ????????) []
</code></pre>
<p>Tengo un problema... Si justo tenía que cortar en <code>x</code>, no tengo forma de
"decirle" al caso recursivo que no tiene que filtrar, y tampoco tengo cómo
recuperar lo que falta de la lista.</p>
<p>Cómo puedo sobreponerme a esto? Bueno, por algo vimos el ejemplo anterior de
<code>SumaLong</code>. Podría hacer que mi función devuelva una tupla, en donde el primer
elemento es el resultado del <code>dropWhile</code> y el segundo es la lista sin filtrar.</p>
<pre><code class="language-haskell">dropWhile p = fst (foldr (\x (droppedRec, undroppedRec) -&gt; 
        if p x then (undroppedRec, x:undroppedRec) 
        else (x:droppedRec, x:undroppedRec)) ([], []))
-- alternativa
dropWhile p = fst (foldr (\x (droppedRec, undroppedRec) -&gt; 
        (if p x then undroppedRec else x:droppedRec, x:undroppedRec)) ([], []))
-- alternativa: llamo a lo de arriba sin el fst dropWhileTupla y después dropWhile p xs = fst (dropWhileTupla p xs)
</code></pre>
<h3 id="recursión-primitiva"><a class="header" href="#recursión-primitiva">Recursión Primitiva</a></h3>
<p>Tomando este problema que tuvimos con <code>foldr</code> para implementar <code>dropWhile</code>, por
qué no nos definimos otra función que si tenga en cuenta el <code>xs</code> del resto de
la lista?</p>
<p>El esquema de <code>dropWhile</code> sería:</p>
<pre><code class="language-haskell">g :: [a] -&gt; b
-- caso base
g [] = z
-- recursión
g (x:xs) = f x xs (g xs)
</code></pre>
<p>Y la generalización la llamamos <code>recr</code>:</p>
<pre><code class="language-haskell">recr :: b -&gt; (a -&gt; [a] -&gt; b -&gt; b) -&gt; [a] -&gt; b
recr z _ [] = z
recr z f (x:xs) = f x xs (recr z f xs)
</code></pre>
<div id="admonition-sobre-funciones-primitivas-recursivas" class="admonition admonish-info">
<div class="admonition-title">
<p>Sobre funciones Primitivas Recursivas</p>
<p><a class="admonition-anchor-link" href="esquemas_de_recursion.html#admonition-sobre-funciones-primitivas-recursivas"></a></p>
</div>
<div>
<p>Las funciones Primitivas Recursivas son un conjunto de funciones que vemos en
Lógica y Computabilidad, y en particular tienen un esquema de recursión muy
parecido a este que acabamos de ver. Dicho eso, sabemos que no son todas las
funciones computables debido a que por ejemplo <a href="https://planetmath.org/ackermannfunctionisnotprimitiverecursive">no existe una primitiva recursiva que pueda calcular la función de Ackermann</a>.</p>
<p>Sin embargo, es posible con <code>foldr</code> implementar la función de Ackermann. Esto
da cuenta realmente del poder de expresividad de <code>foldr</code>.</p>
</div>
</div>
<p>Podemos reimplementar <code>dropWhile</code> usando <code>recr</code>?</p>
<pre><code class="language-haskell">dropWhile p = recr [] (\x xs rec -&gt; if p x then xs else x:rec)
</code></pre>
<p>Mucho más simple!</p>
<p>Podemos escribir <code>foldr</code> usando <code>recr</code>?</p>
<pre><code class="language-haskell">foldr f z = recr z (\x xs rec -&gt; f x rec)
</code></pre>
<p>Y <code>recr</code> en términos de <code>foldr</code>?</p>
<pre><code class="language-haskell">-- Uso el mismo truco de antes, devuelvo la tupla manteniendo en el segundo elemento
recr z f = fst . (foldr (\x (rec, xs) -&gt; (f x xs rec, x:xs)) (z, []))
</code></pre>
<div id="admonition-foldl" class="admonition admonish-info">
<div class="admonition-title">
<p>foldl</p>
<p><a class="admonition-anchor-link" href="esquemas_de_recursion.html#admonition-foldl"></a></p>
</div>
<div>
<p>Una alternativa a <code>foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b</code> es <code>foldl</code> (notar
que se invierte el orden de los tipos en la función):</p>
<pre><code class="language-haskell">foldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b
foldl _ z [] = z
foldl f z (x:xs) = foldl f (f z x) xs
</code></pre>
<p>La lista ahora se "recorre" de adelante hacia atrás:</p>
<p><img src="./img/foldl_scheme.png" alt="" /></p>
<p>Otro detalle es que ahora el llamado recursivo no es parte de la <code>f</code>. Si
volvemos a revisar <code>foldr</code> vamos a notar que si <code>xs</code> era una lista infinita,
pero <code>f</code> ignora la lista no pasa nada. En cambio acá si tenés problemas porque
se consume la lista entera incluso si <code>f</code> no la usa.</p>
<p>Notar que en <code>foldl</code> el <code>z</code> es el resultado parcial, no el caso base (o más
bien, es el caso base en el primer elemento y después es el resultado parcial
acumulado).</p>
<p>Si queremos ver un ejemplo, tomemos <code>sumaL</code>:</p>
<pre><code class="language-haskell">sumaL = foldl (+) 0
</code></pre>
<p>Es igual! Pero el orden de evaluación cambia:</p>
<pre><code class="language-haskell">foldl (+) 0 [1, 2]
foldl (+) ((+) 0 1) [2]
foldl (+) ((+) ((+) 0 1) 2) []
((+) ((+) 0 1) 2)
((+) 1 2)
3
</code></pre>
<p>Otro ejemplo, el reverse!:</p>
<pre><code class="language-haskell">reverse = foldl (\acc x -&gt; x:acc) []
-- equivalentemente
reverse = foldl (flip (:)) []
</code></pre>
</div>
</div>
<h3 id="foldl-vs-foldr"><a class="header" href="#foldl-vs-foldr"><code>foldl</code> vs <code>foldr</code></a></h3>
<ul>
<li>En listas infinitas? Usá <code>foldr</code></li>
<li>Puedo escribir <code>foldl</code> usando <code>foldr</code>?</li>
</ul>
<pre><code class="language-haskell">-- galerazo: en lugar de acumular y listo, devuelvo una función 
-- que cuando la aplique va a tomar el orden del foldl (asumamos 
-- que g es alguna función que toma un elemento)
foldl f z xs = foldr (\x recf -&gt; (\ac -&gt; recf (f ac x))) (g) 
</code></pre>
<p>Creo que ayuda más a entender si lo vemos con un ejemplo y lo expandimos:</p>
<pre><code class="language-haskell">-- supongamos que hacemos foldl f g [x, y]
-- al final de la recursión tenemos:
(\ac -&gt; g (f ac y))
-- cuando se vuelve de la recursión y se aplica el siguiente paso
(\ac' -&gt; (\ac -&gt; g (f ac y)) (f ac' x))
-- Si hacemos el reemplazo en la evaluación:
(\ac' -&gt; g (f (f ac' x) y))
-- ahí se puede ver que si ac' es el caso base z, tendría la evaluación en el orden del foldl
</code></pre>
<p>Por último entonces, alcanza con notar que si <code>g = id</code> ya gané. O sea que queda definida como:</p>
<pre><code class="language-haskell">foldl f z xs = foldr (\x recf -&gt; (\ac -&gt; recf (f ac x))) id z
</code></pre>
<ul>
<li>Puedo escribir <code>foldr</code> usando <code>foldl</code>? No, pero si para listas finitas</li>
</ul>
<h1 id="esquemas-de-recursión-sobre-tipos-de-datos-algebráicos"><a class="header" href="#esquemas-de-recursión-sobre-tipos-de-datos-algebráicos">Esquemas de recursión sobre tipos de datos algebráicos</a></h1>
<h2 id="Árboles-binarios"><a class="header" href="#Árboles-binarios">Árboles binarios</a></h2>
<p>Recuerdo, yo podía definir un árbol binario como:</p>
<pre><code class="language-haskell">data Arbol a = Hoja a | Nodo a (Arbol a) (Arbol a)
</code></pre>
<p>Y podría querer por ejemplo aplicar una función a todos los nodos. A qué te
suena eso? Así es, al <code>map</code>. En el caso de árboles tendríamos un <code>map</code> definido
como:</p>
<pre><code class="language-haskell">mapA :: (a -&gt; b) -&gt; Arbol a -&gt; Arbol b
mapA f (Hoja x) = Hoja (f x)
mapA f (Nodo a (sai) (sad)) = (Nodo (f a) (mapA f sai) (mapA f sad))
</code></pre>
<p>Así como puedo hacer <code>map</code>, puedo hacer <code>fold</code> también:</p>
<pre><code class="language-haskell">-- recibo una función para aplicar en el caso base y otra 
-- para la combinación. La segunda recibe los resultados del
-- fold para ambas ramas
foldA :: (a -&gt; b) -&gt; (a -&gt; b -&gt; b -&gt; b) -&gt; Arbol a -&gt; b
foldA f g (Hoja x) = f x
foldA f g (Nodo x izq der) = g x (foldA f g izq) (foldA f g der)
</code></pre>
<h3 id="algunas-operaciones-interesantes"><a class="header" href="#algunas-operaciones-interesantes">Algunas operaciones interesantes</a></h3>
<pre><code class="language-haskell">-- no te suena al foldr (:) = id?
-- obs: fold aplicado a los constructores es la identidad
id = foldA Hoja Nodo

sumaA = foldA id (\x izq der -&gt; x + izq + der)

altura = fold (\x -&gt; 1) (\x izq der -&gt; max izq der + 1)
</code></pre>
<h2 id="Árboles-generales"><a class="header" href="#Árboles-generales">Árboles Generales</a></h2>
<pre><code class="language-haskell">data AG a = NodoAG a [AG a]
</code></pre>
<p>La pregunta es cómo hago <code>fold</code>/<code>map</code> con esto?</p>
<pre><code class="language-haskell">mapAG :: (a -&gt; b) -&gt; AG a -&gt; AG b
-- uso tanto map como mapAG!!!
mapAG f (NodoAG a as) = NodoAG (f a) (map (mapAG f) as)
</code></pre>
<pre><code class="language-haskell">-- No tengo "caso base" porque map _ [] = []. 
-- Ya está implícito el caso base
foldAG :: (a -&gt; [b] -&gt; b) -&gt; AG a -&gt; b
-- notar que es igual a antes, pero en lugar de aplicar al nodo 
-- izquierdo o derecho lo aplico a todos los nodos de la lista
foldAG f (NodoAG a as) = f a (map (foldAG f) as)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unidad-2---cálculo-lambda"><a class="header" href="#unidad-2---cálculo-lambda">Unidad 2 - Cálculo Lambda</a></h1>
<div style="float:right;margin-left:2rem;margin-bottom:2rem;width:330px">
<p><img src="./img/church.png" alt="" /></p>
</div>
<ul>
<li>El Cálculo Lambda es un modelo de cómputo basado en <strong>funciones</strong>, que es la
base para el paradigma funcional.</li>
<li>Fue introducido por Alonzo Church en el 34', cuando quería responder a la
pregunta de si había un proceso mecánico para demostrar si una fórmula era
teorema o no.
<ul>
<li>Alonzo formalizó en el lambda cálculo esta idea de computar cosas.</li>
</ul>
</li>
<li>Si bien lo introduce en el 34', nosotros vamos a ver el <strong>Cálculo Lambda Tipado</strong>, también desarrollado por Church pero en el 41'.
<ul>
<li>las expresiones tienen tipos</li>
</ul>
</li>
<li>El lambda cálculo es también computacionalmente completo, a.k.a <strong>Turing Completo</strong>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>$$
\newcommand{\lcb}{\lambda^b}
\newcommand{\ifLC}[3]{if\  {#1}\  then\  {#2}\  else\  {#3}}
\newcommand{\lf}[3]{\lambda{#1}:\ {#2}.{#3}}
\newcommand{\apply}[2]{{#1}\ {#2}}
\newcommand{\hastype}[3]{{#1} \triangleright {#2}: {#3}}
\newcommand{\ttrue}[1]{\frac{}{\hastype{#1}{true}{Bool}} (T-True)}
\newcommand{\tfalse}[1]{\frac{}{\hastype{#1}{false}{Bool}} (T-False)}
\newcommand{\tvar}[3]{\frac{{#2}:{#3} \in {#1}}{\hastype{#1}{#2}{#3}} (T-var)}
\newcommand{\tif}[5]{\frac{\hastype{#1}{#2}{Bool}\ \ \hastype{#1}{#3}{#5}\ \ \hastype{#1}{#4}{#5}}{\hastype{#1}{\ifLC{{#2}}{{#3}}{{#4}}}{#5}} (T-If)}
\newcommand{\tabs}[5]{\frac{\hastype{{#1},{#2}:{#3}}{#5}{#4}}{\hastype{#1}{\lf{{#2}}{{#3}}{{#5}}}{{#3} \rightarrow {#4}}} (T-abs)}
\newcommand{\tapp}[5]{\frac{\hastype{#1}{#2}{#3 \rightarrow #4}\ \ \hastype{#1}{#5}{#3}}{\hastype{#1}{\apply{{#2}}{{#5}}}{#4}} (T-app)}
\newcommand{\eiftrue}[2]{\frac{}{\ifLC{true}{#1}{#2} \rightarrow #1} (E-IfTrue)}
\newcommand{\eiffalse}[2]{\frac{}{\ifLC{false}{#1}{#2} \rightarrow #2} (E-IfFalse)}
\newcommand{\eif}[4]{\frac{#1 \rightarrow #2}{\ifLC{#1}{#3}{#4} \rightarrow \ifLC{#2}{#3}{#4}} (E-If)}
\newcommand{\eift}[4]{\frac{\eiftrue{#3}{#4}}{\ifLC{#1}{#3}{#4} \rightarrow \ifLC{#2}{#3}{#4}} (E-If)}
\newcommand{\eiff}[4]{\frac{\eiffalse{#3}{#4}}{\ifLC{#1}{#3}{#4} \rightarrow \ifLC{#2}{#3}{#4}} (E-If)}
$$</p>
<h1 id="cálculo-lambda-tipado-booleano-lcb"><a class="header" href="#cálculo-lambda-tipado-booleano-lcb">Cálculo Lambda Tipado Booleano \(\lcb\)</a></h1>
<h2 id="expresiones-de-tipos"><a class="header" href="#expresiones-de-tipos">Expresiones de tipos</a></h2>
<p>Las expresiones de tipos (o simplemente tipos) de \(\lcb\) son:</p>
<p>$$
\sigma, \tau ::= Bool | \sigma \rightarrow \tau
$$</p>
<p>En criollo,</p>
<ul>
<li>\(Bool\) es el tipo de los booleanos</li>
<li>\(\sigma \rightarrow \tau\) es el tipo de las funciones de tipo
\(\sigma\) en \(\tau\)</li>
</ul>
<p>Por ejemplo, uno puede tener una función \(Bool \rightarrow Bool\)</p>
<h2 id="términos-de-lambdab"><a class="header" href="#términos-de-lambdab">Términos de \(\lambda^b\)</a></h2>
<p>Sea \(\mathcal{X}\) un conjunto infinito enumerable de variables y \(x \in \mathcal{X}\). Los términos de \(\lambda^b\) están definidos por:</p>
<p>$$
\begin{align}
M,N,P,Q ::=&amp; \ x \\
&amp;| \ true \\
&amp;| \ false \\
&amp;| \ \ifLC{M}{P}{Q} \\
&amp;| \ \lf{x}{\sigma}{M} \\
&amp;| \ \apply{M}{N}
\end{align}
$$</p>
<p>Es importante entender que estas reglas <strong>sólo definen cómo construir sintácticamente los términos</strong>, pero no necesariamente te va a dar cosas que tengan sentido ni que sean útiles. Veamos algunos ejemplos de términos válidos:</p>
<ul>
<li>\(\lf{x}{Bool}{x}\)</li>
<li>\(\lf{x}{Bool}{\ifLC{x}{false}{true}}\)</li>
<li>\(\lf{f}{Bool \rightarrow Bool \rightarrow Bool}{\lf{x}{Bool}{\apply{f}{x}}}\)</li>
<li>\((\lf{f}{Bool \rightarrow Bool}{\apply{f}{true}})(\lf{y}{Bool}{y})\)</li>
<li>\(\apply{true}{(\lf{x}{Bool}{x})}\)</li>
<li>\(\apply{x}{y}\)</li>
</ul>
<h2 id="sistema-de-tipado"><a class="header" href="#sistema-de-tipado">Sistema de tipado</a></h2>
<ul>
<li>Es un sistema formal de deducción/derivación que usa axiomas y reglas de
inferencia para caracterizar al conjunto de los conjuntos "bien tipados"</li>
<li>Lo definimos a partir de reglas de inferencia
<ul>
<li>axiomas de tipado para algunos términos</li>
<li>reglas de tipado para otros términos, que derivan (siempre y cuando se
pueda) el tipado de una expresión en base a sus sub-expresiones.</li>
</ul>
</li>
</ul>
<h2 id="variables-libres"><a class="header" href="#variables-libres">Variables libres</a></h2>
<p>Ya vimos que tenemos funciones lambda que se pueden usar en la construcción de
términos. Antes de seguir con otras cosas está bueno definir y distinguir las
<strong>variables libres</strong> de las <strong>variables ligadas</strong>. Una variable \(x\) se dice
que ocurre libre si no está bajo el alcance de alguna ocurrencia de un
\(\lambda x\). En otro caso decimos que ocurre ligada.</p>
<p><img src="./img/var_libre_vs_ligada.png#center" alt="" /></p>
<p>Más formalmente:</p>
<p>$$
\begin{align}
FV(x) &amp;\stackrel{def}{=} \{ x \} \\
FV(true) = FV(false) &amp;\stackrel{def}{=} \emptyset \\
FV(\ifLC{M}{P}{Q}) &amp;\stackrel{def}{=} FV(M) \cup FV(P) \cup FV(Q) \\
FV(\apply{M}{N}) &amp;\stackrel{def}{=} FV(M) \cup FV(N) \\
FV(\lf{x}{\sigma}{M}) &amp;\stackrel{def}{=} FV(M) \setminus \{x\} \\
\end{align}
$$</p>
<h2 id="sistema-de-tipado-1"><a class="header" href="#sistema-de-tipado-1">Sistema de tipado</a></h2>
<p>Un <strong>juicio de tipado</strong> es una expresión de la forma \(\Gamma \triangleright M\ :\ \sigma\) que se lee como: "el término \(M\) tiene tipo \(\sigma\) asumiendo el contexto de tipado \(\Gamma\)"</p>
<p>Un <strong>contexto de tipado</strong> por otro lado es un conjunto de pares \(x_i\ :\ \sigma_i\), anotado \(\{x_1\ :\ \sigma_1, \dots, x_n\ :\ \sigma_n\}\) donde los \(\{x_i\}_{i \in 1 \dots n}\) son distintos. Usamos letras \(\Gamma\), \(\bigtriangleup\), ... para contextos de tiapdo.</p>
<h2 id="axiomas-de-tipado-de-lcb"><a class="header" href="#axiomas-de-tipado-de-lcb">Axiomas de tipado de \(\lcb\)</a></h2>
<p>Obs: están guiadas por la sintáxis!</p>
<p>$$
\ttrue{\Gamma}
$$</p>
<p>$$
\tfalse{\Gamma}
$$</p>
<p>$$
\tvar{\Gamma}{x}{\sigma}
$$</p>
<p>$$
\tif{\Gamma}{M}{P}{Q}{\sigma}
$$</p>
<p>$$
\tabs{\Gamma}{x}{\sigma}{\tau}{M}
$$</p>
<p>$$
\tapp{\Gamma}{M}{\sigma}{\tau}{N}
$$</p>
<ul>
<li>Si \(\hastype{\Gamma}{M}{\sigma}\) puede derivarse usando los axiomas y reglas de tipado decimos que es derivable.</li>
<li>Decimos que \(M\) es tipable si el juicio de tiapdo \(\hastype{\Gamma}{M}{\sigma}\) puede derivarse, para algún \(\Gamma\) y \(\sigma\).</li>
</ul>
<h2 id="resultados-básicos-demostración-con-inducción-estructural"><a class="header" href="#resultados-básicos-demostración-con-inducción-estructural">Resultados básicos (demostración con inducción estructural)</a></h2>
<h3 id="unicidad-de-tipos"><a class="header" href="#unicidad-de-tipos">Unicidad de tipos</a></h3>
<p>Si \(\hastype{\Gamma}{M}{\sigma}\) y \(\hastype{\Gamma}{M}{\tau}\) son derivables, entonces \(\sigma = \tau\).</p>
<h3 id="weakening--strengthening"><a class="header" href="#weakening--strengthening">Weakening + Strengthening</a></h3>
<p>Si \(\hastype{\Gamma}{M}{\sigma}\) es derivable y \(\Gamma \cap \Gamma'\) contiene a todas las variables libres de \(M\), entonces \(\hastype{\Gamma'}{M}{\sigma}\).</p>
<h2 id="semántica-o-sea-qué-hacen-mis-cómputos"><a class="header" href="#semántica-o-sea-qué-hacen-mis-cómputos">Semántica (o sea qué hacen mis cómputos)</a></h2>
<p>Hasta ahora definimos para \(\lcb\) con reglas inductivas:</p>
<ul>
<li>una sintáxis</li>
<li>un sistema de tipado</li>
</ul>
<p>Ahora vamos a darle significado a los términos que para nosotros tengan sentido
(o sea aquellos que estén bien tipados).</p>
<p>Hay distintas formas de definir la semántica, en particular vamos a dar una
<strong>semántica operacional</strong>. Nota: hay otros tipos de semántica, como la
semántica axiomática (similar a lo que vimos en algo 1 con pre-condición y
post-condición, basada en aserciones), denotacional (le das una denotación a
cada término del lenguaje y definís la semántica dando funciones para los
elementos de la sintaxis).</p>
<p>En qué consiste entonces la semántica operacional:</p>
<ul>
<li>interpreto a los términos como estados de una máquina abstracta</li>
<li>defino reglas para hacer evolucionar (reducir) los términos en otros términos
<ul>
<li>también están guiadas por sintaxis</li>
</ul>
</li>
<li>el <strong>significado</strong> de un término \(M\) es el estado final que alcanza la
máquina si comienza con el estado inicial \(M\)</li>
<li>hay dos formas de dar la semántica operacional:
<ul>
<li><strong>small-step</strong>: describo pasos chiquitos. Vamos a ver principalmente
este.</li>
<li><strong>big-step (o natural semantics)</strong>: la función de transición en un paso
reduce al resultado.</li>
</ul>
</li>
<li>definir la semántica tiene que hacerse de forma precisa cosa de poder llevar
todo a una implementación de un intérprete del lenguaje.</li>
</ul>
<h2 id="semántica-small-step"><a class="header" href="#semántica-small-step">Semántica small-step</a></h2>
<ul>
<li>La hacemos a través de <strong>juicios de evaluación</strong>, a.k.a. reglas de reducción que se leen como "el término \(M\) reduce en un paso al término \(N\)":</li>
</ul>
<p>$$
M \rightarrow N
$$</p>
<ul>
<li>Uso axiomas de evaluación + reglas de derivación que establecen que algunos
juicios de evaluación son derivables a partir de otros juicios que también
son derivables.</li>
<li>Además de la función de transición, tenemos que definir los <strong>valores</strong>, que
son los posibles resultados de una evaluación de términos, en tanto sean
cerrados (no tiene variables libres) y estén bien tipados.</li>
</ul>
<h3 id="valores"><a class="header" href="#valores">Valores</a></h3>
<p>Como nuestro lambda cálculo es booleano, nos interesan true y false. O sea que
expresiones complejas también pueden reducir a esos valores. O sea, todo
término bien tiapdo y cerrado de tipo \(Bool\) evalúa en cero o más pasos, a
\(true\) o \(false\).</p>
<p>$$
V ::= true\ |\ false
$$</p>
<h3 id="juicio-de-evaluación-en-un-paso"><a class="header" href="#juicio-de-evaluación-en-un-paso">Juicio de evaluación en un paso</a></h3>
<p>Al If podemos pensarlo como que lo tenemos que reducir por completo el término
del \(if\) hasta un valor, sea \(true\) o \(false\)</p>
<p>$$
\eiftrue{M_2}{M_3}
$$</p>
<p>$$
\eiffalse{M_2}{M_3}
$$</p>
<p>$$
\eif{M_1}{M_1'}{M_2}{M_3}
$$</p>
<div id="admonition-ejemplo" class="admonition admonish-info">
<div class="admonition-title">
<p>Ejemplo</p>
<p><a class="admonition-anchor-link" href="lambda_calc_booleano.html#admonition-ejemplo"></a></p>
</div>
<div>
<p>$$
\eiff{(\ifLC{false}{false}{true})}{true}{false}{true}
$$</p>
<p>Observaciones:</p>
<ul>
<li>No hay \(M\) tal que \(true \rightarrow M\)</li>
<li>Idem con \(false\)</li>
</ul>
</div>
</div>
<h4 id="algunas-propiedades-interesantes"><a class="header" href="#algunas-propiedades-interesantes">Algunas propiedades Interesantes</a></h4>
<ul>
<li><strong>Lema</strong> (Determinismo del juicio de evaluación en un paso): Si las reglas están bien hechas, y \(M \rightarrow M'\) \(M \rightarrow M''\) entonces \(M' = M''\)</li>
<li>Una <strong>forma noraml</strong> es un término que no puede evaluarse más (o sea no existe una regla para reducir).</li>
<li>(recuerdo: un valor es el resultado al que puede evaluar un término bien tipado y cerrado)</li>
<li><strong>Lema</strong>: todo valor está en forma normal. No vale el recíproco en \(\lcb\). Por ejemplo:
<ul>
<li>\(\ifLC{x}{true}{false}\), no tengo cómo reducir porque \(x\) ta libre</li>
<li>\(x\), mismo caso</li>
<li>\(\apply{true}{false}\), no puedo reducir (tampoco tipa...)</li>
</ul>
</li>
<li>Lo vemos en un toque, pero el resultado más fuerte es que si una expresión es cerrada y bien tipada eventualmente puedo reducir hasta llegar a un valor.</li>
</ul>
<h3 id="evaluación-en-muchos-pasos"><a class="header" href="#evaluación-en-muchos-pasos">Evaluación en muchos pasos</a></h3>
<p>El <strong>juicio de evaluación en muchos pasos</strong> \(\twoheadrightarrow\) es la clausura reflexiva y transitiva de \(\rightarrow\). O sea es la menor relación tal que:</p>
<ol>
<li>Si \(M \rightarrow M'\), entonces \(M \twoheadrightarrow M'\)</li>
<li>\(M \twoheadrightarrow M\) para todo \(M\)</li>
<li>Si \(M \twoheadrightarrow M'\) y \(M' \twoheadrightarrow M''\), entonces \(M \twoheadrightarrow M''\)</li>
</ol>
<p>Por ejemplo, tenemos que:</p>
<p>$$
\ifLC{true}{(\ifLC{false}{false}{true})}{true} \twoheadrightarrow true
$$</p>
<h4 id="propiedades"><a class="header" href="#propiedades">Propiedades</a></h4>
<p>Para el cálculo de expresiones booleanas valen:</p>
<ul>
<li><strong>Lema</strong> (Unicidad de formas normales): Si \(M \twoheadrightarrow U\) y \(M \twoheadrightarrow V\), con \(U, V\) formas normales, entonces \(U = V\)</li>
<li><strong>Lema</strong> (Terminación): Para todo \(M\) existe una forma normal \(N\) tal que \(M \twoheadrightarrow \).
<ul>
<li>esto es bueno porque me aseguro que mi algoritmo de evaluación no tiene loops infinitos</li>
</ul>
</li>
</ul>
<h2 id="semántica-operacional-de-lcb"><a class="header" href="#semántica-operacional-de-lcb">Semántica Operacional de \(\lcb\)</a></h2>
<p>Ya hablamos antes de que en haskell por ejemplo, las funciones también pueden ser resultados de una evaluación (eso de first class citizen, yada yada yada...). Así que por qué no extendemos nuestro conjunto de valores:</p>
<p>$$
V ::= true\ false\ \lf{x}{\sigma}{M}
$$</p>
<p>Vamos a extender nuestro sistema tal que valgan los lemas previos, pero además valga el siguiente resultado:</p>
<div id="admonition-teorema" class="admonition admonish-abstract">
<div class="admonition-title">
<p>Teorema</p>
<p><a class="admonition-anchor-link" href="lambda_calc_booleano.html#admonition-teorema"></a></p>
</div>
<div>
<p>Para todo término bien tipado y cerrado de tipo:</p>
<ul>
<li>\(Bool\) evalúa, en cero o más pasos, a \(true, false\).</li>
<li>\(\sigma \rightarrow \tau\) evalúa, en cero o más pasos, a \(\lf{x}{\sigma}{M}\), para alguna variable \(x\) y algún término \(M\)
<ul>
<li>en castellano: si tipa como una función eventualmente lo puedo reducir a la forma de una lambda con una variable y un término</li>
</ul>
</li>
</ul>
</div>
</div>
<h3 id="juicio-de-evaluación-en-un-paso-1"><a class="header" href="#juicio-de-evaluación-en-un-paso-1">Juicio de evaluación en un paso</a></h3>
<ul>
<li>Primero, una regla que me haga reducir lo más que pueda la "función" que quiero evaluar:</li>
</ul>
<p>$$
\frac{M_1 \rightarrow M_1'}{\apply{M_1}{M_2} \rightarrow \apply{M_1'}{M_2}} (E-App1 / \mu)
$$</p>
<ul>
<li>Segundo, una regla que me haga reducir lo más que pueda al argumento:</li>
</ul>
<p>$$
\frac{M_2 \rightarrow M_2'}{\apply{(\lf{x}{\sigma}{M})}{M_2} \rightarrow \apply{(\lf{x}{\sigma}{M})}{M_2'}} (E-App1 / v)
$$</p>
<ul>
<li>Por último, una regla que se encargue del reemplazo de la evaluación</li>
</ul>
<p>$$
\frac{}{\apply{(\lf{x}{\sigma}{M})}{V} \rightarrow M \{x \leftarrow V\}} (E-AppAbs / \beta)
$$</p>
<ul>
<li>Esto último quiere decir agarrar la función lambda, y reemplazar sintácticamente las ocurrencias de \(x\) por \(V\)
<ul>
<li>sustituyo únicamente las ocurrencias <strong>libres</strong> de \(x\)</li>
<li>le da semántica a la aplicación de funciones</li>
<li>hay que tener cuidado con los ligadores de variable (los \(\lambda x\))</li>
</ul>
</li>
</ul>
<p>Podemos dar una definición basada en la sintaxis:</p>
<p>$$
\begin{align}
x \{x \leftarrow N\} &amp;\stackrel{def}{=} N \\
a \{x \leftarrow N\} &amp;\stackrel{def}{=} a \text{si a } \notin \{true, false\} \cup \mathcal{X} \setminus \{x\} \\
\ifLC{M}{P}{Q} \{x \leftarrow N\} &amp;\stackrel{def}{=} \ifLC{M\{x \leftarrow N\}}{P\{x \leftarrow N\}}{Q\{x \leftarrow N\}} \\
(\apply{M_1}{M_2}) \{x \leftarrow N\} &amp;\stackrel{def}{=} \apply{M_1\{x \leftarrow N\}}{M_2\{x \leftarrow N\}} \\
\lf{y}{\sigma}{M} \{x \leftarrow N\} &amp;\stackrel{def}{=} ? \\
\end{align}
$$</p>
<p>Y ese último? Imaginemos el caso de la sustitución:</p>
<p>$$
\lf{z}{\sigma}{x} \{x \leftarrow N\} \stackrel{def}{=} \lf{z}{\sigma}{z}
$$</p>
<p>La convertimos de la función constante en la función identidad! Pero bueno, a
priori no importa qué nombre tenga la variable ligada, no? Entonces, lo que
podemos hacer es renombrar (o asumir que se hizo el renombre para estas
reglas), de manera tal que la variable que se liga en la función lambda <strong>no
ocurre libre</strong> en \(N\). De ser así la regla nos queda:</p>
<p>$$
\lf{y}{\sigma}{M} \{x \leftarrow N\} \stackrel{def}{=} \lf{y}{\sigma}{M\{x \leftarrow N\}}\ \ x \neq y, y \notin FV(N) \\
$$</p>
<p>Para formalizar esto aparece el concepto de \(\alpha\)-equivalencia. Dos
términos son \(\alpha\)-equivalentes si <strong>únicamente difieren en el nombre de
sus variables ligadas</strong>. Es una relación de equivalencia.</p>
<div id="admonition-algunos-ejemplos" class="admonition admonish-example">
<div class="admonition-title">
<p>Algunos ejemplos</p>
<p><a class="admonition-anchor-link" href="lambda_calc_booleano.html#admonition-algunos-ejemplos"></a></p>
</div>
<div>
<ul>
<li>\(\lf{x}{Bool}{x} =_{\alpha} \lf{y}{Bool}{y}\)</li>
<li>\(\lf{x}{Bool}{y} =_{\alpha} \lf{z}{Bool}{y}\)
<ul>
<li>acá \(y\) es variable libre en ambos casos</li>
</ul>
</li>
<li>\(\lf{x}{Bool}{y} \neq_{\alpha} \lf{x}{Bool}{z}\)
<ul>
<li>acá tanto \(y\) como \(z\) son variables libres y son distintas en cada término.</li>
</ul>
</li>
<li>\(\lf{x}{Bool}{\lf{x}{Bool}{x}} \neq_{\alpha} \lf{y}{Bool}{\lf{x}{Bool}{y}}\)
<ul>
<li>acá la lambda interna tiene en su subtérmino a la \(x\) ligada, mientras que del lado derecho no.</li>
</ul>
</li>
</ul>
<p>Llevado a la práctica, esto quiere decir que mientras hagamos las reducciones,
podemos tener que hacer el reemplazo por un término \(\alpha\)-equivalente y
después aplicar la sustitución.</p>
</div>
</div>
<h2 id="estado-de-error"><a class="header" href="#estado-de-error">Estado de error</a></h2>
<ul>
<li>Es un estado (término) que <strong>no es</strong> un valor, pero en el que la evaluación está <strong>trabada</strong>.</li>
<li>Representa un estado en el cual el sistema de runtime en una implementación real generaría una excepción</li>
<li>Ejemplos:
<ul>
<li>\(\ifLC{x}{M}{N}\)
<ul>
<li>obs: no es cerrado</li>
</ul>
</li>
<li>\(\apply{true}{M}\)
<ul>
<li>obs: no es tipable</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="objetivo-de-un-sistema-de-tipos"><a class="header" href="#objetivo-de-un-sistema-de-tipos">Objetivo de un sistema de tipos</a></h2>
<p>Queremos garantizar la <strong>ausencia</strong> de estados de error. Decimos que un término
<strong>termina</strong> o que es <strong>fuertemente normalizante</strong> si no hay cadenas de
reducción infinitas a partir de él.</p>
<div id="admonition-teorema-1" class="admonition admonish-note">
<div class="admonition-title">
<p>Teorema</p>
<p><a class="admonition-anchor-link" href="lambda_calc_booleano.html#admonition-teorema-1"></a></p>
</div>
<div>
<ul>
<li>Todo término bien tipado termina</li>
<li>Si un término cerrado está bien tipado, entonces evalúa a un valor</li>
</ul>
</div>
</div>
<p>Tenemos algunas propiedades que nos garantizan este teorema:</p>
<ul>
<li>Progreso: Si \(M\) es cerrado y bien tipado, entonces:
<ul>
<li>\(M\) es un valor</li>
<li>o bien existe \(M'\) tal que \(M \rightarrow M'\) (o sea no se traba si los términos son cerrados y bien tipados, y no son valores)</li>
</ul>
</li>
<li>Preservación (de tipo): Si \(\hastype{\Gamma}{M}{\sigma}\) y \(M \rightarrow N\), entonces \(\hastype{\Gamma}{N}{\sigma}\) (o sea que la reducción/evaluación preserva tipos).</li>
</ul>
<blockquote>
<p><strong>Observación</strong>: parto de progreso. O bien es un valor, o tengo el término al
que reducir. Luego por preservación de tipos, aplicar la reducción nos dice
que el nuevo término está bien tipado, y sigue siendo cerrado.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>$$
\newcommand{\lcb}{\lambda^b}
\newcommand{\lce}{\lambda^{bn}}
\newcommand{\lcr}{\lambda^{\dots n}}
\newcommand{\lcu}{\lambda^{bnu}}
\newcommand{\lclet}{\lambda^{\dots let}}
\newcommand{\ifLC}[3]{if\  {#1}\  then\  {#2}\  else\  {#3}}
\newcommand{\lf}[3]{\lambda{#1}:\ {#2}.{#3}}
\newcommand{\apply}[2]{{#1}\ {#2}}
\newcommand{\hastype}[3]{{#1} \triangleright {#2}: {#3}}
\newcommand{\tzero}[1]{\frac{}{\hastype{\Gamma}{0}{Nat}}  (T-Zero)}
\newcommand{\tsucc}[2]{\frac{\hastype{#1}{#2}{Nat}}{\hastype{\Gamma}{succ(M)}{Nat}}  (T-Succ)}
\newcommand{\tpred}[2]{\frac{\hastype{#1}{#2}{Nat}}{\hastype{\Gamma}{pred(M)}{Nat}}  (T-Pred)}
\newcommand{\tiszero}[2]{\frac{\hastype{#1}{#2}{Nat}}{\hastype{\Gamma}{iszero(M)}{Bool}}  (T-IsZero)}
\newcommand{\esucc}[2]{\frac{#1 \rightarrow #2}{succ(#1) \rightarrow succ(#2)} (E-Succ)}
\newcommand{\epredzero}{\frac{}{pred(0) \rightarrow 0} (E-PredZero)}
\newcommand{\epredsucc}[1]{\frac{}{pred(#1 + 1) \rightarrow #1} (E-PredSucc)}
\newcommand{\epred}[2]{\frac{#1 \rightarrow #2}{pred(#1) \rightarrow pred(#2)} (E-Pred)}
\newcommand{\eiszerozero}{\frac{}{iszero(0) \rightarrow true} (E-IsZeroZero)}
\newcommand{\eiszerosucc}{\frac{}{iszero(n + 1) \rightarrow false} (E-IsZeroSucc)}
\newcommand{\eiszero}[2]{\frac{#1 \rightarrow #2}{iszero(#1) \rightarrow iszero(#2)} (E-IsZero)}
$$</p>
<h1 id="cálculo-lambda-tipado-extendido-lce"><a class="header" href="#cálculo-lambda-tipado-extendido-lce">Cálculo Lambda Tipado Extendido \(\lce\)</a></h1>
<p>Idea: extendamos \(lcb\) para agregar los números naturales y así darle mayor utilidad.</p>
<blockquote>
<p>Nota: esta idea de extender el lenguaje es interesante más allá de lo
teórico, en la práctica si uno quiere agregar un feature a un lenguaje tiene
que considerar qué pasos son necesarios para extenderlo.</p>
</blockquote>
<h2 id="tipos-y-términos-de-lce"><a class="header" href="#tipos-y-términos-de-lce">Tipos y Términos de \(\lce\)</a></h2>
<p>Los tipos son:</p>
<p>$$
\sigma ::= Bool\ Nat\ \sigma \rightarrow \rho
$$</p>
<p>Y los términos son:</p>
<p>$$
M ::= \dots | 0 | succ(M) | pred(M) | iszero(M)
$$</p>
<p>donde tengo los términos del \(lcb\) usual más los aquí definidos:</p>
<ul>
<li>\(succ(M)\): evaluar \(M\) hasta que de un número e incrementarlo.</li>
<li>\(pred(M)\): evaluar \(M\) hasta que de un número y decrementarlo.</li>
<li>\(iszero(M)\): evaluar \(M\) hasta que de un número y luego devolver \(true / false\) según sea cero o no.</li>
</ul>
<h2 id="reglas-de-tipado-de-lce"><a class="header" href="#reglas-de-tipado-de-lce">Reglas de tipado de \(lce\)</a></h2>
<p>Junto con las reglas y axiomas previamente definidas para \(lcb\), se le suman:</p>
<p>$$
\tzero{\Gamma}
$$</p>
<p>$$
\tsucc{\Gamma}{M}
$$</p>
<p>$$
\tpred{\Gamma}{M}
$$</p>
<p>$$
\tiszero{\Gamma}{M}
$$</p>
<h2 id="valores-lce"><a class="header" href="#valores-lce">Valores \(\lce\)</a></h2>
<p>Valores:</p>
<p>$$
V ::= \dots |\ n\ \text{ donde n abrevia } succ^n(0)
$$</p>
<p>Esto ya nos da una idea de que si tengo un \(succ(M)\) voy a querer reducir lo de adentro tanto como pueda</p>
<h2 id="juicio-de-evaluación-en-un-paso-2"><a class="header" href="#juicio-de-evaluación-en-un-paso-2">Juicio de evaluación en un paso</a></h2>
<p>Ahora le damos la semántica. Igual que para el tipado, usamos las mismas reglas que antes sumando:</p>
<ul>
<li>Para succ y pred:</li>
</ul>
<p>$$
\esucc{M_1}{M_1'}
$$</p>
<p>$$
\epredzero
$$</p>
<p>$$
\epredsucc{n}
$$</p>
<p>$$
\epred{M_1}{M_1'}
$$</p>
<ul>
<li>Para iszero:</li>
</ul>
<p>$$
\eiszerozero
$$</p>
<p>$$
\eiszerosucc
$$</p>
<p>$$
\eiszero{M_1}{M_1'}
$$</p>
<blockquote>
<p>Algunas observaciones:</p>
<ul>
<li>Tanto \(E-Succ\) y \(E-Pred\) intentan reducir el argumento hasta llevarlo a un valor</li>
<li>pred además reduce cuando tiene adentro un succ (a pesar de estar en forma normal)</li>
<li>iszero reduce hasta tener un valor y después hace el chequeo</li>
</ul>
</blockquote>
<h1 id="cálculo-lambda-tipado-extendido-lcr"><a class="header" href="#cálculo-lambda-tipado-extendido-lcr">Cálculo Lambda Tipado Extendido \(\lcr\)</a></h1>
<h2 id="tipos-1"><a class="header" href="#tipos-1">Tipos</a></h2>
<p>Podemos pensar a los registros como un struct de C ponele. Incluso más simple,
es un conjunto de tuplas <strong>ordenado</strong> (nombre, valor).</p>
<p>Para suponemos que tenemos \(\mathcal{L}\) un conjunto de etiquetas y sumamos el nuevo tipo:</p>
<p>$$
\sigma ::= \dots |\ \{l_i : \sigma_i^{i \in 1 \dots n}\}
$$</p>
<blockquote>
<p>Observación: los registros pueden tener subregistros adentro. Por ejemplo:</p>
</blockquote>
<h2 id="términos"><a class="header" href="#términos">Términos</a></h2>
<p>$$
M ::= \dots |\ \{l_i = M_i^{i \in 1 \dots n}\} |\ M.I
$$</p>
<p>Informalmente hablando:</p>
<ul>
<li>El registro \(\{l_i = M_i^{i \in 1 \dots n}\}\) evalúa a \(\{l_i = V_i^{i \in 1 \dots n}\}\), donde \(V_i\) es el valor al que evalúa \(M_i\), \(i \in 1 \dots n\).</li>
<li>\(M.I\), la proyección, consiste en evaluar \(M\) hasta obtener \(\{l_i = V_i^{i \in 1 \dots n}\}\) y luego proyectar al campo correspondiente.</li>
</ul>
<p>Algunos ejemplos:</p>
<p><img src="./img/ejemplo_lcr.png#center" alt="" /></p>
<ol>
<li>Dado un \(x\) de tipo \(Nat\) y un \(y\) de tipo \(Bool\), genera un registro donde pongo en \(edad\) a \(x\) y en \(esMujer\) a \(y\).</li>
<li>Dado un registro que tiene 2 campos, aplica la proyección del campo \(edad\)</li>
<li>Este último es igual al anterior pero se evalúa en lugar de obtener una función y listo</li>
</ol>
<h2 id="reglas-de-tipado"><a class="header" href="#reglas-de-tipado">Reglas de tipado</a></h2>
<p>$$
\frac{\Gamma \triangleright M_i : \sigma_i\ \text{para cada } i \in 1 \dots n}{\Gamma \triangleright \{l_i = M_i^{i \in 1 \dots n} \} : \{l_i : \sigma_i^{i \in 1 \dots n}\}} (T-RCD)
$$</p>
<p>$$
\frac{\Gamma \triangleright M_i : \{l_i : \sigma_i^{i \in 1 \dots n}\}\ j \in 1 \dots n}{\Gamma \triangleright M.I_j : \sigma_j} (T-Proj)
$$</p>
<h2 id="semántica-operacional-de-lcr"><a class="header" href="#semántica-operacional-de-lcr">Semántica operacional de \(lcr\)</a></h2>
<h3 id="valores-1"><a class="header" href="#valores-1">Valores</a></h3>
<p>Agrego los registros como posibles valores (en tanto todos sus elementos sean valores también):</p>
<p>$$
V ::= \dots |\ \{l_i = V_i^{i \in 1 \dots n}\}
$$</p>
<h3 id="reglas-de-reducción"><a class="header" href="#reglas-de-reducción">Reglas de reducción</a></h3>
<p>La primer regla nos da la idea de que sí o si tengo que reducir en el orden de las etiquetas:</p>
<p>$$
\frac{M_j \rightarrow M_j'}{\{l_i = V_i^{i \in 1 \dots j-1}, l_j = M_j, l_i = M_i^{i \in j+1 \dots n}\} \rightarrow \{l_i = V_i^{i \in 1 \dots j-1}, l_j = M_j', l_i = M_i^{i \in j+1 \dots n}\}} (E-RCD)
$$</p>
<p>Luego tenemos las reglas para la proyección:</p>
<p>$$
\frac{j \in 1 \dots n}{\{l_i = V_i^{i \in 1 \dots n}\}.l_j \rightarrow V_j} (E-ProjRCD)
$$</p>
<p>$$
\frac{M \rightarrow M'}{M.I \rightarrow M'.I} (E-ProjRCD)
$$</p>
<p>O sea que primero reduzco antes de proyectar, y reduzco en el orden de las
etiquetas. Una vez que llegué a una expresión de registro en forma normal,
recién ahí hago el reemplazo por el valor correspondiente a la etiqueta.</p>
<h1 id="cálculo-lambda-tipado-extendido-lcu"><a class="header" href="#cálculo-lambda-tipado-extendido-lcu">Cálculo Lambda Tipado Extendido \(\lcu\)</a></h1>
<p>Vamos a agregar un nuevo tipo, que se va a comportar similar a lo que es el void en C o C++. A este tipo lo vamos a llamar \(Unit\). No nos importa mucho qué retorna.</p>
<h2 id="tipos-y-términos-de-lcu"><a class="header" href="#tipos-y-términos-de-lcu">Tipos y términos de \(\lcu\)</a></h2>
<p>$$
\sigma ::= Bool\ |\ Nat\ |\ \textbf{Unit}\ |\ \sigma \rightarrow \rho
$$</p>
<p>$$
M ::= \dots\ |\ unit
$$</p>
<h2 id="reglas-de-tipado-1"><a class="header" href="#reglas-de-tipado-1">Reglas de tipado</a></h2>
<p>Se agrega un axioma de tipado:</p>
<p>$$
\frac{}{\hastype{\Gamma}{unit}{Unit}}
$$</p>
<blockquote>
<p>Observaciones:</p>
<ul>
<li>no se agregan reglas de evaluación nuevas</li>
<li>Se extiende el conjunto de valores \(V\) con \(unit\):
$$
V ::= \dots\ |\ unit
$$</li>
</ul>
</blockquote>
<h2 id="utilidad-de-unit"><a class="header" href="#utilidad-de-unit">Utilidad de Unit</a></h2>
<ul>
<li>El principal uso es en lenguajes que tienen side effects.</li>
<li>En dichos lenguajes es útil poder evaluar varias expresiones secuencialmente. Entonces definimos:</li>
</ul>
<p>$$
M_1;M_2 \stackrel{def}{=} \apply{(\lf{x}{Unit}{M_2})}{M_1}\ \ \ x \notin FV(M_2)
$$</p>
<ul>
<li>La evaluación de \(M_1;M_2\) consiste en nprimero evaluar \(M_1\) y luego \(M_2\).</li>
<li>Bajo esta definición, el comportamiento se da con las reglas de evaluación ya existentes.</li>
</ul>
<blockquote>
<p><em>Obs</em>: por ahora nuestro lenguaje no tiene side effects, ya vamos a llegar a eso.</p>
</blockquote>
<h1 id="cálculo-lambda-tipado-extendido-lclet"><a class="header" href="#cálculo-lambda-tipado-extendido-lclet">Cálculo Lambda Tipado Extendido \(\lclet\)</a></h1>
<p>En este caso, vamos a agregar una feature que no introduce tipos, y tampoco
introduce mecanismos de ejecución necesariamente pero si aporta legibilidad. Es
el equivalente en cálculo lambda del <code>f = ... where ...</code> de haskell.</p>
<h2 id="términos-1"><a class="header" href="#términos-1">Términos</a></h2>
<p>$$
M ::= \dots\ |\ let\ x : \sigma = M\ in\ N
$$</p>
<p>La idea es evaluar \(M\) hasta un valor \(V\), ligamos \(x\) a \(V\) y evaluamos \(N\). Algunos ejemplos:</p>
<ul>
<li><code>let x: Nat = 2 in succ(x)</code></li>
<li><code>pred (let x: Nat = 2 in x)</code></li>
<li><code>let f: Nat -&gt; Nat = \x: Nat.succ(n) in f(f(0))</code></li>
<li><code>let x: Nat = 2 in let x: Nat = 3 in x</code></li>
</ul>
<h2 id="tipado"><a class="header" href="#tipado">Tipado</a></h2>
<p>Si bien no agregamos tipos, si tenemos una regla de tipado:</p>
<p>$$
\frac{\hastype{\Gamma}{M}{\sigma_1}\ \ \ \hastype{\Gamma,\ x:\sigma_1}{N}{\sigma_2}}{\hastype{\Gamma}{let\ x: \sigma_1 = M\ in\ N}{\sigma_2}} (T-Let)
$$</p>
<blockquote>
<p><strong>Obs</strong>: la regla tiene un aire a \(T-Abs\)</p>
</blockquote>
<h2 id="semántica-operacional-de-lclet"><a class="header" href="#semántica-operacional-de-lclet">Semántica operacional de \(\lclet\)</a></h2>
<p>Tenemos 2 reglas, una para reducir y otra cuando llego a un valor:</p>
<p>$$
\frac{M_1 \rightarrow M_1'}{let\ x: \sigma = M_1\ in\ M_2 \rightarrow let\ x: \sigma = M_1'\ in\ M_2} (E-Let)
$$</p>
<p>$$
\frac{}{let\ x: \sigma = V_1\ in\ M_2 \rightarrow \apply{M_2}{\{x \leftarrow V_1\}}} (E-LetV)
$$</p>
<h2 id="interpretando-el-let"><a class="header" href="#interpretando-el-let">Interpretando el <code>let</code></a></h2>
<p>En una expresión como <code>let x: Nat = 2 in M</code>:</p>
<ul>
<li>x se declara con el valor 2</li>
<li>x es inalterado a lo largo de la evaluación de M</li>
<li>en este sentido x es <strong>inmutable</strong>. No hay operación de asignación</li>
</ul>
<p>Lo siguiente es agregar variables <strong>mutables</strong> (casi que estamos saliendo del terreno del lenguaje funcional y metiéndonos en el terreno del lenguaje mutable)</p>
<h1 id="cálculo-lambda-con-variables-mutables"><a class="header" href="#cálculo-lambda-con-variables-mutables">Cálculo Lambda con variables mutables</a></h1>
<p>Vamos a agregar algunas operaciones básicas:</p>
<ul>
<li>Reserva de memoria (allocation): \(ref M\) genera una referencia fresca cuyo contenido es el valor de \(M\).</li>
<li>Desreferenciación (lectura): \(!x\) sigue la referencia \(x\) y retorna su contenido.</li>
<li>Asignación: \(x := M\) almacena en la referencia \(x\) el valor de \(M\).</li>
</ul>
<div id="admonition-algunos-ejemplos" class="admonition admonish-example">
<div class="admonition-title">
<p>Algunos Ejemplos</p>
<p><a class="admonition-anchor-link" href="lambda_calc_extendido.html#admonition-algunos-ejemplos"></a></p>
</div>
<div>
<p>(Nota: se omiten los tipos de las expreciones para facilitar la lectura, perdemos algo de formalismo. Sepan comprender)</p>
<ul>
<li><code>let x = ref 2 in !x</code> evalúa a 2</li>
<li><code>let x = ref 2 in (\_: Unit.!x) (x := succ(!x))</code> evalúa a 3 (es lo mismo que
hacer <code>x := succ(!x); !x</code>)</li>
<li><code>let x = 2 in x</code> evalúa a 2</li>
<li><code>let x = ref 2 in x</code> a qué evalúa? A priori no sabemos (todavía no vimos qué
devuelve un <code>ref 2</code>)</li>
<li><code>let x = ref 2 in let y = x in (\_: Unit.!x) (y := succ(!y))</code> evalúa a 3.
Primero reemplaza el y por la referencia, y después es igual al segundo
ejemplo. Obtuve en este caso un alias a la celda de memoria.</li>
</ul>
<p><strong>Obs</strong>: x sigue <strong>siendo inmutable</strong> pero en los primeros 2 casos lo que es inmutable es la referencia a la memoria, no su contenido.</p>
</div>
</div>
<h2 id="comandos"><a class="header" href="#comandos">Comandos</a></h2>
<p>Pregunta: el término <code>let x = ref 2 in x := succ(!x)</code>, a qué evalúa? En la operación de asignación sólo interesa el efecto que tiene, por lo tanto la definimos como que evalúa a \(unit\). Esto es lo que conocemos como <strong>comando</strong></p>
<h2 id="formalizando"><a class="header" href="#formalizando">Formalizando</a></h2>
<h3 id="expresiones-de-tipos-1"><a class="header" href="#expresiones-de-tipos-1">Expresiones de tipos</a></h3>
<div style="float:right;margin-left:2rem;margin-bottom:1rem;margin-top:-6rem;width:330px">
<div id="admonition-achievement-unlocked" class="admonition admonish-success">
<div class="admonition-title">
<p>Achievement Unlocked</p>
<p><a class="admonition-anchor-link" href="lambda_calc_extendido.html#admonition-achievement-unlocked"></a></p>
</div>
<div>
<p>Wow, ya desbloqueamos los punteros a funciones!</p>
<p><img src="./img/function_pointer.png" alt="" /></p>
</div>
</div>
</div>
<p>\(Ref \sigma\) va a ser el tipo de las referencias a valores de tipo \(\sigma\). O sea \(Ref (Bool \rightarrow Nat)\) es el tipo de las referencias a funciones de \(Bool\) en \(Nat\).</p>
<p>$$
\sigma ::= Bool\ |\ Nat\ |\ \sigma \rightarrow \tau\ |\ Unit\ |\ Ref \sigma
$$</p>
<h3 id="términos-2"><a class="header" href="#términos-2">Términos</a></h3>
<p>$$
M ::= \dots\ |\ ref\ M\ |\ !M\ |\ M := N\ |\ l
$$</p>
<div style="width:330px">
<blockquote>
<p>Nota: por ahora ignorar el último término pero es el que corresponde a las
referencias propiamente dichas (idealemente no se exponen al "programador"
pero en la maquinaria lógica hay que tenerlas en consideración)</p>
</blockquote>
</div>
<h3 id="reglas-de-tipado-2"><a class="header" href="#reglas-de-tipado-2">Reglas de tipado</a></h3>
<p>El tipo de la referencia es una referencia al tipo del término:</p>
<p>$$
\frac{\hastype{\Gamma}{M_1}{\sigma}}{\hastype{\Gamma}{ref\ M_1}{Ref\ \sigma}} (T-Ref)
$$</p>
<p>El tipo de la desreferencia es el tipo interno de la referencia:</p>
<p>$$
\frac{\hastype{\Gamma}{M_1}{Ref\ \sigma}}{\hastype{\Gamma}{!M_1}{\sigma}} (T-DeRef)
$$</p>
<p>Por último, el tipo de una asignación es siempre unit y además el tipo de la variabla tiene que ser una referencia del tipo que se está asignando:</p>
<p>$$
\frac{\hastype{\Gamma}{M_1}{Ref\ \sigma_1}\ \ \hastype{\Gamma}{M_2}{\sigma_1}}{\hastype{\Gamma}{M_1 := M_2}{Unit}} (T-Assign)
$$</p>
<h3 id="semántica"><a class="header" href="#semántica">Semántica</a></h3>
<p>Al intentar formalizar la semántica operacional surgen 2 preguntas:</p>
<ul>
<li>Cuáles son los valores de tipo \(Ref \sigma\)</li>
<li>Cómo modelo la evaluación del término \(ref M\)</li>
</ul>
<p>Para poder responder esto tenemos que responder antes a la pregunta: <em>qué es una referencia</em> (rta: es una abstracción de una porción de memoria que se encuentra en uso).</p>
<p>Entonces, vamos a tener que modelar la memoria!</p>
<ul>
<li>Usamos direcciones simbólicas o "locations" \(l, l_i \in \mathcal{L}\) para representar referencias.</li>
<li>La memoria o store va a ser una función parcial de direcciones a valores (a.k.a un diccionario).</li>
<li>Usamos \(\mu, \mu'\) para referirnos a stores</li>
<li>Notación:
<ul>
<li>\(\mu[l \rightarrow V]\) es el store resultante de pisar \(\mu(l)\) con \(V\).</li>
<li>\(\mu \oplus (l \rightarrow V)\) es el store extendido resultante de ampliar \(\mu\) con una nueva asociación \(l \rightarrow V\) (asumiendo \(l \notin Dom(\mu)\), porque si no hubiese usado la sintáxis de arriba).</li>
</ul>
</li>
<li>Cambia también ligeramente la sintaxis de los juicios de valor:</li>
</ul>
<p>$$
M\ |\ \mu \rightarrow M'\ |\ \mu'
$$</p>
<div id="admonition-juicios-de-tipado" class="admonition admonish-note">
<div class="admonition-title">
<p>juicios de tipado</p>
<p><a class="admonition-anchor-link" href="lambda_calc_extendido.html#admonition-juicios-de-tipado"></a></p>
</div>
<div>
<p>Agregar las location nos obliga a agregar nuevas reglas de tipado. En particular, cuál sería el tipo de \(\hastype{\Gamma}{l}{?}\)?</p>
<ul>
<li>Depende de qué valores se almacenen en \(l\)</li>
<li>Tengo un problema similar al de las variables libres</li>
<li>Tenemos que introducir entonces un <strong>contexto de tipado</strong> para direcciones \(\Sigma\)</li>
</ul>
<p>Nuevo formato de los juicios de tipado:</p>
<p>$$
\hastype{\Gamma | \Sigma}{M}{\sigma}
$$</p>
<p>Y Nueva regla de tipado:</p>
<p>$$
\frac{\Sigma(l) = \sigma}{\hastype{\Gamma | \Sigma}{l}{Ref \sigma}} (T-Loc)
$$</p>
</div>
</div>
<h4 id="valores-2"><a class="header" href="#valores-2">Valores</a></h4>
<p>Además de los ya existentes, incluimos las direcciones al conjunto de valores:</p>
<p>$$
V ::= \dots\ |\ unit\ |\ \lf{x}{\sigma}{M}\ |\ l
$$</p>
<h4 id="operaciones-de-reducción-en-un-paso"><a class="header" href="#operaciones-de-reducción-en-un-paso">Operaciones de reducción en un paso</a></h4>
<p>Reglas para ref:</p>
<p>$$
\frac{M_1\ |\ \mu \rightarrow M_1'\ |\ \mu' \rightarrow}{(ref\ M_1 | \mu) \rightarrow ref\ M_1' | \mu} (E-RefV)
$$</p>
<p>$$
\frac{l \notin Dom(\mu)}{(ref V\ | \mu) \rightarrow (l | \mu \oplus (l \rightarrow V))} (E-RefV)
$$</p>
<p>Reglas para la desreferenciación:</p>
<p>$$
\frac{M_1 | \mu \rightarrow M_1' | \mu'}{!M_1 | \mu \rightarrow !M_1' | \mu} (E-Deref)
$$</p>
<p>$$
\frac{\mu(l) = V}{!l | \mu \rightarrow V | u} (E-DerefLoc)
$$</p>
<p>Las reglas para la asignación:</p>
<p>Dejo evolucionar el lado de la etiqueta:</p>
<p>$$
\frac{M_1\ |\ \mu \rightarrow M_1'\ |\ \mu'}{M_1 := M_2\ |\ \mu \rightarrow M_1' := M_2\ |\ \mu' } (E-Assign1)
$$</p>
<p>Cuando llegué al valor evalúo lo que se asigna:</p>
<p>$$
\frac{M_2\ |\ \mu \rightarrow M_2'\ |\ \mu'}{V := M_2\ |\ \mu \rightarrow V := M_2'\ |\ \mu' } (E-Assign2)
$$</p>
<p>Por último, la evaluación se reduce a \(unit\),  pero la memoria se modifica:</p>
<p>$$
\frac{}{l := V\ |\ \mu \rightarrow unit\ |\ \mu[l \rightarrow V] } (E-Assign)
$$</p>
<h2 id="revisitando-reglas-de-evaluación-viejas"><a class="header" href="#revisitando-reglas-de-evaluación-viejas">Revisitando reglas de evaluación viejas</a></h2>
<p>Como ahora tenemos el store, tenemos que actualizar todas las reglas previas.
Veamos un par de ejemplos de la aplicación pero en general la regla es la misma
y lo único que hay que reflejar es si el store puede cambiar o no.</p>
<p>$$
\frac{M_1\ |\ \mu \rightarrow M_1'\ |\ \mu'}{\apply{M_1}{M_2}\ |\ \mu \rightarrow \apply{M_1'}{M_2}\ |\ \mu'} (E-App1)
$$</p>
<p>$$
\frac{M_2\ |\ \mu \rightarrow M_2'\ |\ \mu'}{\apply{V_1}{M_2}\ |\ \mu \rightarrow \apply{V_1}{M_2'}\ |\ \mu'} (E-App2)
$$</p>
<p>Notar que para cuando hacemos la aplicación, al ser un reemplazo sintáctico el store no cambia:</p>
<p>$$
\frac{}{\apply{(\lf{x}{\sigma}{M})}{V}\ |\ \mu \rightarrow M \{x \leftarrow V\}\ |\ \mu} (E-AppAbs)
$$</p>
<h2 id="the-last-crusade-corrección-de-sistema-de-tipos"><a class="header" href="#the-last-crusade-corrección-de-sistema-de-tipos">The last crusade: Corrección de sistema de tipos</a></h2>
<p>Como vimos para \(\lcb\), podíamos asegurar dos características que eran:</p>
<ul>
<li>progreso: si \(M\) es cerrado y bien tipado entonces o bien es un valor o
se puede reducir a un término \(M'\)</li>
<li>preservación: si \(M\) es de tipo \(\sigma\) bajo el contexto
\(\Gamma\), y se reduce a otro término \(N\), entonces ese nuevo término
también va a ser de tipo \(\sigma\). O sea que la reducción preserva tipos.</li>
</ul>
<p>Tenemos que poder reformular estas propiedades en el marco del lambda cálculo
tipado con referencias (y registros y otras cosas, aunque lo relevante son las
referencias).</p>
<div id="admonition-primer-intento" class="admonition admonish-warning">
<div class="admonition-title">
<p>Primer intento</p>
<p><a class="admonition-anchor-link" href="lambda_calc_extendido.html#admonition-primer-intento"></a></p>
</div>
<div>
<p>Qué pasa con la siguiente formulación?</p>
<blockquote>
<p>Si \(\hastype{\Gamma | \Sigma}{M}{\sigma}\) y \(M\ |\ \mu \rightarrow M'\ |\ \mu'\) entonces \(\hastype{\Gamma | \Sigma}{M'}{\sigma}\)</p>
</blockquote>
<p>El problema que tenemos con esto es que la semántica puede no respetar los tipos asumidos para las direcciones (o sea \(\sigma\))</p>
<p>Por ejemplo, supongamos que:</p>
<ul>
<li>\(M = !l \)</li>
<li>\(\Gamma = \emptyset \)</li>
<li>\(\Sigma(l) = Nat \)</li>
<li>\(\mu(l) = true \)</li>
</ul>
<p>Esto ya de por si es raro porque significaría que nuestro tipo dice que tenemos
un \(Nat\) pero guardamos un valor booleano. Pero bueno, no está restringido
en lo que enunciamos.</p>
<p>Observar que:</p>
<ul>
<li>\(\hastype{\Gamma | \Sigma}{M}{Nat} \) y</li>
<li>\(M\ |\ \mu \rightarrow true\ |\ \mu \)</li>
<li>pero \(\hastype{\Gamma | \Sigma}{true}{Nat}\) no vale</li>
</ul>
<p>Lo importante es la <strong>coordinación entre el contexto de tipado</strong> \(\Sigma\) <strong>y el valor en el store durante la evaluación</strong> \(\mu\)</p>
</div>
</div>
<h3 id="reformulando-preservación"><a class="header" href="#reformulando-preservación">Reformulando preservación</a></h3>
<p>Tenemos que hablar de compatibilidad / coordinación entre el store y el
contexto de tipado para stores (se podría pensar que "tipamos" los stores).</p>
<p>Para eso intrducimos un nuevo "juicio de tiapdo" para el store:</p>
<p>$$
\Gamma | \Sigma \triangleright \mu \iff
$$</p>
<ul>
<li>\(Dom(\Sigma) = Dom(\mu)\)</li>
<li>\(\hastype{\Gamma | \Sigma}{\mu(l)}{\Sigma(l)} \text{ para todo } l \in Dom(\mu)\)</li>
</ul>
<p>Con esto definido, podemos reformular la propiedad de preservación:</p>
<blockquote>
<p>Si \(\hastype{\Gamma | \Sigma}{M}{\sigma}\) y \(M\ |\ \mu \rightarrow N\ |\ \mu'\) y \(\Gamma | \Sigma \triangleright \mu\) entonces \(\hastype{\Gamma | \Sigma}{N}{\sigma}\)</p>
</blockquote>
<p>Pero de vuelta, tenemos que considerar una cosa más. En el paso de evaluación,
pudo haber cambiado el store. Entonces necesitamos también incluir dicha
consideración.</p>
<blockquote>
<p>Si</p>
<ul>
<li>\(\hastype{\Gamma | \Sigma}{M}{\sigma}\)</li>
<li>\(M\ |\ \mu \rightarrow N\ |\ \mu'\)</li>
<li>\(\Gamma | \Sigma \triangleright \mu\)</li>
</ul>
<p>entonces existe un \(\Sigma' \subseteq \Sigma\) tal que:</p>
<ul>
<li>\(\hastype{\Gamma | \Sigma'}{N}{\sigma}\)</li>
<li>\(\Gamma\ |\ \Sigma' \triangleright \mu'\)</li>
</ul>
</blockquote>
<h3 id="reformulando-progreso"><a class="header" href="#reformulando-progreso">Reformulando progreso</a></h3>
<p>Si \(M\) es cerrado y bien tipado (es decir, \(\hastype{\emptyset | \Sigma}{M}{\sigma}\)) para algún \Sigma,\sigma) entonces:</p>
<ul>
<li>\(M\) es un valor (o sea el store quedó fijo)</li>
<li>o bien para cualquier store \(\mu\) tal que \(\emptyset | \Sigma \rightarrow \mu\), existe \(M'\) y \(\mu'\) tal que \(M\ |\ \mu \rightarrow M'\ |\ \mu'\) (o sea que puedo haber cambiado el store)</li>
</ul>
<h3 id="ejemplos"><a class="header" href="#ejemplos">Ejemplos</a></h3>
<p><img src="./img/eval_example_with_references.png#center" alt="" /></p>
<p><img src="./img/eval_example_with_references_2.png#center" alt="" /></p>
<p><img src="./img/eval_example_with_references_3.png#center" alt="" /></p>
<div id="admonition-opa-opa-opa" class="admonition admonish-warning">
<div class="admonition-title">
<p>Opa Opa Opa...</p>
<p><a class="admonition-anchor-link" href="lambda_calc_extendido.html#admonition-opa-opa-opa"></a></p>
</div>
<div>
<p>En ese último ejemplo me quedo en un loop infinito de evaluaciones. En
\(\lambda^{bnr}\) (lambda cálculo con booleanos, naturales y referencias) no
todo término cerrado y bien tipado termina.</p>
</div>
</div>
<h2 id="recursión"><a class="header" href="#recursión">Recursión</a></h2>
<p>Algo común en funcional es tener definiciones de funciones recursivas.
Intentemos extender el \(\lambda\)-cálculo para soportarlo. Para eso tenemos
que introducir un nuevo término:</p>
<p>$$
M ::= \dots\ |\ fix\ M
$$</p>
<p>Y si bien no se precisan nuevos tipos, si se necesita una regla de tipado nueva:</p>
<p>$$
\frac{\hastype{\Gamma}{M}{\sigma_1 \rightarrow \sigma_1}}{\hastype{\Gamma}{fix\ M}{\sigma_1}} (T-Fix)
$$</p>
<blockquote>
<p>Obs: sólo le puedo pasar funciones cuyo dominio y codominio coincidan, y \(fix M\) tiene el mismo tipo que el codominio.</p>
</blockquote>
<h3 id="semántica-operacional"><a class="header" href="#semántica-operacional">Semántica operacional</a></h3>
<p>No hay valores nuevos pero se suman 2 reglas de evaluación.</p>
<blockquote>
<p>Nota: si bien es posible, acá dejamos de considerar la parte de cálculo
lambda con efectos y referencias</p>
</blockquote>
<p>Primero reduzco todo lo que pueda lo de adentro del fix</p>
<p>$$
\frac{M_1 \rightarrow M_1'}{fix\ M_1 \rightarrow fix\ M_1'} (E-Fix)
$$</p>
<p>Luego hago el reemplazo como cuando hacía la evaluación de una lambda. Pero ojo, <strong>lo reemplazo por el fix entero</strong>.</p>
<p>$$
\frac{}{fix\ \lf{x}{\sigma}{M} \rightarrow M \{x \leftarrow fix\ \lf{x}{\sigma}{M}\}} (E-FixBeta)
$$</p>
<h3 id="mecanismo-de-escape"><a class="header" href="#mecanismo-de-escape">Mecanismo de escape</a></h3>
<p>Dada la semántica operacional de \(fix\), se va a evaluar tanto como sea
necesario. Pero a priori puede seguir de forma infinita. Entonces necesitamos
alguna herramienta que nos de control respecto a cuándo cortar. Una posibilidad
es usar un if-else-then. Veamos un ejemplo de eso:</p>
<p>Sea M el término:</p>
<pre><code>\f: Nat -&gt; Nat. 
    \x: Nat. if iszero(x) then 1 else x * f(pred(x))
</code></pre>
<p>en</p>
<pre><code>let fact = fix M in fact 3
</code></pre>
<p>Veamos cómo se reduce:</p>
<pre><code>let fact = fix M in fact 3
let fact = \x: Nat. if iszero(x) then 1 else x * (fix M)(pred(x)) in fact 3
\x: Nat. if iszero(x) then 1 else x * (fix M)(pred(x)) 3
if iszero(3) then 1 else 3 * (fix M)(pred(3))
3 * (\x: Nat. if iszero(x) then 1 else x * (fix M)(pred(x)))(pred(3))
3 * (\x: Nat. if iszero(x) then 1 else x * (fix M)(pred(x)))(2)
3 * (if iszero(2) then 1 else 2 * (fix M)(pred(2))))
3 * (2 * (fix M)(pred(2)))
3 * (2 * (\x: Nat. if iszero(x) then 1 else x * (fix M)(pred(x)))(pred(2)))
3 * (2 * (\x: Nat. if iszero(x) then 1 else x * (fix M)(pred(x)))(1))
3 * (2 * iszero(1) then 1 else 1 * (fix M)(pred(1)))
3 * (2 * 1 * (fix M)(pred(1)))
3 * (2 * 1 * (fix M)(0))
3 * (2 * 1 * (\x: Nat. if iszero(x) then 1 else x * (fix M)(pred(x)))(0))
3 * (2 * 1 * if iszero(0) then 1 else 0 * (fix M)(pred(0)))
3 * (2 * 1 * 1)
...
6
</code></pre>
<p>Obs: el término M tiene tipo <code>(Nat-&gt;Nat) -&gt; (Nat-&gt;Nat)</code>, con lo cual el fix va
a ser de tipo <code>Nat-&gt;Nat</code>. De alguna forma podemos pensar que la f sirve para
llamar a la recursión de la función y la x es el parámetro del llamado actual.</p>
<h3 id="más-ejemplos"><a class="header" href="#más-ejemplos">Más ejemplos</a></h3>
<ul>
<li>Podemos definir funciones parciales:</li>
</ul>
<pre><code>fix (\x: Nat.succ x) 
-&gt; succ (fix (\x: Nat.succ x)) 
-&gt; succ (succ (fix (\x: Nat.succ x)))
-&gt; ...
</code></pre>
<h2 id="letrec"><a class="header" href="#letrec">letrec</a></h2>
<p>A modo de sintactic sugar definimos:</p>
<pre><code>letrec f: t -&gt; t = \x : t.M in N
</code></pre>
<p>El letrec se puede re-escribir usando let con:</p>
<pre><code>let f = fix (\f : t -&gt; t. \x: t.M) in N
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>$$
\newcommand{\lft}[2]{\lambda{#1}.{#2}}
\newcommand{\lf}[3]{\lambda{#1}:\ {#2}.{#3}}
\newcommand{\ifLC}[3]{if\  {#1}\  then\  {#2}\  else\  {#3}}
\newcommand{\apply}[2]{{#1}\ {#2}}
\newcommand{\hastype}[3]{{#1} \triangleright {#2}: {#3}}
\newcommand{\inference}[1]{\mathbb{W}(#1)}
$$</p>
<h1 id="inferencia-de-tipos"><a class="header" href="#inferencia-de-tipos">Inferencia de tipos</a></h1>
<p>Queremos resolver el problema de recibir términos sin información de tipos o
con información de tipos parcial en términos tipables. Para eso es necesario
<strong>inferir</strong> la información de tipos que falta.</p>
<p>En lenguajes tipados esto permite obviar algunas declaraciones de tipos (e.g
Haskell, Rust, etc.), esto puede resultar en código más simple de entender
(menos complejidad), y no afecta el tiempo de ejecución porque esto se puede
hacer en tiempo de compilación.</p>
<h2 id="punto-de-partida"><a class="header" href="#punto-de-partida">Punto de partida</a></h2>
<p>Primero vamos a modificar la sintaxis de los términos del \(\lambda\)-cálculo
eliminando toda anotación de tipos (el único lugar donde teníamos era en la
lambda). O sea la función lambda pasa a ser: \(\lft{x}{M}\). A ese conjunto
de términos lo denotamos \(\Lambda\).</p>
<p>Para formalizar esto, vamos a usar la función \(Erase(.):\ \Lambda_{\tau} \rightarrow \Lambda\) que elimina las anotiaciones de tipos. Por ejemplo:</p>
<p>$$
Erase(\lf{x}{Nat}{\lf{f}{Nat\ \rightarrow Nat}{\apply{f}{x}}}) = \lft{x}{\lft{f}{\apply{f}{x}}}
$$</p>
<h2 id="definición-formal-del-problema-de-la-inferencia"><a class="header" href="#definición-formal-del-problema-de-la-inferencia">Definición formal del problema de la inferencia</a></h2>
<p>Dado \(U\) un término sin anotaciones de tipo, encontrar un término con anotaciones de tipos \(M\) tal que:</p>
<ol>
<li>\(\hastype{\Gamma}{M}{\sigma}\) para algún \(\Gamma\) y \(\sigma\), y</li>
<li>\(Erase(M) = U\)</li>
</ol>
<h3 id="ejemplos-1"><a class="header" href="#ejemplos-1">Ejemplos</a></h3>
<ul>
<li>\(U = \lft{x}{succ(x)}\), \(\lf{x}{Nat}{succ(x)}\) (en este caso no hay otra posibilidad)</li>
<li>\(U = \lft{x}{\lft{f}{\apply{f}{x}}}\) tomamos \(M_{\sigma,\tau} = \lf{x}{\sigma}{\lf{f}{\sigma \rightarrow \tau}{\apply{f}{x}}}\) (notar que en este caso hay un \(M_{\sigma,\tau}\) por cada par \(\sigma,\tau\))</li>
<li>Si \(U = \apply{x}{x}\), en principio no tenemos un término \(M\) que satisfaga la propiedad.</li>
</ul>
<div id="admonition-chequeo--inferencia" class="admonition admonish-warning">
<div class="admonition-title">
<p>Chequeo != Inferencia</p>
<p><a class="admonition-anchor-link" href="inferencia_de_tipos.html#admonition-chequeo--inferencia"></a></p>
</div>
<div>
<p>Es importante poder diferenciar un problema de otro. El problema del chequeo de
tipos es que dado un término \(M\) tengo que determinar si existe un contexto
\(\Gamma\) y un tipo \(\sigma\) tales que \(\hastype{\Gamma}{M}{\sigma}\)
es derivable.</p>
<ul>
<li>esto es muuuuuucho más fácil que el problema de inferencia, ya que está todo guiado por sintáxis</li>
<li>de hecho, la forma para chequear eso es seguir la estructura sintáctica para construir una derivación del juicio de tipado.</li>
<li>es escencialmente lo mismo a que ya te den el \(\Gamma\) y el \(\sigma\) y veas si \(\hastype{\Gamma}{M}{\sigma}\) es derivable.</li>
</ul>
</div>
</div>
<h2 id="variables-de-tipo"><a class="header" href="#variables-de-tipo">Variables de tipo</a></h2>
<p>Supongamos que tenemos \(U = \lft{x}{\lft{f}{\apply{f}{x}}}\). Entonces dijimos que para cada \(\sigma\) tengo definido un \(M_{\sigma} = \lf{x}{\sigma}{\lf{f}{\sigma \rightarrow \sigma}{\apply{f}{x}}}\). Y cada uno de esos es una solución posible al problema de la inferencia.</p>
<p>Entonces, estaría bueno tener una forma de agrupar todas esas soluciones en una sola. Para eso, podríamos representar a todas las soluciones con \(\lf{x}{s}{\lf{f}{s \rightarrow s}{\apply{f}{x}}}\</p>
<ul>
<li>\(s\) no es un tipo en si mismo si no que es una variable de tipos.</li>
<li>la expresión no es una solución en si misma, pero la substitución de \(s\)
por cualquier expresióin de tipos si nos da una solución.</li>
</ul>
<h2 id="extensión-de-las-expresiones-de-tipo"><a class="header" href="#extensión-de-las-expresiones-de-tipo">Extensión de las expresiones de tipo</a></h2>
<p>$$
\sigma ::= s\ |\ Nat\ |\ Bool\ |\ \sigma \rightarrow \tau
$$</p>
<ul>
<li>Denotamos con \(\mathcal{V}\) al conjunto de variables de tipo.</li>
<li>Denotamos con \(\mathcal{T}\) al conjunto de tipos definidos como arriba.</li>
</ul>
<h2 id="sustitución-de-tipos"><a class="header" href="#sustitución-de-tipos">Sustitución de tipos</a></h2>
<p>Vamos a definir una función de sustitución que mapea variables de tipo en
expresiones de tipo \(\mathcal{S}: \mathcal{V} \rightarrow \mathcal{T}\).
Sólo nos interesan las \(\mathcal{S}\) tales que \(\{t \in \mathcal{V}\ |\ St \neq t\}\)
es finito (Es un detalle técnico, lo importante es que no queremos que reemplace infinitas variables)</p>
<p>Además, vamos a querer poder aplicar \(S\) a varias cosas:</p>
<ul>
<li>expresiones de tipos (dado \(\sigma\), escribimos \(S\sigma\))</li>
<li>un término cualquiera (dado \(M\) escribimos \(SM\))</li>
<li>un contexto de tipado (dado \(\Gamma = \{x_1: \sigma_1, \dots, x_n: \sigma_n\}\) escribimos \(S\Gamma\) definido como:)</li>
</ul>
<p>$$
S\Gamma = \{x_1: S\sigma_1, \dots, x_n: S\sigma_n\}
$$</p>
<p>Algunas consideraciones extra:</p>
<ul>
<li>Llamamos <strong>soporte de</strong> \(S\) a \(\{t\ |\ St \neq t\}\)</li>
<li>El soporte representa las variables que \(S\) "afecta".</li>
<li>Usamos la notación \(\{\sigma_1/t_1, \dots, \sigma_n/t_n\}\) para la sustitución con soporte \(\{t_1, \dots, t_n\}\)
<ul>
<li>los \(\sigma_i\) es la cosa por la que reemplazo a los Ts</li>
</ul>
</li>
<li>La sustitución con soporte \(\emptyset\) es la sustitución identidad y la notamos \(Id\)</li>
</ul>
<h2 id="juicio-de-tipado-instanciado"><a class="header" href="#juicio-de-tipado-instanciado">Juicio de tipado instanciado</a></h2>
<p>Dado un juicio de tipado original \(\hastype{\Gamma}{M}{\sigma}\), hablamos del juicio de tipado instanciado \(\hastype{\Gamma'}{M'}{\sigma'}\) al resultante de aplicarle una sustitución \(S\) al juicio original (en caso de existir tal \(S\). Esto es equivalente a que existe \(S\) tal que:</p>
<p>$$
S\Gamma \subseteq \Gamma', M' = SM, \sigma' = S\sigma
$$</p>
<blockquote>
<p><strong>Propiedad</strong>: si \(\hastype{\Gamma}{M}{\sigma}\) es derivable, entonces cualquier instancia del mismo juicio de tipado lo es.</p>
</blockquote>
<h2 id="función-de-inferencia-inference"><a class="header" href="#función-de-inferencia-inference">Función de inferencia \(\inference{.}\)</a></h2>
<p>Es una función que dado un término \(U\) sin anotaciones verifica:</p>
<ul>
<li>Corrección: \(\inference{U} = \hastype{\Gamma}{M}{\sigma}\) implica
<ul>
<li>\(Erase(M) = U\)</li>
<li>\(\hastype{\Gamma}{M}{\sigma}\) es derivable</li>
</ul>
</li>
<li>Completitud: Si \(\hastype{\Gamma}{M}{\sigma}\) es derivable y \(Erase(M) = U\), entonces
<ul>
<li>\(\inference{U}\) tiene éxito (si existe lo tiene que encontrar)</li>
<li>produce un juicio \(\hastype{\Gamma'}{M'}{\sigma'}\) tal que \(\hastype{\Gamma}{M}{\sigma}\) es instancia del mismo (se dice que \(\inference{.}\)) <strong>computa un tipo principal</strong>. (capaz no encuentra exactamente el mismo término o al menos va a encontrar algo del que mi juicio original sea instancia. O sea que el algoritmo te va a dar la versión más general)</li>
</ul>
</li>
</ul>
<h3 id="algoritmo-de-inferencia-casos-bases"><a class="header" href="#algoritmo-de-inferencia-casos-bases">Algoritmo de inferencia (casos bases)</a></h3>
<p>$$
\begin{align}
\inference{0} &amp;\stackrel{def}{=} \hastype{\emptyset}{0}{Nat} \\
\inference{true} &amp;\stackrel{def}{=} \hastype{\emptyset}{true}{Bool} \\
\inference{false} &amp;\stackrel{def}{=} \hastype{\emptyset}{false}{Bool} \\
\inference{x} &amp;\stackrel{def}{=} \hastype{\{x: s\}}{x}{s}, x \text{ variable fresca}
\end{align}
$$</p>
<h3 id="algoritmo-de-inferencia-caso-succ"><a class="header" href="#algoritmo-de-inferencia-caso-succ">Algoritmo de inferencia (caso succ)</a></h3>
<p>$$
\inference{succ(U)} \stackrel{def}{=} ?
$$</p>
<ul>
<li>Sea \(\inference{U} = \hastype{\Gamma}{M}{\tau}\) ("aplico hipótesis inductiva")</li>
<li>Tenemos que saber si \(\tau\) puede ser un \(Nat\)</li>
</ul>
<div id="admonition-unificación" class="admonition admonish-info">
<div class="admonition-title">
<p>Unificación</p>
<p><a class="admonition-anchor-link" href="inferencia_de_tipos.html#admonition-unificación"></a></p>
</div>
<div>
<p>Al igual que arriba, me puedo encontrar casos en donde tengo que saber si una
expresión de tipos es compatible o unificable con otra. Dicho proceso implica
determinar si existe una sustitución \(S\) tal que las expresiones de tipos
(ponele que son \(\sigma\) y \(\tau\)) son unificables (o sea \(S\sigma =
S\tau\))</p>
<p>Por ejemplo, el tipo \(s \rightarrow t\) es unificable con \(Nat \rightarrow u\)?</p>
<ul>
<li>puedo armar una sustitución que tome \(s\) y lo transforme en \(Nat\), y agarre \(t\) y lo transforme en \(u\)</li>
<li>en este caso la estructura lo facilita también, pero se puede replicar para otras expresiones</li>
</ul>
</div>
</div>
<h2 id="propiedades-de-sustituciones"><a class="header" href="#propiedades-de-sustituciones">Propiedades de sustituciones</a></h2>
<ul>
<li>La composición de sustituciones es equivalente a la composición de funciones. Ejemplo:</li>
</ul>
<p><img src="./img/sust_composicion.png#center" alt="" /></p>
<ul>
<li>Decimos que \(S = T\) si tienen el mismo soporte y \(St = Tt\) para todo \(t\) del soporte.</li>
<li>la identidad no afecta en la composición</li>
<li>la composición es asociativa</li>
<li>decimos que una sustitución \(S\) es <strong>más general</strong> que \(T\) si existe \(U\) tal que \(T = U \circ S\)
<ul>
<li>\(S\) es más general que \(T\) porque \(T\) se obtiene instanciando \(S\)</li>
<li>Ej: una sustitución que reemplaza \(s\) por \(t \rightarrow t\) es más general que otra que la reemplaza por \(Nat \rightarrow Nat\)</li>
</ul>
</li>
</ul>
<h2 id="unificador"><a class="header" href="#unificador">Unificador</a></h2>
<p>Una <strong>expresión de unificación</strong> es algo de la forma <code>expr1 = expr2</code>. Una sustitución es una solución de un conjunto de ecuaciones de unificación \(\{\sigma_1 = \sigma_1', \dots, \sigma_n = \sigma_n'\}\) si \(S\sigma_1 = S\sigma_1', \dots, S\sigma_n = S\sigma_n'\)</p>
<p>Veamos unos ejemplos:</p>
<ul>
<li>La sustitución \(\{Bool/v, Bool \times Nat/u\}\) es solución de \{v \times Nat \rightarrow Nat = u \rightarrow Nat\}
<ul>
<li>\(\{Bool \times Bool/v, (Bool \times Bool) \times Nat/u\}\) también es solución, pero es un poco más compleja.</li>
<li>\(\{v \times Nat/u\}\) también... y de hecho es más simple... más <strong>GENERAL</strong>.</li>
</ul>
</li>
<li>\(\{Nat \rightarrow s = t \times u\}\) no tiene solución porque no puedo matchear la función con un producto interno.</li>
<li>\(\{u \rightarrow Nat = u\}\) no tiene solución porque cualquier cosa por la que reemplace a \(u\) me queda distinto.</li>
</ul>
<h3 id="unificador-más-general-mgu"><a class="header" href="#unificador-más-general-mgu">Unificador más general (MGU)</a></h3>
<p>Retomemos eso de la solución simple y <strong>más general</strong>. Una sustitución \(S\) es un MGU de \(\{\sigma_1 = \sigma_1', \dots, \sigma_n = \sigma_n'\}\) si:</p>
<ol>
<li>es solución del conjunto de ecuaciones</li>
<li>es más general que cualquier otra solución</li>
</ol>
<p>En el ejemplo anterior \(\{v \times Nat/u\}\) era la MGU.</p>
<h3 id="algoritmo-de-unificación"><a class="header" href="#algoritmo-de-unificación">Algoritmo de unificación</a></h3>
<p>Sabiendo que vale el siguiente teorema:</p>
<blockquote>
<p>Si \(\{\sigma_1 = \sigma_1', \dots, \sigma_n = \sigma_n'\}\) tiene solución, entonces existe MGU y es único salvo por renombre de variables</p>
</blockquote>
<p>Vamos a armar un algoritmo que cumple:</p>
<ul>
<li>entrada:
<ul>
<li>conjunto de ecuaciones de unificación</li>
</ul>
</li>
<li>salida:
<ul>
<li>MGU del conjunto, si tiene solución</li>
<li>falla en caso contrario</li>
</ul>
</li>
</ul>
<h3 id="algoritmo-de-martelli-montanari"><a class="header" href="#algoritmo-de-martelli-montanari">Algoritmo de Martelli-Montanari</a></h3>
<ul>
<li>es no determinístico (defino reglas para aplicar pero no hay un orden específico establecido)</li>
<li>consiste en reglas de simplificación, que simplifican conjuntos de pares de tipos a unificar (goals)</li>
</ul>
<p>$$
G_0 \rightarrow G_1 \rightarrow \dots \rightarrow G_n
$$</p>
<ul>
<li>las secuencias que terminan con el goal vacío son las existosas. El resto
fallan</li>
<li>algunos pasos usan una substitución que representa una solución parcial, pero
si la secuencia es exitosa basta con componer todas las substituciones y
obtenemos el MGU.</li>
</ul>
<h4 id="reglas-del-algoritmo"><a class="header" href="#reglas-del-algoritmo">Reglas del algoritmo</a></h4>
<ol>
<li>Descomposición
<ul>
<li>\(\{\sigma_1 \rightarrow \sigma_2 = \tau_1 \rightarrow \tau_2\} \cup G \rightarrow \{\sigma_1 = \tau_1, \sigma_2 = \tau2\} \cup G\) (igualdad de funciones se descompone en igualdad de cada tipo de la función)</li>
<li>\(\{Nat = Nat\} \cup G \rightarrow G\)</li>
<li>\(\{Bool = Bool\} \cup G \rightarrow G\)</li>
</ul>
</li>
<li>Eliminación de par trivial
<ul>
<li>\(\{s = s\} \cup G \rightarrow G\)</li>
</ul>
</li>
<li>Swap: si \(\sigma\) no es una variable
<ul>
<li>\(\{\sigma = s\} \cup G \rightarrow \{s = \sigma\} \cup G\) (es un paso intermedio para usar la regla 4)</li>
</ul>
</li>
<li>Eliminación de variable: si \(s \notin FV(\sigma)\)
<ul>
<li>\(\{s = \sigma\} \cup G \rightarrow_{\{\sigma/s\}} \{\sigma/s\}G \) (el objetivo de la regla es eliminar la restricción)</li>
</ul>
</li>
<li>Colisión
<ul>
<li>\(\{\sigma = \tau\} \cup G \rightarrow falla\), con \((\sigma, \tau) \in T \cup T^{-1}\) (las permutaciones de matchear Bool, Nat o función) y \(T = \{(Bool, Nat), (Nat, \sigma_1 \rightarrow \sigma_2), (Bool, \sigma_1 \rightarrow \sigma_2)\}\)</li>
</ul>
</li>
<li>Occur check: si \(s \neq \sigma\) y \(s \in FV(\sigma)\)
<ul>
<li>\(\{s = \sigma\} \cup G \rightarrow falla\) (es como el ejemplo de \(s = s \rightarrow Nat\) que habíamos visto antes)</li>
</ul>
</li>
</ol>
<div id="admonition-ejemplo" class="admonition admonish-example">
<div class="admonition-title">
<p>Ejemplo</p>
<p><a class="admonition-anchor-link" href="inferencia_de_tipos.html#admonition-ejemplo"></a></p>
</div>
<div>
<p><img src="./img/ejemplo_montanari.png#center" alt="" /></p>
<p>Notar que aplicamos 3 sustituciones. Armemos el MGU que es:</p>
<p>$$
\{Nat \rightarrow (s \rightarrow s)/u\} \circ \{s \rightarrow s/r\} \circ \{Nat \rightarrow r/t\} = \\
\{Nat \rightarrow (s \rightarrow s)/t, s \rightarrow s/r, Nat \rightarrow (s \rightarrow s)/u\}
$$</p>
</div>
</div>
<h4 id="propiedades-del-algoritmo-teorema"><a class="header" href="#propiedades-del-algoritmo-teorema">Propiedades del algoritmo (Teorema)</a></h4>
<ul>
<li>El algoritmo siempre termina</li>
<li>Sea \(G\) un conjunto de pares. Si tiene unificador, entonces el algoritmo de Martelli-Montanari termina exitosamente y devuelve un MGU. Y si no tiene  el algoritmo termina con \(falla\)</li>
</ul>
<h3 id="volviendo-a-succ"><a class="header" href="#volviendo-a-succ">Volviendo a Succ</a></h3>
<p>$$
\inference{succ(U)} \stackrel{def}{=} ?
$$</p>
<ul>
<li>Sea \(\inference{U} = \hastype{\Gamma}{M}{\tau}\) ("aplico hipótesis inductiva")</li>
<li>Sea \(S = MGU\{\tau = Nat\}\)</li>
</ul>
<p>Entonces:</p>
<p>$$
\inference{succ(U)} \stackrel{def}{=} \hastype{S\Gamma}{S\ succ(M)}{Nat}
$$</p>
<blockquote>
<p>Nota: \(pred\) es similar</p>
</blockquote>
<h3 id="algoritmo-de-inferencia-caso-iszero"><a class="header" href="#algoritmo-de-inferencia-caso-iszero">Algoritmo de inferencia (caso iszero)</a></h3>
<ul>
<li>Sea \(\inference{U} = \hastype{\Gamma}{M}{\tau}\)</li>
<li>Sea \(S = MGU\{\tau = Nat\}\)</li>
</ul>
<p>Entonces:</p>
<p>$$
\inference{iszero(U)} \stackrel{def}{=} \hastype{S\Gamma}{S\ iszero(M)}{Bool}
$$</p>
<h3 id="algoritmo-de-inferencia-caso-ifthenelse"><a class="header" href="#algoritmo-de-inferencia-caso-ifthenelse">Algoritmo de inferencia (caso ifThenElse)</a></h3>
<ul>
<li>Sea \(\inference{U} = \hastype{\Gamma_1}{M}{\rho}\)</li>
<li>Sea \(\inference{V} = \hastype{\Gamma_2}{P}{\sigma}\)</li>
<li>Sea \(\inference{W} = \hastype{\Gamma_3}{Q}{\tau}\)</li>
<li>Sea \(S = MGU(\{\rho = Bool, \sigma = \tau\} \cup \{\sigma_1 = \sigma_2\ |\ x: \sigma_1 \in \Gamma_i \land x: \sigma_2 \in \Gamma_j, i \neq j\})\)
<ul>
<li>el primer conjunto es simplemente forzar que la parte del if sea un booleano y que matcheen los tipos del then y del else para que todo tipe bien.</li>
<li>la segunda parte es para asegurarte que las variables que reciben un tipo en cada término sean consistentes con el resto (notar que el ifThenElse no liga variables así que no hay que tener mucho cuidado respecto a eso).</li>
</ul>
</li>
</ul>
<p>Entonces:</p>
<p>$$
\inference{\ifLC{U}{V}{W}} \stackrel{def}{=} \hastype{S\Gamma_1 \cup S\Gamma_2 \cup S\Gamma_3}{S\ (\ifLC{M}{P}{Q})}{\sigma}
$$</p>
<blockquote>
<p>Notar que se puede usar tanto \(\tau\) como \(\sigma\) porque ya tenemos la ecuación de unificación que hace que sean iguales.</p>
</blockquote>
<h3 id="algoritmo-de-inferencia-caso-aplicación"><a class="header" href="#algoritmo-de-inferencia-caso-aplicación">Algoritmo de inferencia (caso aplicación)</a></h3>
<ul>
<li>Sea \(\inference{U} = \hastype{\Gamma_1}{M}{\tau}\)</li>
<li>Sea \(\inference{V} = \hastype{\Gamma_2}{N}{\rho}\)</li>
<li>Sea \(S = MGU(\{\tau = \rho \rightarrow t\} \cup \{\sigma_1 = \sigma_2\ |\ x: \sigma_1 \in \Gamma_i \land x: \sigma_2 \in \Gamma_j, i \neq j\})\), con \(t\) una variable fresca.
<ul>
<li>el segundo conjunto es el mismo que para el ifThenElse</li>
<li>el otro es para asegurarnos que \(U\) sea una función que recibe lo que sea que devuelva \(V\).</li>
</ul>
</li>
</ul>
<p>Entonces:</p>
<p>$$
\inference{\apply{U}{V}} \stackrel{def}{=} \hastype{S\Gamma_1 \cup S\Gamma_2}{S(\apply{M}{N})}{St}
$$</p>
<h3 id="algoritmo-de-inferencia-caso-abstracción--lambda"><a class="header" href="#algoritmo-de-inferencia-caso-abstracción--lambda">Algoritmo de inferencia (caso abstracción / lambda)</a></h3>
<ul>
<li>Sea \(\inference{U} = \hastype{\Gamma}{M}{\rho}\)</li>
<li>Si el contexto tiene información de tipos para \(x\) (o sea \(x: \tau \in \Gamma\), o lo que es lo mismo, \(x\) no puede tomar cualquier valor), entonces:</li>
</ul>
<p>$$
\inference{\lft{x}{U}} \stackrel{def}{=}  \hastype{\Gamma \setminus \{x: \tau\}}{\lf{x}{\tau}{M}}{\tau \rightarrow \rho}
$$</p>
<ul>
<li>Si no (o sea \(x \notin Dom(\Gamma)\)), elegimos una variable fresca \(s\) y entonces:</li>
</ul>
<p>$$
\inference{\lft{x}{U}} \stackrel{def}{=}  \hastype{\Gamma}{\lf{x}{s}{M}}{s \rightarrow \rho}
$$</p>
<blockquote>
<p>Notar que en este caso sólo le saco cosas al contexto, justamente porque el
término \(U\) es como dejar "libre" a \(x\), pero en realidad el valor de
\(x\) va a estar restringido por el tipo que le ligue la función lambda, no
el contexto.</p>
</blockquote>
<h3 id="algoritmo-de-inferencia-caso-fix"><a class="header" href="#algoritmo-de-inferencia-caso-fix">Algoritmo de inferencia (caso \(fix\))</a></h3>
<ul>
<li>Sea \(\inference{U} \stackrel{def}{=} \hastype{\Gamma}{M}{\rho}\)</li>
<li>Recuerdo la regla de tipado de fix:</li>
</ul>
<p>$$
\frac{\hastype{\Gamma}{M}{\sigma_1 \rightarrow \sigma_1}}{\hastype{\Gamma}{fix\ M}{\sigma_1}} (T-Fix)
$$</p>
<ul>
<li>Sea \(S = MGU \{\rho = s \rightarrow s\}\) con \(s\) una variable fresca</li>
</ul>
<p>Entonces:</p>
<p>$$
\inference{fix(U)} \stackrel{def}{=} \hastype{S\Gamma}{S\ fix(M)}{s}
$$</p>
<div style="break-before: page; page-break-before: always;"></div><p>$$
\newcommand{\ifLC}[3]{if\  {#1}\  then\  {#2}\  else\  {#3}}
\newcommand{\lf}[3]{\lambda{#1}:\ {#2}.{#3}}
\newcommand{\apply}[2]{{#1}\ {#2}}
\newcommand{\hastype}[3]{{#1} \triangleright {#2}: {#3}}
\newcommand{\tapp}[5]{\frac{\hastype{#1}{#2}{#3 \rightarrow #4}\ \ \hastype{#1}{#5}{#3}}{\hastype{#1}{\apply{{#2}}{{#5}}}{#4}} (T-app)}
$$</p>
<h1 id="subtipado"><a class="header" href="#subtipado">Subtipado</a></h1>
<h2 id="por-qué"><a class="header" href="#por-qué">Por qué?</a></h2>
<p>Arrancamos con un cálculo lambda bastante simple, y le fuimos agregando
extensiones para hacer cosas más interesantes (registros, referencias, side
effects, fix, etc.). Ahora vamos a ver una extensión más, que va a flexibilizar
un poco el sistema de tipos.</p>
<p>Qué quiere decir esto? Bueno, que hay casos donde sabemos que el programa no va
a "romper", pero nuestro sistema de tipos rechaza ese término. Pensar que el
objetivo del sistema de tipos en parte es rechazar términos que no tienen
sentido. Veamos un ejemplo:</p>
<p>$$
\apply{\lf{x}{\{a: Nat\}}{x.a}}{\{a = 1, b = true\}}
$$</p>
<p>A simple vista parece que funciona, pero el término es rechazado porque el tipo
del registro también incluye lo que pasa con \(b\). Pero a mi qué me importa
que tenga \(b\) en el contexto de la lambda?</p>
<h2 id="principio-de-sustitutividad"><a class="header" href="#principio-de-sustitutividad">Principio de sustitutividad</a></h2>
<p>Definimos la siguiente expresión:</p>
<p>$$
\sigma &lt;: \tau
$$</p>
<p>Que quiere decir que en todo contexto donde se espera una expresión de tipo
\tau, puedo pasarle una de tipo \sigma y también funciona. Es mucho muy
importante entender esto y ante la duda hacer con un ejemplo (o tomar el caso
puntual) y preguntarte, con qué tipo anda y con qué tipo quiero que también
funcione.</p>
<p>Esto mismo se expresa con la regla de tipado de Subsumption (Subsumisión):</p>
<p>$$
\frac{\hastype{\Gamma}{M}{\sigma}\ \ \ \sigma &lt;: \tau}{\hastype{\Gamma}{M}{\tau}} (T-Subs)
$$</p>
<div id="admonition-subtipado-de-tipos-básicos" class="admonition admonish-info">
<div class="admonition-title">
<p>Subtipado de tipos básicos</p>
<p><a class="admonition-anchor-link" href="subtipado.html#admonition-subtipado-de-tipos-básicos"></a></p>
</div>
<div>
<ul>
<li>\(Nat &lt;: Float\)
<ul>
<li>"Siempre que tenga un término que acepta float puedo usar un nat y no debería romper"</li>
</ul>
</li>
<li>\(Int &lt;: Float\)
<ul>
<li>"Siempre que tenga un término que acepta float puedo usar un int y no debería romper"</li>
</ul>
</li>
<li>\(Bool &lt;: Nat\)
<ul>
<li>"Siempre que tenga un término que acepta Nat puedo usar un bool y no debería romper"</li>
</ul>
</li>
</ul>
</div>
</div>
<p>Algo interesante que agrega este operador es que induce un pre-orden, o sea que es reflexiva y transitiva:</p>
<div style="width:330px;">
<p>$$
\frac{}{\sigma &lt;: \sigma} (T-Refl) \\
\frac{\sigma &lt;: \tau\ \ \ \tau &lt;: \rho}{\sigma &lt;: \rho} (T-Trans)
$$</p>
</div>
<div style="float:right;margin-left:2rem;margin-bottom:3rem;margin-top:-10rem;width:330px">
<blockquote>
<p>Nota: No es ni antisimétrica ni simétrica</p>
</blockquote>
<div id="admonition-querríamos-tener-un-orden-total" class="admonition admonish-question">
<div class="admonition-title">
<p>Querríamos tener un orden total?</p>
<p><a class="admonition-anchor-link" href="subtipado.html#admonition-querríamos-tener-un-orden-total"></a></p>
</div>
<div>
<p>A priori suena medio raro, porque hay cosas que ni tienen sentido comparar. No
tiene mucho sentido comparar por ejemplo un entero con una función, o un
booleano con una función. Pero capaz si tiene sentido comparar las funciones
según su tipo de entrada y salida.</p>
</div>
</div>
</div>
<h2 id="revisitando-las-reglas-de-tipado-para-lambdacálculo-con-registros"><a class="header" href="#revisitando-las-reglas-de-tipado-para-lambdacálculo-con-registros">Revisitando las reglas de tipado para lambdacálculo con registros</a></h2>
<p>A priori las reglas más básicas \(T-Var\), \(T-Var\), \(T-Abs\) y
\(T-App\) no requieren cambios.</p>
<p>Por otro lado teníamos las <a href="./lambda_calc_extendido.html#reglas-de-tipado">reglas de tipado</a> para registros \(T-Rcd\) y \(T-Proj\) para los registros y su proyección:</p>
</br>
</br>
<p>$$
\frac{\Gamma \triangleright M_i : \sigma_i\ \text{para cada } i \in 1 \dots n}{\Gamma \triangleright \{l_i = M_i^{i \in 1 \dots n} \} : \{l_i : \sigma_i^{i \in 1 \dots n}\}} (T-RCD) \\
\frac{\Gamma \triangleright M_i : \{l_i : \sigma_i^{i \in 1 \dots n}\}\ j \in 1 \dots n}{\Gamma \triangleright M.I_j : \sigma_j} (T-Proj)
$$</p>
<p>Ahora, lo siguiente que vamos a hacer es introducir la regla \(T-Trans\), y
la vamos a usar para agregar nuevas reglas.</p>
<h3 id="subtipados-de-registros-a-lo-ancho"><a class="header" href="#subtipados-de-registros-a-lo-ancho">Subtipados de registros a lo "ancho"</a></h3>
<p>Idea de la regla: si yo tengo algo que tipa para un registro, agregarle más
cosas a dicho registro no debería de cambiar nada. Por ejemplo: <code>{nombre: String, edad: Int} &lt;: {nombre: String}</code>.</p>
<p>Generalizando, nos quedaría:</p>
<p>$$
\frac{}{\{l_i: \sigma_i\ |\ i \in 1\dots n + k\} &lt;: \{l_i: \sigma_i\ |\ i \in 1\dots n\}} (S-RcdWidth)
$$</p>
<ul>
<li>Nota: \(\sigma &lt;: \{\}\) para todo registro \(\sigma\).</li>
<li>Hay algún tipo registro \(t\) tal que \(\tau &lt;: \sigma\) para todo tipo registro \(\sigma\).
<ul>
<li>yo creo que no, porque basta con agarrar un registro que tenga una etiqueta que \(t\) no use y armar un registro con eso.</li>
</ul>
</li>
</ul>
<h3 id="subtipado-en-profundidad"><a class="header" href="#subtipado-en-profundidad">Subtipado "en profundidad"</a></h3>
<p>Si yo tuviese <code>{a: Nat, b: Int} ? {a: Float, b: Int}</code>. Qué va en el <code>?</code>? Bueno,
si yo cuando espero un <code>Float</code> me pasan un <code>Nat</code> y anda, debería de pasar lo
mismo si para una etiqueta el tipo es <code>Float</code> y me pasan algo que para esa
etiqueta el tipo es <code>Nat</code>. Generalizando eso se escribe como:</p>
<p>$$
\frac{\sigma_i &lt;: \tau_i\ i \in \{1 \dots n\}}{\{l_i: \sigma_i\ |\ i \in 1\dots n\} &lt;: \{l_i: \tau_i\ |\ i \in 1\dots n\}} (S-RcdDepth)
$$</p>
<ul>
<li>Notar que la restricción la hacemos sobre todos los campos (como el subtipado
es reflexivo no nos trae muchos problemas y no perdemos flexibilidad vs
escribir la regla sobre un label puntual).</li>
<li>Ejemplo: <code>{x: {a: Nat, b: Nat}, y: {m: Nat}} &lt;: {x: {a: Nat}, y: {}}</code>. Vale pues:
<ul>
<li><code>{m: Nat} &lt;: {}</code> (value para cualquier cosa que ponga a la izquierda).</li>
<li><code>{a: Nat, b: Nat} &lt;: {a: Nat}</code> ya que es agregarle <code>b: Nat</code> a <code>{a: Nat}</code> (\(S-RcdWidth\))</li>
<li>Como para <code>x</code> e <code>y</code>, los tipos del término de la izquierda son subtipos de los de la derecha, + \(S-RcdDepth\) obtenemos que el término de la izquierda es subtipo del de la derecha</li>
</ul>
</li>
</ul>
<h3 id="permutaciones-de-campos"><a class="header" href="#permutaciones-de-campos">Permutaciones de campos</a></h3>
<p>Más que nada para simplificar el lenguaje, cuando definimos los registros
teníamos la restricción de que el tipo te fijaba el órden de las etiquetas, a
pesar de que con las etiquetas ya debería de ser suficiente independientemente
del orden. O sea, me da lo mismo tener <code>{a: String, b: Int}</code> que <code>{b: Int, a: String}</code>. Generalizando:</p>
<p>$$
\frac{\{k_j: \sigma_j\ j \in 1 \dots n\} \text{ es permutación de } \{l_i: \tau_i\ i \in 1 \dots n\}}{\{k_j: \sigma_j\ j \in 1 \dots n\} &lt;: \{l_i: \tau_i\ i \in 1 \dots n\}} (S-RcdPerm)
$$</p>
<div id="admonition-nota-eliminando-etiquetas" class="admonition admonish-info">
<div class="admonition-title">
<p>Nota: Eliminando etiquetas</p>
<p><a class="admonition-anchor-link" href="subtipado.html#admonition-nota-eliminando-etiquetas"></a></p>
</div>
<div>
<p>Usando \(S-RcdWidth\) + \(S-Trans\) + \(S-RcdPerm\) puedo eliminar campos en cualquier parte del registro</p>
<ul>
<li>lo puedo lograr reordenando los campos que no quiero al fondo y después eliminandolos</li>
<li>podría armar una regla nueva también, pero ya con lo que tenemos tenemos una base</li>
</ul>
<p>$$
\frac{\{l_i: \tau_i\ i \in 1 \dots n\} \subseteq \{k_j: \sigma_j\ j \in 1 \dots m\}\ \ \ \ k_j = l_i \implies \sigma_j &lt;: \tau_i}{\{k_j: \sigma_j\ j \in 1 \dots n\} &lt;: \{l_i: \tau_i\ i \in 1 \dots n\}} (S-Rcd)
$$</p>
<p>O sea que si:</p>
<ul>
<li>tengo un subconjunto de las etiquetas (está implícito que tiene más campos) y</li>
<li>en aquellas que coincide su tipo correspondiente es subtipo del otro</li>
</ul>
<p>Entonces un tipo registro es subtipo del otro. Para hacer las pruebas vamos a usar esta regla (más que nada para ahorrarnos pasos y que quede una demo más directa)</p>
</div>
</div>
<h2 id="subtipado-de-tipos-función"><a class="header" href="#subtipado-de-tipos-función">Subtipado de tipos función</a></h2>
<p>Cómo funcionaría para las funciones? Si yo quiero que \(\sigma_1 \rightarrow \tau_1 &lt;: \sigma_2 \rightarrow \tau_2\), qué le tengo que pedir a \(\sigma_1, \sigma_2, \tau_1, \tau_2\)?</p>
<p>Primero, hay que tener como base que lo que quiero es que a una función que acepta \(\sigma_2 \rightarrow \tau_2\) le pueda pasar algo de tipo \(\sigma_1 \rightarrow \tau_1\). Esto significaría:</p>
<ul>
<li>Que el dominio tiene que ser compatible, o sea que las cosas de \(\sigma_2\) que se le pasaban a la función funcionen con cosas de \(sigma_1\).
<ul>
<li>o sea \(\sigma_2 &lt;: \sigma_1\)</li>
</ul>
</li>
<li>Que el resultado de la función funcione en lugar del tipo que devolvía lo otra función.
<ul>
<li>o sea \(\tau_1 &lt;: \tau_2\)</li>
</ul>
</li>
</ul>
<p>Veamos dos casos:</p>
<ul>
<li>Supongamos que tenemos los tipos <code>Nat</code> e <code>Int</code>, y mi código usaba una función
de tipo <code>Int -&gt; Int</code> (por ejemplo, la función <code>sumar_2 x = x + 2</code>). Si yo le
pasara la función raíz cuadrada que es de tipo <code>Nat -&gt; Nat</code> y en algún
momento se le pasaba un número negativo, explotaba!.</li>
<li>Mismos tipos que antes pero mi código usa una función de tipo <code>Nat -&gt; Nat</code>.
Si yo le paso una función de tipo <code>Int -&gt; Int</code> podría pasar que al resultado
de llamar a la función se lo pasara a la función raíz cuadrada, y de vuelta
si en alguna situación mi nueva función daba como resultado un número
negativo, también explotaría.</li>
</ul>
<p>La regla entonces que sacamos de esto es (en la teórica están al revés los tipos):</p>
<p>$$
\frac{\sigma' &lt;: \sigma\ \ \tau &lt;: \tau'}{\sigma \rightarrow \tau &lt;: \sigma' \rightarrow \tau'} (S-Arrow)
$$</p>
<p>Se dice que el constructor de tipos función es <strong>contravariante</strong> en su primer argumento y <strong>variante</strong> en el segundo.</p>
<h2 id="subtipado-de-referencias"><a class="header" href="#subtipado-de-referencias">Subtipado de referencias</a></h2>
<p>Es covariante? Veamos cómo sería la regla (covariante):</p>
<p>$$
\frac{\sigma &lt;: \tau}{Ref \sigma &lt;: Ref \tau}
$$</p>
<p>Qué pasa?</p>
<ul>
<li>La desreferencia tiene sentido que ande</li>
<li>Pero y si intento escribir? Veámos un ejemplo:</li>
</ul>
<pre><code>let r = ref 3 (*r: Ref Int*)
in r := 2.1;
!r
</code></pre>
<ul>
<li>En el ejemplo, tengo que <code>Int &lt;: Float</code>, y sin embargo <code>Ref Int &lt;: Ref Float</code>
no vale porque a la hora de asignar estaría asignándole un <code>Float</code> a algo a
lo que sólo puede recibir un <code>Int</code></li>
</ul>
<p>Por lo tanto es contravariante, no?</p>
<p>$$
\frac{\tau &lt;: \sigma}{Ref \sigma &lt;: Ref \tau}
$$</p>
<p>Qué pasa con:</p>
<pre><code>let r = ref 3.2 (*r: Ref Float*)
in succ(!r)
</code></pre>
<p>Ahora tengo el otro problema: si asumo que es contravariante, como <code>Int &lt;: Float</code>, obtengo que <code>Ref Float &lt;: Ref Int</code>, lo cual significaría que donde
espere una referencia a un entero puedo pasarle una referencia a un float y
anda. Claramente en el ejemplo no puedo pasar una referencia a un float porque
<code>succ</code> no tipa.</p>
<h3 id="la-desilusión"><a class="header" href="#la-desilusión">La desilusión...</a></h3>
<p>Ah, que bien esto de subtipado, no me sirve para nada!!!!!</p>
<p><img src="./img/nacagada.png#center" alt="" /></p>
<p>Pero a no desesperar. Vamos a hacer un último empujón para hacerlo andar. Qué
pasa si a la regla le pedimos que los tipos sean equivalentes. Eso resolvería
nuestros problemas porque al leer de un tipo coerciono contra el otro, y al
escribir hago lo mismo a la inversa. Eso quedaría:</p>
<p>$$
\frac{\sigma &lt;: \tau\ \ \tau &lt;: \sigma}{Ref \sigma &lt;: Ref \tau}
$$</p>
<p>Notar que el orden de los refs abajo es intercambiable. O sea que si dos tipos
son equivalentes, sus referencias también lo serán. Cuando esto sucede, decimos
que el tipo (Ref en este caso) es <strong>Invariante</strong>.</p>
<h3 id="refinando-ref"><a class="header" href="#refinando-ref">Refinando \(Ref\)</a></h3>
<p>La solución anterior no me deja del todo satisfecho porque lo que trae
problemas es la co-existencia de la lectura y la escritura, ya que esas nos
restringen a ser covariante o contravariante. Y en muchos casos, puedo
únicamente querer leer o únicamente escribir.</p>
<p>Entonces, vamos a separar las referencias dependiendo de si son de lectura o de
esritura. Vamos a definir 2 tipos de referencias nuevos:</p>
<ul>
<li>\(Source\ \sigma\) para las referencias de lectura</li>
<li>\(Sink\ \sigma\) para las referencias de escritura</li>
</ul>
<p>Las reglas de tipado para ambos términos son:</p>
<p>$$
\frac{\hastype{\Gamma|\Sigma}{M}{Source \sigma}}{\hastype{\Gamma|\Sigma}{!M}{\sigma}} \\
\frac{\hastype{\Gamma|\Sigma}{M}{Sink\ \sigma}\ \hastype{\Gamma|\Sigma}{N}{\sigma}}{\hastype{\Gamma|\Sigma}{M := N}{Unit}}
$$</p>
<p>Ahora, estoy forzando a que a un source únicamente le hago la desreferencia, y
a un sink le hago una asignación. Además, por la lógica vista anteriormente,
nos quedaría que el source va a ser covariante (\(S-Source\)) y el sink contravariante (\(S-Sink\)):</p>
<p>$$
\frac{\sigma &lt;: \tau}{Source \sigma &lt;: Source \tau} \\
\frac{\sigma &lt;: \tau}{Sink \tau &lt;: Sink \sigma}
$$</p>
<p>Un último detalle, porque recuerdo que el ejemplo era:</p>
<pre><code>let r = ref 3
in r := 2.1;
!r
</code></pre>
<p>Acá estoy tanto leyendo como escribiendo en la referencia! A priori no me
funciona mi abstracción... o sí? Bueno, hay que agregar una cosa más, y es
poder "downgradear" las referencias a \(Sink\) o \(Source\) dependiendo de
lo que se necesite.</p>
<p>Para eso sumamos las reglas:</p>
<p>$$
\frac{}{Ref\ \sigma &lt;: Source\ \sigma} \\
\frac{}{Ref\ \sigma &lt;: Sink\ \sigma}
$$</p>
<p>Con eso en el ejemplo tendría:</p>
<pre><code>let r = ref 3 (* el ref 3 va a ser de tipo Ref Int*)
in r := 2.1; (* esto lo tipo como sink, y uso que ref es subtipo*)
!r
</code></pre>
<h2 id="dándole-un-uso"><a class="header" href="#dándole-un-uso">Dándole un uso</a></h2>
<p><a href="subtipado.html#principio-de-sustitutividad">Al principio de todo</a> dijimos que agregábamos la
regla de subsumption. Esto cambia en parte la lógica de nuestro algoritmo de
chequeo de tipos, porque hasta ahora todas las reglas estaban guiadas por
sintáxis, y la regla que introducimos está guiada por la "oportunidad" del tipo
(o sea según te convenga). Cómo haríamos con eso para implementar un algoritmo
de chequeo de tipos? Idealmente, me gustaría poder sacar la regla \(T-Subs\).
Entonces, para eso vamos a mirar en qué casos pueden haber incompatibilidades
de tipos. Si revisamos la reglas, todas son de la pinta "instancio un tipo y le
asigno el tipo abajo y restrinjo el tipo arriba". La única regla que parecería
agregar nuevos tipos es la de la aplicación \(T-App\):</p>
<p>$$
\tapp{\Gamma}{M}{\tau}{\sigma}{N}
$$</p>
<p>Entonces la idea es tomar esa regla, y cambiar lo que nos da problemas, que es
el tipo de \(N\). Vamos a pedir que el tipo de \(N\) sea subtipo de lo que
sea que acepta \(M\):</p>
<p>$$
\frac{\hastype{\Gamma}{M}{\sigma \rightarrow \tau}\ \ \hastype{\Gamma}{N}{\rho}\ \ \rho &lt;: \tau}{\hastype{\Gamma}{\apply{M}{N}}{\tau}} (T-App')
$$</p>
<p>Hay un resultado que nos dice que:</p>
<ul>
<li>Si en este nuevo sistema de tipado pude asignar un tipo válido a un término,
entonces también lo puedo hacer con el que tiene la regla de subsumption
libre (lo cual tiene sentido, ya que el otro me permite hacer lo mismo y
meter la regla de subsumption donde se me cante.</li>
<li>Pero además, el resulado dice que en el recíproco, si vos probaste que tu
término tiene tipo \(\sigma\), entonces con esta variante podés probar que
tiene tipo \(\rho\), con \(\rho &lt;: \tau\) (o sea que capaz es un poquito
más restrictivo, pero al menos tengo una implementación más directa).</li>
</ul>
<h3 id="más-problemas"><a class="header" href="#más-problemas">Más problemas</a></h3>
<p>Si bien me saqué de encima \(T-Subs\), todavía me quedan algunas reglas que no están guiadas por sintáxis. En particular \(S-Refl\) y \(S-Trans\) (ponele que en \(S-Func\) podría llegar a zafar porque tengo funciones). Por suerte hay solución:</p>
<div id="admonition-ojo" class="admonition admonish-warning">
<div class="admonition-title">
<p>Ojo</p>
<p><a class="admonition-anchor-link" href="subtipado.html#admonition-ojo"></a></p>
</div>
<div>
<p>Que no están guiadas por sintáxis en este caso no refiere al término si no a la
sintáxis de los tipos. A esas reglas les da lo mismo si tengo \(Nat\) o si
tengo \(Nat -&gt; Nat\).</p>
</div>
</div>
<ul>
<li>se puede probar que \(\sigma &lt;: \sigma\) se puede derivar si tengo
reflexividad para tipos escalares (asumidos como axiomas):
<ul>
<li>\(Nat &lt;: Nat\)</li>
<li>\(Int &lt;: Int\)</li>
<li>\(Bool &lt;: Bool\)</li>
<li>\(Float &lt;: Float\)</li>
</ul>
</li>
<li>además recuerdo que tengo un par de reglas axiomáticas que relacionan los
tipos escalares:
<ul>
<li>\(Nat &lt;: Float\)</li>
<li>\(Int &lt;: Float\)</li>
<li>\(Bool &lt;: Float\)</li>
</ul>
</li>
<li>de forma similar se puede probar que no hace falta la regla de transitividad \(S-Trans\), ya que tenemos transitividad en las reglas de tipado (ojo, no es tan directo pero tampoco voy a ahondar mucho en esto).</li>
</ul>
<h3 id="función-subtype"><a class="header" href="#función-subtype">Función <code>subtype</code></a></h3>
<p>Obviando los casos base para tipos escalares, nos quedaría algo así:</p>
<pre><code class="language-python">subtype(S, T):
    # Manejar casos base
    if S == S1 -&gt; S2 and T = T1 -&gt; T2:
        subtype(T1, S1) and subtype(S2, T2)
    else:
        if S == {k_j: S_j, j in (1..m)} and T == {l_i: T_i, i in (1..n)}:
            subseteq({l_i, i in (1..n)}, {k_j, j in (1..m)}) and all(i in (1..n) -&gt; exists(j in (1..m) -&gt; k_j = l_i and subtype(S_j, T_i)))
        else: 
            false
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unidad-3---programación-funcional"><a class="header" href="#unidad-3---programación-funcional">Unidad 3 - Programación Funcional</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="programación-orientada-a-objetos"><a class="header" href="#programación-orientada-a-objetos">Programación orientada a objetos</a></h1>
<p>Así como en la programación imperativa, teníamos la idea de <em>estado</em> que tiene
el valor de las variables y nosotros le damos una serie de instrucciones para
modificar el estado. Después vimos el paradigma funcional y el modelo de
cómputo cambio. En ese nuevo paradigma defino funciones, las evalúo en
expresiones y reducimos las expresiones a su forma normal.</p>
<p>En objetos, lo pensamos como que un programa es una simulación. Y cada entidad
(relevante, que quiero modelar) del sistema que se simula se representa en el
programa con un <strong>objeto</strong>. En este paradigma la forma de razonar es hacer que
los objetos "hablen" entre sí.</p>
<h2 id="modelo-de-cómputo"><a class="header" href="#modelo-de-cómputo">Modelo de cómputo</a></h2>
<ul>
<li>Sistema formado por objetos.</li>
<li>El modelo de cómputo consiste en el envío de mensajes.</li>
<li>Un <strong>mensaje</strong> es una solicitud que se le manda a un objeto para que lleve a
caba alguna de las operaciones que sabe hacer.</li>
<li>El <strong>receptor</strong> es el objeto que recibe el mensaje y es quien se encarga de
determinar <strong>cómo</strong> se resulve esa solicitud/mensaje.
<ul>
<li>Los <strong>métodos</strong> son los que describen ese cómo.</li>
<li>La forma en la que se resuleve puede depender del estado interno del
objeto.
<ul>
<li>Ese estado interno se representa mediante <strong>colaboradores internos</strong>
(también conocidos como <strong>atributos</strong> o <strong>variables de instancia</strong>)</li>
</ul>
</li>
</ul>
</li>
<li>El conjunto de mensajes a los que un objeto responde se lo llama <strong>interfaz o
protocolo</strong>.</li>
<li>la <strong>única</strong> forma de interactuar con un objeto es mediante el envío de
mensajes
<ul>
<li>la implementación de un objeto no puede depender de los detalles de
implementación de otros objetos (confio en que tienen una interfaz que
resuelve lo que necesito y de manera correcta).</li>
</ul>
</li>
<li>el estado de un objeto es <strong>privado</strong> y sólo puede ser modificado por medio
de sus métodos.
<ul>
<li>no todos los lenguajes imponen esta restricción though (ej: en c++ tengo el modifier <code>friend</code>)</li>
</ul>
</li>
</ul>
<h3 id="method-dispatch"><a class="header" href="#method-dispatch">Method Dispatch</a></h3>
<p>El método de cómputo se puede describir con los siguientes pasos:</p>
<ul>
<li>(reminder) la interacción entre objetos es mediante envío de mensajes</li>
<li>al recibir un mensaje se activa el método que corresponde
<ul>
<li>para procesar el mensaje, hay un proceso de encontrar el método
correspondiente para ese mensaje. Dicho proceso se conoce como <strong>method
dispatch</strong></li>
<li>puede ser tan simple como ver si mi objeto tiene el método para el nombre
o puedo complejizarlo cuando meto herencia, entre otras features. En esos
casos el method dispatch tiene un algoritmo no tan sencillo.</li>
</ul>
</li>
<li>el method dispatch se puede hacer de forma estática (c, no todo. Java híbrido) o dinámica (en tiempo de
ejecución)</li>
</ul>
<div id="admonition-ejemplo" class="admonition admonish-example">
<div class="admonition-title">
<p>Ejemplo</p>
<p><a class="admonition-anchor-link" href="javascript_intro.html#admonition-ejemplo"></a></p>
</div>
<div>
<p>objeto <code>unCirculo</code>. Si le quiero pedir el radio: <code>unCirculo radio</code> en smalltalk, <code>unCirculo.radio</code> en c#, etc.</p>
<ul>
<li><code>unCirculo</code> es el receptor del mensaje</li>
<li><code>radio</code> es el mensaje que se le envía</li>
</ul>
<p>objeto <code>unRectangulo</code></p>
<ul>
<li>interfaz: area</li>
<li>atributos: alto y ancho</li>
<li>métodos: area = function(){ return alto * ancho }</li>
</ul>
</div>
</div>
<h2 id="corrientes"><a class="header" href="#corrientes">Corrientes</a></h2>
<p>Hablamos de que tenemos mensajes y que tenemos métodos para responder dichos
mensajes. Ahora, dónde ponemos esos métodos? Si tengo un objeto <code>Estudiante</code>,
una vez cargada las notas parciales la nota final se calcula siempre igual,
entonces podría reusar esa lógica. las 2 alternativas más conocidas son
<strong>clasificación</strong> y <strong>prototipado</strong>.</p>
<h3 id="clasificación"><a class="header" href="#clasificación">Clasificación</a></h3>
<p>Usan el concepto de <strong>Clase</strong>:</p>
<ul>
<li>modelan conceptos abstractos del dominio del problema</li>
<li>son como un "molde" de los objetos: definen la forma (los colaboradores externos) y el comportamiento de
los objetos</li>
<li>todo objeto es instancia de alguna clase (los objetos son distintos pero usan
los métodos de la misma clase para responder a mensajes)</li>
</ul>
<h4 id="componentes-de-una-clase"><a class="header" href="#componentes-de-una-clase">Componentes de una clase</a></h4>
<ul>
<li>un nombre</li>
<li>definición de las variables de instancia</li>
<li>métodos de instancia</li>
<li>por cada método se especifica
<ul>
<li>nombre</li>
<li>parámetros formales</li>
<li>cuerpo</li>
</ul>
</li>
</ul>
<p>Algunos lenguajes como smalltalk permiten tener tanto métodos de clase como
métodos de instancia.</p>
<h4 id="self-o-this-según-el-lenguaje"><a class="header" href="#self-o-this-según-el-lenguaje">Self (o this según el lenguaje)</a></h4>
<p>Es una pseudo-variable que se resuelve durante la evaluación de un método. Recerencia al receptor del mensaje que activó la evaluación</p>
<ul>
<li>no se puede modificar por medio de una asignación</li>
<li>se liga al receptor ni bien comienza la evaluación del método</li>
</ul>
<h4 id="jerarquía-de-clases"><a class="header" href="#jerarquía-de-clases">Jerarquía de clases</a></h4>
<ul>
<li>Es común que algunas clases aparezcan como una extensión de otras clases
<ul>
<li>porque se agrega / sobreescribe el comportamiento de algún método</li>
<li>porque quiero agregar nuevas variables de instancia / clase</li>
</ul>
</li>
<li>Se permite que una clase <strong>herede</strong> o <strong>extienda</strong> una clase pre-existente, que conocemos como <strong>superclase</strong></li>
<li>La herencia es una relación transitiva, lo cual da origen a la diferenciación entre <strong>ancestros</strong> y <strong>descendientes</strong></li>
</ul>
<h4 id="herencia"><a class="header" href="#herencia">Herencia</a></h4>
<p>Hay 2 tipos de herencia:</p>
<ul>
<li>Simple: una clase tiene una única clase padre (salvo <code>Object</code>)</li>
<li>Múltiple: una clase puede tener más de una clase padre
<ul>
<li>ejemplo: un <code>ProjeforUniversitario</code> es un <code>Profesor</code> y un <code>Investigador</code></li>
</ul>
</li>
<li>La mayoría de los lenguajes OO usan <strong>herencia simple</strong> ya que la herencia múltiple complica el proceso de method dispatch (qué pasa cuando ambas clases implementan un método)
<ul>
<li>hay soluciones (pero siguen agregando complejidad medio al dope):
<ul>
<li>uso el órden de búsqueda</li>
<li>fuerzo a que en esos casos se tenga que redefinir el método de la nueva clase.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="method-dispatch-estático"><a class="header" href="#method-dispatch-estático">Method Dispatch Estático</a></h2>
<p>Lo que le da power al lenguaje orientado a objetos es la posibilidad de tener
method dispatch dinámico. Sin embargo, hay lenguajes que cuentan com method
dispatch estático. Esto se puede dar por una cuestión de eficiencia o porque se
requiera más allá de la eficiencia, como lo es con <code>super</code>.</p>
<div id="admonition-method-dispatch-estático" class="admonition admonish-example">
<div class="admonition-title">
<p>Method dispatch estático</p>
<p><a class="admonition-anchor-link" href="javascript_intro.html#admonition-method-dispatch-estático"></a></p>
</div>
<div>
<p>Supongamos que queremos extender la clase <code>point</code> del siguiente modo:</p>
<pre><code>Object subclass: #Point
Métodos de instancia
setX: xValue setY: yValue
    xCoord := xValue.
    yCoord := yValue.

Point subclass: #ColorPoint
Métodos de instancia
setX: xValue setY: yValue setColor: aColor
    xCoord := xValue.
    yCoord := yValue.
    color  := aColor.
</code></pre>
<p>Duplico código innecesariamente! En lugar de eso puedo usar <code>super</code>:</p>
<pre><code>Object subclass: #Point
Métodos de instancia
setX: xValue setY: yValue
    xCoord := xValue.
    yCoord := yValue.

Point subclass: #ColorPoint
Métodos de instancia
setX: xValue setY: yValue setColor: aColor
    self setX: xValue setY: yValue.
    color  := aColor.
</code></pre>
<p>Ahora supongamos que queremos hacer algo similar y definir el objeto <code>BluePoint</code>:</p>
<pre><code>Object subclass: #Point
Métodos de instancia
setX: xValue setY: yValue
    xCoord := xValue.
    yCoord := yValue.

Point subclass: #BluePoint
instanceVarNames: 'color'
Métodos de instancia
setX: xValue setY: yValue
    self setX: xValue setY: yValue.
    color  := 'blue'.
</code></pre>
<p>El problema de esto es que al hacer <code>self setX: _ setY: _</code> entro en un loop
infinito. Antes funcionaba porque tenía el constructor de 3 variables y llamo
al de la superclase que usa 2. En este caso sin embargo lo que pasa es que ya
pisamos la implementación de <code>setX: _ setY: _</code>.</p>
<p>Al usar <code>super</code> de la siguiente manera se arregla:</p>
<pre><code>Point subclass: #ColorPoint
instanceVarNames: 'color'
Métodos de instancia
setX: xValue setY: yValue
    super setX: xValue setY: yValue.
    color  := 'blue'.
</code></pre>
<p><strong>OJO</strong>, <code>super</code> <strong>también hace referencia al objeto receptor del mensaje</strong>, la
diferencia es que <code>super</code> cambia el comienzo del method lookup para que
arranque a buscar desde la clase padre.</p>
</div>
</div>
<h2 id="lenguajes-basados-en-objetos"><a class="header" href="#lenguajes-basados-en-objetos">Lenguajes basados en objetos</a></h2>
<p>O sea lenguajes que <strong>no usan clases</strong>. Tengo constructores para crear objetos particulares:</p>
<pre><code class="language-js">let celda {
    contenido: 0,
    get: function () { return this.contenido; },
    set: function (n) { this.contenido = n; },
}
</code></pre>
<p>Puedo definir procedimientos para generar objetos (es un constructor, pero no una clase):</p>
<pre><code class="language-js">Celda = function () {
    this.contenido = 0;
    this.get = function () { return this.contenido; };
    this.set = function (n) { this.contenido = n; };
}

otracelda = new Celda ();
</code></pre>
<h3 id="prototipado"><a class="header" href="#prototipado">Prototipado</a></h3>
<p>Es la idea de construir instancias concretas que son representantes de las instancias (son los prototipas). Las otras instancias se generan mediante clonación (es una shallow copy, sólo copia la primer linea de atributos y métodos. No se mete a fondo):</p>
<pre><code class="language-js">celdaClonada = Object.create(celda);
</code></pre>
<p>Los clones además se pueden cambiar:</p>
<pre><code class="language-js">celdaClonada.set = function (n) {
    this.contenido = this.contenido + n;
}
</code></pre>
<p>Es posible además implementar herencia a través de prototipos (lo veremos más adelante).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cálculo-sigma"><a class="header" href="#cálculo-sigma">Cálculo Sigma</a></h1>
<p>Vamos a ver una formalización del cálculo de objetos (parcial)</p>
<ul>
<li>Basada en la formalización de Abadi &amp; Cardelli del 98'</li>
<li>Basáda en semántica operacional big step (recuerdo: son dar pasos grandes para llegar al resultado)</li>
<li><strong>No tipado</strong> (y con un aire a funcional)
<ul>
<li>En el mismo libro de Abadi&amp;Cardelli dan una versión imperativa</li>
</ul>
</li>
<li>Objetos como única estructura computacional
<ul>
<li>son colecciones de atributos (como los registros del funcional)</li>
<li><strong>todos</strong> los atributos son métodos</li>
</ul>
</li>
<li>Cada método tiene una única variable ligada que representa a <code>self/this</code> y un cuerpo que produce un resultado.</li>
<li>Los objetos proveen 2 operaciones:
<ul>
<li>envío de mensajes</li>
<li>redefinición de un método (actualizar atributos, a.k.a modificar el estado)</li>
</ul>
</li>
</ul>
<h2 id="sintaxis"><a class="header" href="#sintaxis">Sintaxis</a></h2>
<p>$$
\begin{alignat}{2}
o,b ::=&amp; x\ &amp;\text{variable} \\
|&amp;\ [l_i = \zeta(x_i)b_i^i\in{1\dots n}] \ &amp;\text{objeto} \\
|&amp;\ o.l\ &amp;\text{selección / envío de mensaje} \\
|&amp;\ o.l \leftarrow \zeta(x)b\ &amp;\text{redefinición de método}
\end{alignat}
$$</p>
<div id="admonition-un-objeto" class="admonition admonish-example">
<div class="admonition-title">
<p>Un objeto</p>
<p><a class="admonition-anchor-link" href="sigma_calc.html#admonition-un-objeto"></a></p>
</div>
<div>
<p>$$
o \stackrel{def}{=} [l_1 = \zeta(x_1)[],\ l_2 = \zeta(x_2).l_1]
$$</p>
<p>\(o\) tiene 2 métodos:</p>
<ul>
<li>\(l_1\) retorna un objeto vacío \([]\)</li>
<li>\(l_2\) es un método que envía el mensaje \(l_1\) a \(\text{self}\) (representado por \(x_2\))</li>
</ul>
</div>
</div>
<h2 id="atributos-vs-métodos"><a class="header" href="#atributos-vs-métodos">Atributos vs métodos</a></h2>
<p>El cálculo \(\sigma\) no incluye explícitamente atributos. Peeeeero podemos definir atributos como métodos que no usan \(\text{self}\). En el ejemplo anterior, \(l_1\) era un atributo. De esta forma podemos interpretar que</p>
<ul>
<li>un envío de mensaje puede ser la selección de un atributo</li>
<li>redefinir un método puede ser modificar el atributo</li>
</ul>
<p>Para simplificar la notación, tomamos algunos atajos:</p>
<ul>
<li>Definición de atributo: \([\dots, l = b, \dots]\) lo usamos como abreviatura de \([\dots, l = \zeta(x)b, \dots]\)</li>
<li>Asignación de atributo: \(o.l := b\) lo usamos como abreviatura de \(o.l \leftarrow \zeta(x)b\)</li>
</ul>
<h2 id="variables-libres-1"><a class="header" href="#variables-libres-1">Variables Libres</a></h2>
<p>Pdemos ver a \(\zeta\) como el ligador de \(x_i\) en el cuerpo \(b_i\) (similar a como hacíamos con \(\lambda\) en funcional) de la expresión \(\zeta(x_i)b_i\):</p>
<p>$$
\begin{align}
fv(\zeta(x)b) &amp;= fv(b) \setminus \{x\} \\
fv(x) &amp;= \{x\} \\
fv([l_i = \zeta(x_i)b_i^i\in{1\dots n}]) &amp;= \bigcup^{i\in1\dots n} fv(\zeta(x_i)b_i) \\
fv(o.l) &amp;= fv(o) \\
fv(o.l \leftarrow \zeta(x)b) &amp;= fv(o.l) \cup fv(\zeta(x)b)
\end{align}
$$</p>
<blockquote>
<p>Duda pendiente: en el último caso no tendría que sacarle las que estuviesen
libres previamente en \(o.l\) y no estén libres en el método con el que se
pisa?</p>
</blockquote>
<p>Un término se dice <strong>cerrado</strong> si su conjunto de variables libres es vacío.</p>
<h2 id="sustitución"><a class="header" href="#sustitución">Sustitución</a></h2>
<p>Asumamos que c es alguna expresión arbitraria.</p>
<p>$$
\begin{align}
x\{c/x\} &amp;= c \\
y\{c/x\} &amp;= y \text{si} x \neq y \\
[l_i = \zeta(x_i)b_i^i\in{1\dots n}]\{c/x\} &amp;= [l_i = (\zeta(x_i)b_i)\{c/x\}^i\in{1\dots n}] \\
o.l\{c/x\} &amp;= (o\{c/x\}).l \\
(o.l \leftarrow \zeta(x)b)\{c/x\} &amp;= (o.l\{c/x\}) \leftarrow (\zeta(x)b\{c/x\}) \\
\zeta(y)b\{c/x\} &amp;= \zeta(y')(b\{y'/y\}\{c/x\}) \\
&amp;\text{si } y' \notin fv(\zeta(y)b) \cup fv(c) \cup \{x\} \\
\end{align}
$$</p>
<p>(Notar que esto es parecido a las alfa conversiones del cálculo lambda)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unidad-4---programación-funcional"><a class="header" href="#unidad-4---programación-funcional">Unidad 4 - Programación Funcional</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resolución-proposicional"><a class="header" href="#resolución-proposicional">Resolución Proposicional</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resolución-en-lógica-de-primer-orden"><a class="header" href="#resolución-en-lógica-de-primer-orden">Resolución en lógica de primer orden</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resolución-sld"><a class="header" href="#resolución-sld">Resolución SLD</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prolog"><a class="header" href="#prolog">Prolog</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prácticas"><a class="header" href="#prácticas">Prácticas</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guia-0---repaso-haskell"><a class="header" href="#guia-0---repaso-haskell">Guia 0 - Repaso Haskell</a></h1>
<h2 id="ejercicio-1-1"><a class="header" href="#ejercicio-1-1">Ejercicio 1</a></h2>
<p>Dar el tipo y describir el comportamiento de las siguientes funciones del módulo <code>Prelude</code> de Haskell:</p>
<p>Hago un par nomás (recomiendo primero jugar un poco con las funciones y si no les queda claro pueden usar <code>:doc NOMBRE_DE_LA_FUNCIÓN</code>):</p>
<ul>
<li><code>null</code>:</li>
</ul>
<pre><code class="language-haskell">ghci&gt; :type null
null :: Foldable t =&gt; t a -&gt; Bool
ghci&gt; null []
True
ghci&gt; null [1, 2 , 3]
False
</code></pre>
<p>Devuelve si una estructura está vacía o no</p>
<ul>
<li><code>head</code></li>
</ul>
<pre><code class="language-haskell">ghci&gt; :type head
head :: GHC.Stack.Types.HasCallStack =&gt; [a] -&gt; a
ghci&gt; head []
*** Exception: Prelude.head: empty list
CallStack (from HasCallStack):
  error, called at libraries/base/GHC/List.hs:1646:3 in base:GHC.List
  errorEmptyList, called at libraries/base/GHC/List.hs:85:11 in base:GHC.List
  badHead, called at libraries/base/GHC/List.hs:81:28 in base:GHC.List
  head, called at &lt;interactive&gt;:9:1 in interactive:Ghci3
ghci&gt; head [1, 2]
1
</code></pre>
<p>Devuelve el primer elemento de una lista</p>
<ul>
<li><code>take</code></li>
</ul>
<pre><code class="language-haskell">ghci&gt; :type take
take :: Int -&gt; [a] -&gt; [a]
ghci&gt; take 3 [1, 2 , 3, 4]
[1,2,3]
ghci&gt; take 3 [1, 2]
[1,2]
ghci&gt; take 3 []
[]
</code></pre>
<p>Recibe un número <code>n</code> y una lista, y devuelve los primeros <code>n</code> elementos de dicha lista.</p>
<ul>
<li><code>!!</code></li>
</ul>
<pre><code class="language-haskell">ghci&gt; :type (!!)
(!!) :: GHC.Stack.Types.HasCallStack =&gt; [a] -&gt; Int -&gt; a
ghci&gt; [1, 2, 3, 4] !! 2
3
ghci&gt; [1, 2, 3, 4] !! 3
4
ghci&gt; [1, 2, 3, 4] !! 0
1
</code></pre>
<p>Es el operador de indexado.</p>
<h2 id="ejercicio-2-1"><a class="header" href="#ejercicio-2-1">Ejercicio 2</a></h2>
<p>Definir las siguientes funciones:</p>
<ul>
<li><code>valorAbsoluto :: Float -&gt; Float</code> que dado un número devuelve su valor absoluto.</li>
</ul>
<pre><code class="language-haskell">valorAbsoluto :: Float -&gt; Float
valorAbsoluto = abs
</code></pre>
<ul>
<li><code>bisiesto :: Int -&gt; Bool</code> que dado un número que representa un año, indica si el mismo es bisiesto.</li>
</ul>
<pre><code class="language-haskell">bisiesto :: Int -&gt; Bool
bisiesto anio | mod anio 4 == 0 = True
              | otherwise       = False
</code></pre>
<ul>
<li><code>factorial :: Int -&gt; Int</code> definida únicamente para enteros positivos, que computa el factorial.</li>
</ul>
<pre><code class="language-haskell">factorial :: Int -&gt; Int
factorial 1 = 1
factorial n = n * factorial (n-1)
</code></pre>
<ul>
<li><code>cantDivisoresPrimos :: Int -&gt; Int</code>, que dado un entero positivo devuelve la cantidad de divisores primos</li>
</ul>
<pre><code class="language-haskell">valorAbsoluto :: Float -&gt; Float
valorAbsoluto = abs

bisiesto :: Int -&gt; Bool
bisiesto anio | mod anio 4 == 0 = True
              | otherwise       = False

factorial :: Int -&gt; Int
factorial 1 = 1
factorial n = n * factorial (n-1)

cantDivisoresPrimos :: Int -&gt; Int
cantDivisoresPrimos n = cantDivisoresPrimosMenoresA n n

cantDivisoresPrimosMenoresA :: Int -&gt; Int -&gt; Int
cantDivisoresPrimosMenoresA _ 1 = 0
cantDivisoresPrimosMenoresA n divisorCandidato | esPrimo divisorCandidato &amp;&amp; mod n divisorCandidato == 0 = 1 + divisoresMenores
                                               | otherwise                   = divisoresMenores
                                              where divisoresMenores = cantDivisoresPrimosMenoresA n (divisorCandidato - 1)

esPrimo :: Int -&gt; Bool
esPrimo n = cantDivisoresMenoresA n n == 2

cantDivisoresMenoresA :: Int -&gt; Int -&gt; Int
cantDivisoresMenoresA _ 1 = 1
cantDivisoresMenoresA n divisorCandidato | mod n divisorCandidato == 0 = 1 + divisoresMenores
                                         | otherwise                   = divisoresMenores
                                         where divisoresMenores = cantDivisoresMenoresA n (divisorCandidato - 1)
</code></pre>
<h2 id="ejercicio-3-1"><a class="header" href="#ejercicio-3-1">Ejercicio 3</a></h2>
<p>Contamos con los tipos <code>Maybe</code> y <code>Either</code> definidos como sigue:</p>
<pre><code class="language-haskell">data Maybe a = Nothing | Just a
data Either a b = Left a | Right b
</code></pre>
<ul>
<li>Definir la función <code>inverso :: Float -&gt; Maybe Float</code> que dado un número devuelve su inverso multiplicativo si está definido, o <code>Nothing</code> en caso contrario.</li>
</ul>
<pre><code class="language-haskell">inverso :: Float -&gt; Maybe Float
inverso 0.0 = Nothing
inverso x = Just (1.0 / x)
</code></pre>
<ul>
<li>Definir la función <code>aEntero :: Either Int Bool -&gt; Int</code> que convierte a entero una expresión que puede ser booleana o entera. En el caso de los booleanos, el entero que corresponde es 0 para <code>False</code> y 1 para <code>True</code>.</li>
</ul>
<pre><code class="language-haskell">aEntero :: Either Int Bool -&gt; Int
aEntero (Left unEntero) = unEntero
aEntero (Right True) = 1
aEntero (Right False) = 0
</code></pre>
<h2 id="ejercicio-4-1"><a class="header" href="#ejercicio-4-1">Ejercicio 4</a></h2>
<p>Definir las siguientes funciones sobre listas:</p>
<ul>
<li><code>limpiar :: String -&gt; String -&gt; String</code>, que elimina todas las apariciones de cualquier carácter de la primera cadena en la segunda. Por ejemplo, <code>limpiar "susto" "puerta"</code> evalúa a <code>"pera"</code>. Nota: <code>String</code> es un renombre de <code>[Char]</code>. La notación <code>"hola"</code> es equivalente a <code>['h', 'o', 'l', 'a']</code> y a <code>'h':'o':'l':'a':[]</code></li>
</ul>
<pre><code class="language-haskell">limpiar :: String -&gt; String -&gt; String
limpiar [] fromStr = fromStr 
limpiar (unChar:restoDelPatron) fromStr = limpiar restoDelPatron (filter (/= unChar) fromStr) 
</code></pre>
<ul>
<li><code>difPromedio :: [Float] -&gt; [Float]</code> que dada una lista de números devuelve la diferencia de cada uno con el promedio general. Por ejemplo, <code>difPromedio [2, 3, 4]</code> evalúa a <code>[-1, 0, 1]</code>.</li>
</ul>
<pre><code class="language-haskell">difPromedio :: [Float] -&gt; [Float]
difPromedio xs = map (\x -&gt; x - promedioXs) xs
              where promedioXs = promedio xs

promedio :: [Float] -&gt; Float
promedio [] = 0.0
promedio xs = sum xs / fromIntegral (length xs)
</code></pre>
<ul>
<li><code>todosIguales :: [Int] -&gt; Bool</code> que indica si una lista de enteros tiene todos sus elementos iguales.</li>
</ul>
<pre><code class="language-haskell">todosIguales :: [Int] -&gt; Bool
todosIguales [] = True
todosIguales (x:xs) = all (== x) xs
</code></pre>
<h2 id="ejercicio-5-1"><a class="header" href="#ejercicio-5-1">Ejercicio 5</a></h2>
<p>Dado el siguiente modelo para árboles binarios:</p>
<pre><code class="language-haskell">data AB a = Nil | Bin (AB a) a (AB a)
</code></pre>
<p>definir las siguientes funciones:</p>
<ul>
<li><code>vacioAB :: AB a -&gt; Bool</code> que indica si un árbol es vacío (i.e. no tiene nodos)</li>
</ul>
<pre><code class="language-haskell">vacioAB :: AB a -&gt; Bool
vacioAB Nil = True
vacioAB _ = False
</code></pre>
<ul>
<li><code>negacionAB :: AB bool -&gt; AB Bool</code> que dado un árbol de booleanos construye otro formulado por la negación de cada uno de los nodos.</li>
</ul>
<pre><code class="language-haskell">negacionAB :: AB Bool -&gt; AB Bool
negacionAB Nil = Nil
negacionAB (Bin (hijoIzq) nodo (hijoDer)) = Bin (negacionAB hijoIzq) (not nodo) (negacionAB hijoDer)
</code></pre>
<ul>
<li><code>productoAB :: AB Int -&gt; Int</code> que calcula el producto de todos los nodos del árbol</li>
</ul>
<pre><code class="language-haskell">productoAB :: AB Int -&gt; Int
productoAB Nil = 1
productoAB (Bin hijoIzq nodo hijoDer) = productoAB hijoIzq * nodo * productoAB hijoDer
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guia-1---programación-funcional"><a class="header" href="#guia-1---programación-funcional">Guia 1 - Programación funcional</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guia-2---cálculo-lambda-tipado"><a class="header" href="#guia-2---cálculo-lambda-tipado">Guia 2 - Cálculo Lambda Tipado</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guia-3---inferencia-de-tipos"><a class="header" href="#guia-3---inferencia-de-tipos">Guia 3 - Inferencia de Tipos</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guia-4---subtipado"><a class="header" href="#guia-4---subtipado">Guia 4 - Subtipado</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guia-5---programación-orientada-a-objetos"><a class="header" href="#guia-5---programación-orientada-a-objetos">Guia 5 - Programación Orientada a Objetos</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guia-6---resolución-lógica"><a class="header" href="#guia-6---resolución-lógica">Guia 6 - Resolución Lógica</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guia-7---programación-lógica"><a class="header" href="#guia-7---programación-lógica">Guia 7 - Programación Lógica</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bibliografía"><a class="header" href="#bibliografía">Bibliografía</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>
        <script src="theme/pagetoc.js"></script>

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
