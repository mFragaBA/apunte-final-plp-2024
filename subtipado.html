<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Subtipado - Apunte Final Paradigmas de Lenguajes de Programación 2024</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./custom.css">
        <link rel="stylesheet" href="./mdbook-admonish.css">
        <link rel="stylesheet" href="theme/pagetoc.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="unidad_1.html"><strong aria-hidden="true">1.</strong> Unidad 1 - Programación Funcional Con Haskell</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="programacion_funcional.html"><strong aria-hidden="true">1.1.</strong> Intro a Haskell</a></li><li class="chapter-item expanded "><a href="esquemas_de_recursion.html"><strong aria-hidden="true">1.2.</strong> Esquemas de recursión</a></li></ol></li><li class="chapter-item expanded "><a href="unidad_2.html"><strong aria-hidden="true">2.</strong> Unidad 2 - Cálculo Lambda</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lambda_calc_booleano.html"><strong aria-hidden="true">2.1.</strong> Cálculo Lambda Tipado Booleano</a></li><li class="chapter-item expanded "><a href="lambda_calc_extendido.html"><strong aria-hidden="true">2.2.</strong> Cálculo Lambda Tipado Extendido</a></li><li class="chapter-item expanded "><a href="inferencia_de_tipos.html"><strong aria-hidden="true">2.3.</strong> Inferencia de tipos</a></li><li class="chapter-item expanded "><a href="subtipado.html" class="active"><strong aria-hidden="true">2.4.</strong> Subtipado</a></li></ol></li><li class="chapter-item expanded "><a href="unidad_3.html"><strong aria-hidden="true">3.</strong> Unidad 3 - Paradigma de Objetos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="javascript_intro.html"><strong aria-hidden="true">3.1.</strong> Intro a POO</a></li><li class="chapter-item expanded "><a href="sigma_calc.html"><strong aria-hidden="true">3.2.</strong> Cálculo Sigma</a></li></ol></li><li class="chapter-item expanded "><a href="unidad_4.html"><strong aria-hidden="true">4.</strong> Unidad 4 - Programación Lógica</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="prop_solv.html"><strong aria-hidden="true">4.1.</strong> Resolución Proposicional</a></li><li class="chapter-item expanded "><a href="primer_orden_solv.html"><strong aria-hidden="true">4.2.</strong> Resolución en lógica de primer orden</a></li><li class="chapter-item expanded "><a href="sld_solv.html"><strong aria-hidden="true">4.3.</strong> Resolución SLD</a></li><li class="chapter-item expanded "><a href="prolog.html"><strong aria-hidden="true">4.4.</strong> Prolog</a></li></ol></li><li class="chapter-item expanded "><a href="practicas.html"><strong aria-hidden="true">5.</strong> Prácticas</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="guia_0.html"><strong aria-hidden="true">5.1.</strong> Guia 0 - Repaso Haskell</a></li><li class="chapter-item expanded "><a href="guia_1.html"><strong aria-hidden="true">5.2.</strong> Guia 1 - Programación funcional</a></li><li class="chapter-item expanded "><a href="guia_2.html"><strong aria-hidden="true">5.3.</strong> Guia 2 - Cálculo Lambda Tipado</a></li><li class="chapter-item expanded "><a href="guia_3.html"><strong aria-hidden="true">5.4.</strong> Guia 3 - Inferencia de Tipos</a></li><li class="chapter-item expanded "><a href="guia_4.html"><strong aria-hidden="true">5.5.</strong> Guia 4 - Subtipado</a></li><li class="chapter-item expanded "><a href="guia_5.html"><strong aria-hidden="true">5.6.</strong> Guia 5 - Programación Orientada a Objetos</a></li><li class="chapter-item expanded "><a href="guia_6.html"><strong aria-hidden="true">5.7.</strong> Guia 6 - Resolución Lógica</a></li><li class="chapter-item expanded "><a href="guia_7.html"><strong aria-hidden="true">5.8.</strong> Guia 7 - Programación Lógica</a></li></ol></li><li class="chapter-item expanded "><a href="bibliografía.html"><strong aria-hidden="true">6.</strong> Bibliografía</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Apunte Final Paradigmas de Lenguajes de Programación 2024</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main><div class="sidetoc"><nav class="pagetoc"></nav></div>
                        <p>$$
\newcommand{\ifLC}[3]{if\  {#1}\  then\  {#2}\  else\  {#3}}
\newcommand{\lf}[3]{\lambda{#1}:\ {#2}.{#3}}
\newcommand{\apply}[2]{{#1}\ {#2}}
\newcommand{\hastype}[3]{{#1} \triangleright {#2}: {#3}}
\newcommand{\tapp}[5]{\frac{\hastype{#1}{#2}{#3 \rightarrow #4}\ \ \hastype{#1}{#5}{#3}}{\hastype{#1}{\apply{{#2}}{{#5}}}{#4}} (T-app)}
$$</p>
<h1 id="subtipado"><a class="header" href="#subtipado">Subtipado</a></h1>
<h2 id="por-qué"><a class="header" href="#por-qué">Por qué?</a></h2>
<p>Arrancamos con un cálculo lambda bastante simple, y le fuimos agregando
extensiones para hacer cosas más interesantes (registros, referencias, side
effects, fix, etc.). Ahora vamos a ver una extensión más, que va a flexibilizar
un poco el sistema de tipos.</p>
<p>Qué quiere decir esto? Bueno, que hay casos donde sabemos que el programa no va
a "romper", pero nuestro sistema de tipos rechaza ese término. Pensar que el
objetivo del sistema de tipos en parte es rechazar términos que no tienen
sentido. Veamos un ejemplo:</p>
<p>$$
\apply{\lf{x}{\{a: Nat\}}{x.a}}{\{a = 1, b = true\}}
$$</p>
<p>A simple vista parece que funciona, pero el término es rechazado porque el tipo
del registro también incluye lo que pasa con \(b\). Pero a mi qué me importa
que tenga \(b\) en el contexto de la lambda?</p>
<h2 id="principio-de-sustitutividad"><a class="header" href="#principio-de-sustitutividad">Principio de sustitutividad</a></h2>
<p>Definimos la siguiente expresión:</p>
<p>$$
\sigma &lt;: \tau
$$</p>
<p>Que quiere decir que en todo contexto donde se espera una expresión de tipo
\tau, puedo pasarle una de tipo \sigma y también funciona. Es mucho muy
importante entender esto y ante la duda hacer con un ejemplo (o tomar el caso
puntual) y preguntarte, con qué tipo anda y con qué tipo quiero que también
funcione.</p>
<p>Esto mismo se expresa con la regla de tipado de Subsumption (Subsumisión):</p>
<p>$$
\frac{\hastype{\Gamma}{M}{\sigma}\ \ \ \sigma &lt;: \tau}{\hastype{\Gamma}{M}{\tau}} (T-Subs)
$$</p>
<div id="admonition-subtipado-de-tipos-básicos" class="admonition admonish-info">
<div class="admonition-title">
<p>Subtipado de tipos básicos</p>
<p><a class="admonition-anchor-link" href="#admonition-subtipado-de-tipos-básicos"></a></p>
</div>
<div>
<ul>
<li>\(Nat &lt;: Float\)
<ul>
<li>"Siempre que tenga un término que acepta float puedo usar un nat y no debería romper"</li>
</ul>
</li>
<li>\(Int &lt;: Float\)
<ul>
<li>"Siempre que tenga un término que acepta float puedo usar un int y no debería romper"</li>
</ul>
</li>
<li>\(Bool &lt;: Nat\)
<ul>
<li>"Siempre que tenga un término que acepta Nat puedo usar un bool y no debería romper"</li>
</ul>
</li>
</ul>
</div>
</div>
<p>Algo interesante que agrega este operador es que induce un pre-orden, o sea que es reflexiva y transitiva:</p>
<div style="width:330px;">
<p>$$
\frac{}{\sigma &lt;: \sigma} (T-Refl) \\
\frac{\sigma &lt;: \tau\ \ \ \tau &lt;: \rho}{\sigma &lt;: \rho} (T-Trans)
$$</p>
</div>
<div style="float:right;margin-left:2rem;margin-bottom:3rem;margin-top:-10rem;width:330px">
<blockquote>
<p>Nota: No es ni antisimétrica ni simétrica</p>
</blockquote>
<div id="admonition-querríamos-tener-un-orden-total" class="admonition admonish-question">
<div class="admonition-title">
<p>Querríamos tener un orden total?</p>
<p><a class="admonition-anchor-link" href="#admonition-querríamos-tener-un-orden-total"></a></p>
</div>
<div>
<p>A priori suena medio raro, porque hay cosas que ni tienen sentido comparar. No
tiene mucho sentido comparar por ejemplo un entero con una función, o un
booleano con una función. Pero capaz si tiene sentido comparar las funciones
según su tipo de entrada y salida.</p>
</div>
</div>
</div>
<h2 id="revisitando-las-reglas-de-tipado-para-lambdacálculo-con-registros"><a class="header" href="#revisitando-las-reglas-de-tipado-para-lambdacálculo-con-registros">Revisitando las reglas de tipado para lambdacálculo con registros</a></h2>
<p>A priori las reglas más básicas \(T-Var\), \(T-Var\), \(T-Abs\) y
\(T-App\) no requieren cambios.</p>
<p>Por otro lado teníamos las <a href="./lambda_calc_extendido.html#reglas-de-tipado">reglas de tipado</a> para registros \(T-Rcd\) y \(T-Proj\) para los registros y su proyección:</p>
</br>
</br>
<p>$$
\frac{\Gamma \triangleright M_i : \sigma_i\ \text{para cada } i \in 1 \dots n}{\Gamma \triangleright \{l_i = M_i^{i \in 1 \dots n} \} : \{l_i : \sigma_i^{i \in 1 \dots n}\}} (T-RCD) \\
\frac{\Gamma \triangleright M_i : \{l_i : \sigma_i^{i \in 1 \dots n}\}\ j \in 1 \dots n}{\Gamma \triangleright M.I_j : \sigma_j} (T-Proj)
$$</p>
<p>Ahora, lo siguiente que vamos a hacer es introducir la regla \(T-Trans\), y
la vamos a usar para agregar nuevas reglas.</p>
<h3 id="subtipados-de-registros-a-lo-ancho"><a class="header" href="#subtipados-de-registros-a-lo-ancho">Subtipados de registros a lo "ancho"</a></h3>
<p>Idea de la regla: si yo tengo algo que tipa para un registro, agregarle más
cosas a dicho registro no debería de cambiar nada. Por ejemplo: <code>{nombre: String, edad: Int} &lt;: {nombre: String}</code>.</p>
<p>Generalizando, nos quedaría:</p>
<p>$$
\frac{}{\{l_i: \sigma_i\ |\ i \in 1\dots n + k\} &lt;: \{l_i: \sigma_i\ |\ i \in 1\dots n\}} (S-RcdWidth)
$$</p>
<ul>
<li>Nota: \(\sigma &lt;: \{\}\) para todo registro \(\sigma\).</li>
<li>Hay algún tipo registro \(t\) tal que \(\tau &lt;: \sigma\) para todo tipo registro \(\sigma\).
<ul>
<li>yo creo que no, porque basta con agarrar un registro que tenga una etiqueta que \(t\) no use y armar un registro con eso.</li>
</ul>
</li>
</ul>
<h3 id="subtipado-en-profundidad"><a class="header" href="#subtipado-en-profundidad">Subtipado "en profundidad"</a></h3>
<p>Si yo tuviese <code>{a: Nat, b: Int} ? {a: Float, b: Int}</code>. Qué va en el <code>?</code>? Bueno,
si yo cuando espero un <code>Float</code> me pasan un <code>Nat</code> y anda, debería de pasar lo
mismo si para una etiqueta el tipo es <code>Float</code> y me pasan algo que para esa
etiqueta el tipo es <code>Nat</code>. Generalizando eso se escribe como:</p>
<p>$$
\frac{\sigma_i &lt;: \tau_i\ i \in \{1 \dots n\}}{\{l_i: \sigma_i\ |\ i \in 1\dots n\} &lt;: \{l_i: \tau_i\ |\ i \in 1\dots n\}} (S-RcdDepth)
$$</p>
<ul>
<li>Notar que la restricción la hacemos sobre todos los campos (como el subtipado
es reflexivo no nos trae muchos problemas y no perdemos flexibilidad vs
escribir la regla sobre un label puntual).</li>
<li>Ejemplo: <code>{x: {a: Nat, b: Nat}, y: {m: Nat}} &lt;: {x: {a: Nat}, y: {}}</code>. Vale pues:
<ul>
<li><code>{m: Nat} &lt;: {}</code> (value para cualquier cosa que ponga a la izquierda).</li>
<li><code>{a: Nat, b: Nat} &lt;: {a: Nat}</code> ya que es agregarle <code>b: Nat</code> a <code>{a: Nat}</code> (\(S-RcdWidth\))</li>
<li>Como para <code>x</code> e <code>y</code>, los tipos del término de la izquierda son subtipos de los de la derecha, + \(S-RcdDepth\) obtenemos que el término de la izquierda es subtipo del de la derecha</li>
</ul>
</li>
</ul>
<h3 id="permutaciones-de-campos"><a class="header" href="#permutaciones-de-campos">Permutaciones de campos</a></h3>
<p>Más que nada para simplificar el lenguaje, cuando definimos los registros
teníamos la restricción de que el tipo te fijaba el órden de las etiquetas, a
pesar de que con las etiquetas ya debería de ser suficiente independientemente
del orden. O sea, me da lo mismo tener <code>{a: String, b: Int}</code> que <code>{b: Int, a: String}</code>. Generalizando:</p>
<p>$$
\frac{\{k_j: \sigma_j\ j \in 1 \dots n\} \text{ es permutación de } \{l_i: \tau_i\ i \in 1 \dots n\}}{\{k_j: \sigma_j\ j \in 1 \dots n\} &lt;: \{l_i: \tau_i\ i \in 1 \dots n\}} (S-RcdPerm)
$$</p>
<div id="admonition-nota-eliminando-etiquetas" class="admonition admonish-info">
<div class="admonition-title">
<p>Nota: Eliminando etiquetas</p>
<p><a class="admonition-anchor-link" href="#admonition-nota-eliminando-etiquetas"></a></p>
</div>
<div>
<p>Usando \(S-RcdWidth\) + \(S-Trans\) + \(S-RcdPerm\) puedo eliminar campos en cualquier parte del registro</p>
<ul>
<li>lo puedo lograr reordenando los campos que no quiero al fondo y después eliminandolos</li>
<li>podría armar una regla nueva también, pero ya con lo que tenemos tenemos una base</li>
</ul>
<p>$$
\frac{\{l_i: \tau_i\ i \in 1 \dots n\} \subseteq \{k_j: \sigma_j\ j \in 1 \dots m\}\ \ \ \ k_j = l_i \implies \sigma_j &lt;: \tau_i}{\{k_j: \sigma_j\ j \in 1 \dots n\} &lt;: \{l_i: \tau_i\ i \in 1 \dots n\}} (S-Rcd)
$$</p>
<p>O sea que si:</p>
<ul>
<li>tengo un subconjunto de las etiquetas (está implícito que tiene más campos) y</li>
<li>en aquellas que coincide su tipo correspondiente es subtipo del otro</li>
</ul>
<p>Entonces un tipo registro es subtipo del otro. Para hacer las pruebas vamos a usar esta regla (más que nada para ahorrarnos pasos y que quede una demo más directa)</p>
</div>
</div>
<h2 id="subtipado-de-tipos-función"><a class="header" href="#subtipado-de-tipos-función">Subtipado de tipos función</a></h2>
<p>Cómo funcionaría para las funciones? Si yo quiero que \(\sigma_1 \rightarrow \tau_1 &lt;: \sigma_2 \rightarrow \tau_2\), qué le tengo que pedir a \(\sigma_1, \sigma_2, \tau_1, \tau_2\)?</p>
<p>Primero, hay que tener como base que lo que quiero es que a una función que acepta \(\sigma_2 \rightarrow \tau_2\) le pueda pasar algo de tipo \(\sigma_1 \rightarrow \tau_1\). Esto significaría:</p>
<ul>
<li>Que el dominio tiene que ser compatible, o sea que las cosas de \(\sigma_2\) que se le pasaban a la función funcionen con cosas de \(sigma_1\).
<ul>
<li>o sea \(\sigma_2 &lt;: \sigma_1\)</li>
</ul>
</li>
<li>Que el resultado de la función funcione en lugar del tipo que devolvía lo otra función.
<ul>
<li>o sea \(\tau_1 &lt;: \tau_2\)</li>
</ul>
</li>
</ul>
<p>Veamos dos casos:</p>
<ul>
<li>Supongamos que tenemos los tipos <code>Nat</code> e <code>Int</code>, y mi código usaba una función
de tipo <code>Int -&gt; Int</code> (por ejemplo, la función <code>sumar_2 x = x + 2</code>). Si yo le
pasara la función raíz cuadrada que es de tipo <code>Nat -&gt; Nat</code> y en algún
momento se le pasaba un número negativo, explotaba!.</li>
<li>Mismos tipos que antes pero mi código usa una función de tipo <code>Nat -&gt; Nat</code>.
Si yo le paso una función de tipo <code>Int -&gt; Int</code> podría pasar que al resultado
de llamar a la función se lo pasara a la función raíz cuadrada, y de vuelta
si en alguna situación mi nueva función daba como resultado un número
negativo, también explotaría.</li>
</ul>
<p>La regla entonces que sacamos de esto es (en la teórica están al revés los tipos):</p>
<p>$$
\frac{\sigma' &lt;: \sigma\ \ \tau &lt;: \tau'}{\sigma \rightarrow \tau &lt;: \sigma' \rightarrow \tau'} (S-Arrow)
$$</p>
<p>Se dice que el constructor de tipos función es <strong>contravariante</strong> en su primer argumento y <strong>variante</strong> en el segundo.</p>
<h2 id="subtipado-de-referencias"><a class="header" href="#subtipado-de-referencias">Subtipado de referencias</a></h2>
<p>Es covariante? Veamos cómo sería la regla (covariante):</p>
<p>$$
\frac{\sigma &lt;: \tau}{Ref \sigma &lt;: Ref \tau}
$$</p>
<p>Qué pasa?</p>
<ul>
<li>La desreferencia tiene sentido que ande</li>
<li>Pero y si intento escribir? Veámos un ejemplo:</li>
</ul>
<pre><code>let r = ref 3 (*r: Ref Int*)
in r := 2.1;
!r
</code></pre>
<ul>
<li>En el ejemplo, tengo que <code>Int &lt;: Float</code>, y sin embargo <code>Ref Int &lt;: Ref Float</code>
no vale porque a la hora de asignar estaría asignándole un <code>Float</code> a algo a
lo que sólo puede recibir un <code>Int</code></li>
</ul>
<p>Por lo tanto es contravariante, no?</p>
<p>$$
\frac{\tau &lt;: \sigma}{Ref \sigma &lt;: Ref \tau}
$$</p>
<p>Qué pasa con:</p>
<pre><code>let r = ref 3.2 (*r: Ref Float*)
in succ(!r)
</code></pre>
<p>Ahora tengo el otro problema: si asumo que es contravariante, como <code>Int &lt;: Float</code>, obtengo que <code>Ref Float &lt;: Ref Int</code>, lo cual significaría que donde
espere una referencia a un entero puedo pasarle una referencia a un float y
anda. Claramente en el ejemplo no puedo pasar una referencia a un float porque
<code>succ</code> no tipa.</p>
<h3 id="la-desilusión"><a class="header" href="#la-desilusión">La desilusión...</a></h3>
<p>Ah, que bien esto de subtipado, no me sirve para nada!!!!!</p>
<p><img src="./img/nacagada.png#center" alt="" /></p>
<p>Pero a no desesperar. Vamos a hacer un último empujón para hacerlo andar. Qué
pasa si a la regla le pedimos que los tipos sean equivalentes. Eso resolvería
nuestros problemas porque al leer de un tipo coerciono contra el otro, y al
escribir hago lo mismo a la inversa. Eso quedaría:</p>
<p>$$
\frac{\sigma &lt;: \tau\ \ \tau &lt;: \sigma}{Ref \sigma &lt;: Ref \tau}
$$</p>
<p>Notar que el orden de los refs abajo es intercambiable. O sea que si dos tipos
son equivalentes, sus referencias también lo serán. Cuando esto sucede, decimos
que el tipo (Ref en este caso) es <strong>Invariante</strong>.</p>
<h3 id="refinando-ref"><a class="header" href="#refinando-ref">Refinando \(Ref\)</a></h3>
<p>La solución anterior no me deja del todo satisfecho porque lo que trae
problemas es la co-existencia de la lectura y la escritura, ya que esas nos
restringen a ser covariante o contravariante. Y en muchos casos, puedo
únicamente querer leer o únicamente escribir.</p>
<p>Entonces, vamos a separar las referencias dependiendo de si son de lectura o de
esritura. Vamos a definir 2 tipos de referencias nuevos:</p>
<ul>
<li>\(Source\ \sigma\) para las referencias de lectura</li>
<li>\(Sink\ \sigma\) para las referencias de escritura</li>
</ul>
<p>Las reglas de tipado para ambos términos son:</p>
<p>$$
\frac{\hastype{\Gamma|\Sigma}{M}{Source \sigma}}{\hastype{\Gamma|\Sigma}{!M}{\sigma}} \\
\frac{\hastype{\Gamma|\Sigma}{M}{Sink\ \sigma}\ \hastype{\Gamma|\Sigma}{N}{\sigma}}{\hastype{\Gamma|\Sigma}{M := N}{Unit}}
$$</p>
<p>Ahora, estoy forzando a que a un source únicamente le hago la desreferencia, y
a un sink le hago una asignación. Además, por la lógica vista anteriormente,
nos quedaría que el source va a ser covariante (\(S-Source\)) y el sink contravariante (\(S-Sink\)):</p>
<p>$$
\frac{\sigma &lt;: \tau}{Source \sigma &lt;: Source \tau} \\
\frac{\sigma &lt;: \tau}{Sink \tau &lt;: Sink \sigma}
$$</p>
<p>Un último detalle, porque recuerdo que el ejemplo era:</p>
<pre><code>let r = ref 3
in r := 2.1;
!r
</code></pre>
<p>Acá estoy tanto leyendo como escribiendo en la referencia! A priori no me
funciona mi abstracción... o sí? Bueno, hay que agregar una cosa más, y es
poder "downgradear" las referencias a \(Sink\) o \(Source\) dependiendo de
lo que se necesite.</p>
<p>Para eso sumamos las reglas:</p>
<p>$$
\frac{}{Ref\ \sigma &lt;: Source\ \sigma} \\
\frac{}{Ref\ \sigma &lt;: Sink\ \sigma}
$$</p>
<p>Con eso en el ejemplo tendría:</p>
<pre><code>let r = ref 3 (* el ref 3 va a ser de tipo Ref Int*)
in r := 2.1; (* esto lo tipo como sink, y uso que ref es subtipo*)
!r
</code></pre>
<h2 id="dándole-un-uso"><a class="header" href="#dándole-un-uso">Dándole un uso</a></h2>
<p><a href="#principio-de-sustitutividad">Al principio de todo</a> dijimos que agregábamos la
regla de subsumption. Esto cambia en parte la lógica de nuestro algoritmo de
chequeo de tipos, porque hasta ahora todas las reglas estaban guiadas por
sintáxis, y la regla que introducimos está guiada por la "oportunidad" del tipo
(o sea según te convenga). Cómo haríamos con eso para implementar un algoritmo
de chequeo de tipos? Idealmente, me gustaría poder sacar la regla \(T-Subs\).
Entonces, para eso vamos a mirar en qué casos pueden haber incompatibilidades
de tipos. Si revisamos la reglas, todas son de la pinta "instancio un tipo y le
asigno el tipo abajo y restrinjo el tipo arriba". La única regla que parecería
agregar nuevos tipos es la de la aplicación \(T-App\):</p>
<p>$$
\tapp{\Gamma}{M}{\tau}{\sigma}{N}
$$</p>
<p>Entonces la idea es tomar esa regla, y cambiar lo que nos da problemas, que es
el tipo de \(N\). Vamos a pedir que el tipo de \(N\) sea subtipo de lo que
sea que acepta \(M\):</p>
<p>$$
\frac{\hastype{\Gamma}{M}{\sigma \rightarrow \tau}\ \ \hastype{\Gamma}{N}{\rho}\ \ \rho &lt;: \tau}{\hastype{\Gamma}{\apply{M}{N}}{\tau}} (T-App')
$$</p>
<p>Hay un resultado que nos dice que:</p>
<ul>
<li>Si en este nuevo sistema de tipado pude asignar un tipo válido a un término,
entonces también lo puedo hacer con el que tiene la regla de subsumption
libre (lo cual tiene sentido, ya que el otro me permite hacer lo mismo y
meter la regla de subsumption donde se me cante.</li>
<li>Pero además, el resulado dice que en el recíproco, si vos probaste que tu
término tiene tipo \(\sigma\), entonces con esta variante podés probar que
tiene tipo \(\rho\), con \(\rho &lt;: \tau\) (o sea que capaz es un poquito
más restrictivo, pero al menos tengo una implementación más directa).</li>
</ul>
<h3 id="más-problemas"><a class="header" href="#más-problemas">Más problemas</a></h3>
<p>Si bien me saqué de encima \(T-Subs\), todavía me quedan algunas reglas que no están guiadas por sintáxis. En particular \(S-Refl\) y \(S-Trans\) (ponele que en \(S-Func\) podría llegar a zafar porque tengo funciones). Por suerte hay solución:</p>
<div id="admonition-ojo" class="admonition admonish-warning">
<div class="admonition-title">
<p>Ojo</p>
<p><a class="admonition-anchor-link" href="#admonition-ojo"></a></p>
</div>
<div>
<p>Que no están guiadas por sintáxis en este caso no refiere al término si no a la
sintáxis de los tipos. A esas reglas les da lo mismo si tengo \(Nat\) o si
tengo \(Nat -&gt; Nat\).</p>
</div>
</div>
<ul>
<li>se puede probar que \(\sigma &lt;: \sigma\) se puede derivar si tengo
reflexividad para tipos escalares (asumidos como axiomas):
<ul>
<li>\(Nat &lt;: Nat\)</li>
<li>\(Int &lt;: Int\)</li>
<li>\(Bool &lt;: Bool\)</li>
<li>\(Float &lt;: Float\)</li>
</ul>
</li>
<li>además recuerdo que tengo un par de reglas axiomáticas que relacionan los
tipos escalares:
<ul>
<li>\(Nat &lt;: Float\)</li>
<li>\(Int &lt;: Float\)</li>
<li>\(Bool &lt;: Float\)</li>
</ul>
</li>
<li>de forma similar se puede probar que no hace falta la regla de transitividad \(S-Trans\), ya que tenemos transitividad en las reglas de tipado (ojo, no es tan directo pero tampoco voy a ahondar mucho en esto).</li>
</ul>
<h3 id="función-subtype"><a class="header" href="#función-subtype">Función <code>subtype</code></a></h3>
<p>Obviando los casos base para tipos escalares, nos quedaría algo así:</p>
<pre><code class="language-python">subtype(S, T):
    # Manejar casos base
    if S == S1 -&gt; S2 and T = T1 -&gt; T2:
        subtype(T1, S1) and subtype(S2, T2)
    else:
        if S == {k_j: S_j, j in (1..m)} and T == {l_i: T_i, i in (1..n)}:
            subseteq({l_i, i in (1..n)}, {k_j, j in (1..m)}) and all(i in (1..n) -&gt; exists(j in (1..m) -&gt; k_j = l_i and subtype(S_j, T_i)))
        else: 
            false
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="inferencia_de_tipos.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="unidad_3.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="inferencia_de_tipos.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="unidad_3.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>
        <script src="theme/pagetoc.js"></script>


    </div>
    </body>
</html>
