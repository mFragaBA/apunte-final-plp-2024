<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Apunte Final Paradigmas de Lenguajes de Programación 2024</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./custom.css">
        <link rel="stylesheet" href="./mdbook-admonish.css">
        <link rel="stylesheet" href="theme/pagetoc.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="unidad_1.html"><strong aria-hidden="true">1.</strong> Unidad 1 - Programación Funcional Con Haskell</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="programacion_funcional.html"><strong aria-hidden="true">1.1.</strong> Intro a Haskell</a></li></ol></li><li class="chapter-item expanded "><a href="unidad_2.html"><strong aria-hidden="true">2.</strong> Unidad 2 - Cálculo Lambda</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lambda_calc_booleano.html"><strong aria-hidden="true">2.1.</strong> Cálculo Lambda Tipado Bolleano</a></li><li class="chapter-item expanded "><a href="lambda_calc_extendido.html"><strong aria-hidden="true">2.2.</strong> Cálculo Lambda Tipado Extendido</a></li><li class="chapter-item expanded "><a href="inferencia_de_tipos.html"><strong aria-hidden="true">2.3.</strong> Inferencia de tipos</a></li><li class="chapter-item expanded "><a href="subtipado.html"><strong aria-hidden="true">2.4.</strong> Subtipado</a></li></ol></li><li class="chapter-item expanded "><a href="unidad_3.html"><strong aria-hidden="true">3.</strong> Unidad 3 - Paradigma de Objetos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="javascript_intro.html"><strong aria-hidden="true">3.1.</strong> Intro a Javascript</a></li><li class="chapter-item expanded "><a href="sigma_calc.html"><strong aria-hidden="true">3.2.</strong> Cálculo Sigma</a></li></ol></li><li class="chapter-item expanded "><a href="unidad_4.html"><strong aria-hidden="true">4.</strong> Unidad 4 - Programación Lógica</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="prop_solv.html"><strong aria-hidden="true">4.1.</strong> Resolución Proposicional</a></li><li class="chapter-item expanded "><a href="primer_orden_solv.html"><strong aria-hidden="true">4.2.</strong> Resolución en lógica de primer orden</a></li><li class="chapter-item expanded "><a href="sld_solv.html"><strong aria-hidden="true">4.3.</strong> Resolución SLD</a></li><li class="chapter-item expanded "><a href="prolog.html"><strong aria-hidden="true">4.4.</strong> Prolog</a></li></ol></li><li class="chapter-item expanded "><a href="practicas.html"><strong aria-hidden="true">5.</strong> Prácticas</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="guia_0.html"><strong aria-hidden="true">5.1.</strong> Guia 0 - Repaso Haskell</a></li><li class="chapter-item expanded "><a href="guia_1.html"><strong aria-hidden="true">5.2.</strong> Guia 1 - Programación funcional</a></li><li class="chapter-item expanded "><a href="guia_2.html"><strong aria-hidden="true">5.3.</strong> Guia 2 - Cálculo Lambda Tipado</a></li><li class="chapter-item expanded "><a href="guia_3.html"><strong aria-hidden="true">5.4.</strong> Guia 3 - Inferencia de Tipos</a></li><li class="chapter-item expanded "><a href="guia_4.html"><strong aria-hidden="true">5.5.</strong> Guia 4 - Subtipado</a></li><li class="chapter-item expanded "><a href="guia_5.html"><strong aria-hidden="true">5.6.</strong> Guia 5 - Programación Orientada a Objetos</a></li><li class="chapter-item expanded "><a href="guia_6.html"><strong aria-hidden="true">5.7.</strong> Guia 6 - Resolución Lógica</a></li><li class="chapter-item expanded "><a href="guia_7.html"><strong aria-hidden="true">5.8.</strong> Guia 7 - Programación Lógica</a></li></ol></li><li class="chapter-item expanded "><a href="bibliografía.html"><strong aria-hidden="true">6.</strong> Bibliografía</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Apunte Final Paradigmas de Lenguajes de Programación 2024</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main><div class="sidetoc"><nav class="pagetoc"></nav></div>
                        <h1 id="unidad-1---paradigma-funcional"><a class="header" href="#unidad-1---paradigma-funcional">Unidad 1 - Paradigma funcional</a></h1>
<p><img src="./img/hold_up.png" alt="" /></p>
<p>La materia se llama "Paradigmas de Programación. Qué es un paradigma de programación:</p>
<ul>
<li><strong>paradigma</strong>: es una forma de pensamiento (a.k.a un marco teórico, un
conjunto de creencias).</li>
<li><strong>lenguaje de programación</strong>: el lenguaje que usamos para comunicar
instrucciones a una computadora.
<ul>
<li>describen <strong>cómputos</strong> (más de a qué me refiero con esto adelante)</li>
<li>es <strong>turing completo</strong> si puede expresar todas las funciones computables
(LyC war flashbacks). Los DSLs son ejemplos de lenguajes de programación
que no necesariamente son turing completos.</li>
<li>tiene que poder describir lo que hay que hacer de forma explícita y no
ambigua.</li>
</ul>
</li>
<li>Entonces un <strong>paradigma de lenguaje de programación</strong> lo vamos a entender
como un estilo de programación, que impacta en la forma en la que se encaran
las soluciones
<ul>
<li>Está muuuuuy vinculado al <strong>modelo de cómputo</strong>
<ul>
<li>A partir de un estado inicial llegar a un estado final.</li>
<li>En orga, por ejemplo parto de un estado inicial <strong>y aplico secuencias
de instrucciones para modificar el estado</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Entender de paradigmas de programación es una herramienta muy útil a la hora de
decidir qué lenguaje elijo para resulver un problema.</p>
<p>En este resumen (y porque es lo visto en clase) voy a hablar de los paradigmas:</p>
<ul>
<li>imperativo</li>
<li>funcional (vamos a usar haskell)</li>
<li>orientado a objetos (javascript)</li>
<li>lógico (vamos a usar prolog)</li>
</ul>
<p>Pero sepan que exiten más: concurrente, eventos, basado en continuaciones,
probabilístico, cuántico. Además, hoy en día los lenguajes más modernos suelen
tomar features de distintos paradigmas (por ejemplo: rust 🦀. Otro ejemplo es
la incorporación de funciones anónimas en los distintos lenguajes, que antes
estaba medio reservado a los lenguajes funcionales) entonces la linea entre un
paradigma y otro dentro de un lenguaje se vuelve más difusa.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="programación-funcional"><a class="header" href="#programación-funcional">Programación Funcional</a></h1>
<p>Si bien vamos a ver todo con lenguaje "haskelloso", la mayoría de conceptos
aplican a los lenguajes funcionales en general. Vamos a ver más formal el
modelo de cómputo de lenguajes funcionales cuando veamos cálculo lambda.</p>
<ul>
<li>
<p>Programar: Definir funciones</p>
</li>
<li>
<p>Ejecutar: Evaluar expresiones</p>
<pre><code># Programando
factorial(1) = 1
factorial(n) = factorial(n - 1) * n


# Evaluando
factorial(4) =&gt; factorial(3) * 4 
             =&gt; factorial(2) * 3 * 4 
             =&gt; factorial(1) * 2 * 3 * 4
             =&gt; 1 * 2 * 3 * 4
             =&gt; 6 * 4
             =&gt; 24
</code></pre>
</li>
<li>
<p>Un programa es un conjunto de ecuaciones</p>
</li>
<li>
<p>Expresiones</p>
<ul>
<li>Si se puede definir, toda expresión denota un valor</li>
<li>El valor depende únicamente del valor de sus subexpresiones</li>
<li>Evaluar/Reducir una expresión es obtener su valor (en el ejemplo <code>factorial(4) ~&gt; 24</code>)</li>
<li>No toda expresión denota un valor (si no puedo reducir no tengo un valor)</li>
</ul>
</li>
<li>
<p>Valores</p>
<ul>
<li>Los podemos pensar como expresiones que no se pueden seguir reduciendo</li>
</ul>
</li>
</ul>
<h2 id="tipos"><a class="header" href="#tipos">Tipos</a></h2>
<p>En Haskell organizamos los valores en <strong>tipos</strong>. El tipo tiene operaciones asociadas. En haskell se tienen:</p>
<ul>
<li>tipos básicos: <code>Int</code>, <code>Char</code>, <code>Float</code>, <code>Bool</code></li>
<li>tipos compuestos:
<ul>
<li>Listas: <code>[Int]</code></li>
<li>Tuplas: <code>(Int, Bool)</code></li>
<li>Funciones: <code>Int -&gt; Int</code></li>
</ul>
</li>
<li><strong>todo expresión bien formada tiene un tipo asociado</strong> (esto también, más
adelante vamos a ver que si no se le puede otorgar tipo a una expresión
entonces no se va a poder reducir) y el tipo depende del tipo de sus
subexpresiones.</li>
</ul>
<h2 id="funciones"><a class="header" href="#funciones">Funciones</a></h2>
<div id="admonition-definición" class="admonition admonish-note">
<div class="admonition-title">
<p>Definición</p>
<p><a class="admonition-anchor-link" href="programacion_funcional.html#admonition-definición"></a></p>
</div>
<div>
<ul>
<li>
<p>Definición con ecuación orientada:</p>
<pre><code class="language-haskell">doble :: Int -&gt; Int
doble x = x + x
</code></pre>
</li>
<li>
<p>Definición con guardas:</p>
<pre><code class="language-haskell">signo :: Int -&gt; Bool
signo n | n &gt;= 0    = True
        | otherwise = False
</code></pre>
</li>
<li>
<p>Definiciones locales:</p>
<pre><code class="language-haskell">f(x, y) = g x + y
        where g z = z + 2
</code></pre>
</li>
<li>
<p>Expresiones Lambda:</p>
<pre><code class="language-haskell">\x -&gt; x + 1
</code></pre>
</li>
</ul>
</div>
</div>
<h2 id="polimorfismo-paramétrico"><a class="header" href="#polimorfismo-paramétrico">Polimorfismo paramétrico</a></h2>
<p>Dada la siguiente función <code>id</code>, cuál es su tipo?</p>
<pre><code class="language-haskell">id x = x
</code></pre>
<p>Rta: <code>id :: a -&gt; a</code>, donde <code>a</code> es una variable de tipo (es algo así como un meta-tipo)</p>
<h2 id="clases-de-tipos"><a class="header" href="#clases-de-tipos">Clases de Tipos</a></h2>
<p>Cuál es el tipo de <code>máximo</code>?</p>
<pre><code class="language-haskell">maximo x y | x &gt; y      = x
maximo _ y              = y
</code></pre>
<p>Puedo probar de evaluar a <code>máximo</code>:</p>
<pre><code class="language-bash"># La evalúo con enteros y funciona
&gt; maximo 1 2
2
# La evalúo con decimales y también funciona
&gt; maximo 1.2 3.4
3.4
</code></pre>
<p>Una <strong>clase</strong> es una suerte de interface que define un conjunto de operaciones. Por ejemplo:</p>
<ul>
<li><code>Eq</code>: <code>(==)</code>, <code>(/=)</code></li>
<li><code>Ord</code>: <code>(&lt;)</code>, <code>(&lt;=)</code>, <code>(&gt;=)</code>, <code>(&gt;)</code>, <code>max</code>, <code>min</code>, <code>compare</code></li>
</ul>
<p>pVolviendo a <code>maximo</code>, tenemos que <code>maximo :: Ord a =&gt; a -&gt; a -&gt; a</code>. O sea que
en máximo puedo recibir cualquier tipo en tanto pertenezca a la clase <code>Ord</code>
(cosa de tener el comparador)</p>
<h2 id="instancia-de-una-clase-de-tipos"><a class="header" href="#instancia-de-una-clase-de-tipos">Instancia de una clase de tipos</a></h2>
<p>Notar que haskell permite usar el <code>deriving</code> que deriva automáticamente una
"implementación por default" de todas las funciones de <code>Eq</code>. En el caso de <code>Eq</code>
compara cada caso, si es <code>Circulo</code> compara el valor, y si es <code>Rectangulo</code>
compara ambos valores.</p>
<pre><code class="language-haskell">data Figura = Circulo Float | Rectangulo Float Float
deriving Eq
</code></pre>
<p>Pero también se pueden definir instancias con la lógica que quiera:</p>
<pre><code class="language-haskell">instance Ord Figura where
    (&lt;=) = \x -&gt; \y -&gt; area x &lt;= area y
</code></pre>
<h2 id="alto-orden"><a class="header" href="#alto-orden">Alto Orden</a></h2>
<p>En haskell, las funciones son lo que se conoce como first-class citizens, eso
significa que las funciones <strong>son un valor más</strong>. O sea que podés pasarlas como
parámetro, pueden ser el resultado de una función.</p>
<p>Por ejemplo, a <code>id</code> le puedo pasar <code>id</code>. Entonces, cuál sería el tipo de <code>id id</code>?</p>
<p>El tipo es <code>(id id) :: a -&gt; a</code></p>
<h2 id="currificación"><a class="header" href="#currificación">Currificación</a></h2>
<p>Veámoslo con 2 ejemplos:</p>
<pre><code class="language-haskell">suma :: ??
suma x y = x + y

suma' :: ??
suma' (x, y) = x + y
</code></pre>
<p>Si reviso los tipos obtengo que:</p>
<pre><code class="language-haskell">suma :: Int -&gt; Int -&gt; Int
suma' :: (Int, Int) -&gt; Int
</code></pre>
<p>Cuál es la diferencia? Que la primera implementación puedo hacer por ejemplo
<code>suma 5</code> y obtengo una función que incrementa en 5. Eso no lo puedo hacer con
<code>suma'</code>. Esta feature de poder evaluar parcialmente las funciones es lo que se
conoce como <strong>currificación</strong>.</p>
<p><img src="./img/currification.png#center" alt="" /></p>
<p>(No, ese Curry no...)</p>
<p>Veamos cómo se ve esto en ghci:</p>
<pre><code>&gt; :type suma
suma :: Int -&gt; Int -&gt; Int
&gt; :type suma 4
(suma 4) :: Int -&gt; Int
</code></pre>
<p>O sea que puedo definir por ejemplo <code>inc = suma 1</code></p>
<h3 id="viendo-curryuncurry-como-una-función"><a class="header" href="#viendo-curryuncurry-como-una-función">Viendo curry/uncurry como una función</a></h3>
<pre><code class="language-haskell">curry :: ((a, b) -&gt; c) -&gt; (a -&gt; (b -&gt; c))
curry f = \x -&gt; \y -&gt; f (x,y)
-- versión alternativa --
curry f x = \y -&gt; f (x, y)

uncurry :: (a -&gt; b -&gt; c) -&gt; ((a, b) -&gt; c)
uncurry f (a, b) = f x y
</code></pre>
<h2 id="tipos-algebráicos"><a class="header" href="#tipos-algebráicos">Tipos Algebráicos</a></h2>
<p>Puedo definir los tipos por enumeración definiendo:</p>
<ul>
<li>el nombre del tipo</li>
<li>los constructores</li>
</ul>
<pre><code class="language-haskell">data Dia = Lunes | Martes | Miercoles | Jueves | Viernes | Sabado | Domingo

data Bool = True | False
</code></pre>
<p>Los constructores también pueden tener parámetros. En la definición tengo que aclarar los tipos de sus argumentos:</p>
<pre><code class="language-haskell">data Figura = Circulo Float | Rectangulo Float Float
</code></pre>
<p>Algunos ejemplos de tipos:</p>
<ul>
<li><code>Lunes :: Dia</code></li>
<li><code>Circulo 1.0 :: Figura</code></li>
<li><code>Circulo :: Float -&gt; Figura</code></li>
</ul>
<h2 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern matching</a></h2>
<p>Es un mecanismo para comparar un valor con un patrón y deconstruir un valor en
sus partes. Por ejemplo:</p>
<pre><code class="language-haskell">area :: Figura -&gt; Float
area (Circulo radio) = PI * radio^2 
area (Rectangulo base altura) = base * altura
</code></pre>
<p>Si no hay un match directo, lo que va a hacer haskell es seguir reduciendo.
Eventualmente va a matchear o no se va a poder reducir la expresión (y vamos a
tener un error).</p>
<div id="admonition-el-patrón-debe-ser-lineal" class="admonition admonish-info">
<div class="admonition-title">
<p>El patrón debe ser lineal</p>
<p><a class="admonition-anchor-link" href="programacion_funcional.html#admonition-el-patrón-debe-ser-lineal"></a></p>
</div>
<div>
<ul>
<li>
<p><strong>Lineal</strong> quiere decir que una variable debe aparecer una única vez a la izquierda.</p>
<pre><code class="language-haskell">esCuadrado :: Figura -&gt; Bool
esCuadrado (Circulo _) = False
esCuadrado (Rectangulo x y) | x == y =&gt;     = True
                            | otherwise     = False
-- alternativa
esCuadrado (Rectangulo x y) | x == y =&gt;     = True
esCuadrado _                                = False

-- alternativa también valida
esCuadrado (Rectangulo x y) = x == y
esCuadrado _                = False
</code></pre>
</li>
<li>
<p><code>esCuadrado (Rectangulo x x)</code> sería más simple pero no está permitido en
haskell (ej: en erlang/elixir esto es posible)</p>
</li>
</ul>
<p>Observaciones:</p>
<ul>
<li>
<p><code>_</code> coincide con cualquier forma (ver que en la alternativa agarro tanto el caso de <code>Circulo</code> como el de <code>Rectangulo</code> que no es cuadrado)</p>
</li>
<li>
<p>los casos se evalúan en el orden que están escritos</p>
</li>
<li>
<p>Puedo definir funciones parciales:</p>
<pre><code class="language-haskell">-- en este caso radio (Rectangulo _ _) va a dar error
radio (Circulo radio) = radio
</code></pre>
</li>
</ul>
</div>
</div>
<h2 id="tipos-recursivos"><a class="header" href="#tipos-recursivos">Tipos Recursivos</a></h2>
<p>La definición de un tipo tpuede tener uno o más parámetros de tipo:</p>
<pre><code class="language-haskell">data Natural = Zero | Succ Natural

Zero :: Natural
Succ Zero :: Natural
Succ (Succ (Succ Zero)) :: Natural
</code></pre>
<h2 id="listas"><a class="header" href="#listas">Listas</a></h2>
<p>Es un tipo algebráico paramétrico y recursivo con 2 constructores:</p>
<pre><code class="language-haskell">[] :: [a]               -- Constructor de la lista vacía
(:) :: a -&gt; [a] -&gt; [a]  -- Append Front
</code></pre>
<p>Ejemplos de pattern matching:</p>
<pre><code class="language-haskell">esVacia :: [a] -&gt; Bool
esVacia [] = True
esVacia _ = False
</code></pre>
<pre><code class="language-haskell">longitud :: [a] -&gt; Int
longitud [] = 0
longitud (x:xs) _ = 1 + longitud xs
</code></pre>
<h2 id="no-terminación-y-orden-de-evaluación"><a class="header" href="#no-terminación-y-orden-de-evaluación">No terminación y orden de evaluación</a></h2>
<p>Veamos la siguiente función:</p>
<pre><code class="language-haskell">inf1 :: [Int]
inf1 = 1 : inf1
</code></pre>
<p>Se reduce infinitamente, entonces para qué quiero tener algo así? De qué me sirve? Veamos esta función:</p>
<pre><code class="language-haskell">const :: a -&gt; b -&gt; a
const x y = x
</code></pre>
<p>Qué pasa si hago <code>const 42 inf1</code>? Da 42. Pero en realidad depende del mecanismo
de reducción que tenga el lenguaje, porque haskell resuelve primero el pattern
matching en lugar de reducir los parámetros. Si no me quedaba reduciendo
infinitamente.</p>
<h3 id="evaluación-lazy-orden-normal"><a class="header" href="#evaluación-lazy-orden-normal">Evaluación Lazy (Orden Normal)</a></h3>
<ul>
<li>Tiene que ver con el modelo de cómputo que usa haskell, que es el de la
<code>Reducción</code>
<ul>
<li>Se reemplaza un redex (expresión reducible) por otra usando las
ecuaciones orientadas. Un redex es una sub-expresión que no esté en forma
normal.</li>
<li>El redex tiene que ser una instancia del lado izquiero de alguna de las
ecuaciones (si no da error), y se reemplaza por el lado derecho asociando
las variables correspondientes.</li>
<li>El resto de la expresión no cambia</li>
</ul>
</li>
<li>La evaluación Lazy, consiste en seleccionar las funciones más externas y
luego los argumentos (pero sólo si se necesitan)</li>
</ul>
<h2 id="ejercicios"><a class="header" href="#ejercicios">Ejercicios</a></h2>
<h3 id="ejercicio-1"><a class="header" href="#ejercicio-1">Ejercicio 1</a></h3>
<p>Definir <code>dobleL :: [Float] -&gt; Float</code> tal que <code>doble xs</code> es la lista que contiene el doble de cada elemento en xs</p>
<pre><code class="language-haskell">doble [] = []
doble x:xs = (x * 2) : (doble xs)
</code></pre>
<h3 id="ejercicio-2"><a class="header" href="#ejercicio-2">Ejercicio 2</a></h3>
<p>Definir <code>esPar :: [Int] -&gt; [Bool]</code> tal que <code>esParL xs</code> indica si el correspondiente elemento en xs es par o no</p>
<pre><code class="language-haskell">esPar [] = []
esPar x:xs = (even x) : (esPar xs)
</code></pre>
<h3 id="ejercicio-3"><a class="header" href="#ejercicio-3">Ejercicio 3</a></h3>
<p>Definir <code>longL :: [[a]] -&gt; [Int]</code> tal que <code>longL xs</code> es la lista que contiene las longitudes de las listas en xs</p>
<pre><code class="language-haskell">longL [] = []
longL x:xs = (length x) : (longL xs)
</code></pre>
<div id="admonition-generalizando" class="admonition admonish-note">
<div class="admonition-title">
<p>Generalizando...</p>
<p><a class="admonition-anchor-link" href="programacion_funcional.html#admonition-generalizando"></a></p>
</div>
<div>
<ul>
<li>
<p>Notar que en los ejercicios el patrón era siempre el mismo con la diferencia de que en el primero hacíamos <code>* 2</code>, en el segundo <code>even x</code> y en el tercero <code>length x</code></p>
</li>
<li>
<p>Podemos generalizar este comportamiento (gracias funciones de alto orden!) en la siguiente función:</p>
<pre><code class="language-haskell">map :: (a -&gt; b) -&gt; [a] -&gt; [b]
map _ [] = []
map f x:xs = (f x) : (map f xs)
</code></pre>
</li>
<li>
<p>Podemos redefinir las funciones de antes con <code>map</code>:</p>
<pre><code class="language-haskell">-- Ni tengo que agregar el parámetro a la definición!
doble = map (\x -&gt; 2 * x)
esPar = map even
longL = map length
</code></pre>
</li>
</ul>
</div>
</div>
<h3 id="ejercicio-4"><a class="header" href="#ejercicio-4">Ejercicio 4</a></h3>
<p>Definir <code>negativos :: [Float] -&gt; [Float]</code> tal que <code>negativos xs</code> contiene los elementos negativos de xs</p>
<pre><code class="language-haskell">negativos [] = []
negativos x:xs  | x &lt; 0     = x : (negativos xs)
                | otherwise = negativos xs
</code></pre>
<h3 id="ejercicio-5"><a class="header" href="#ejercicio-5">Ejercicio 5</a></h3>
<p>Definir <code>noVacias :: [[a]] -&gt; [[a]]</code> tal que <code>noVacias xs</code> contiene las listas no vacías de <code>xs</code></p>
<pre><code class="language-haskell">noVacias [] = []
noVacias x:xs   | length x &gt; 0     = x : (noVacias xs)
                | otherwise = noVacias xs
</code></pre>
<div id="admonition-generalizando-1" class="admonition admonish-note">
<div class="admonition-title">
<p>Generalizando...</p>
<p><a class="admonition-anchor-link" href="programacion_funcional.html#admonition-generalizando-1"></a></p>
</div>
<div>
<ul>
<li>
<p>Notar que en los ejercicios el patrón era siempre el mismo: el caso base
devuelve vacío, y para el otro chequeo una condición booleana para saber si
agregar o no.</p>
</li>
<li>
<p>Podemos generalizar este comportamiento (gracias funciones de alto orden again!) en
la siguiente función:</p>
<pre><code class="language-haskell">filter :: (a -&gt; Bool) -&gt; [a] -&gt; [b]
filter _ [] = []
filter f x:xs   | (f x)     = x : (filter f xs)
                | otherwise = filter f xs
</code></pre>
</li>
<li>
<p>Podemos redefinir las funciones de antes con <code>filter</code>:</p>
<pre><code class="language-haskell">-- Ni tengo que agregar el parámetro a la definición!
negativos = filter (\x -&gt; x &lt; 0)
noVacias = filter (\x -&gt; length x &gt; 0)
</code></pre>
</li>
</ul>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unidad-2---cálculo-lambda"><a class="header" href="#unidad-2---cálculo-lambda">Unidad 2 - Cálculo Lambda</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cálculo-lambda-tipado-bolleano"><a class="header" href="#cálculo-lambda-tipado-bolleano">Cálculo Lambda Tipado Bolleano</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cálculo-lambda-tipado-extendido"><a class="header" href="#cálculo-lambda-tipado-extendido">Cálculo Lambda Tipado Extendido</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inferencia-de-tipos"><a class="header" href="#inferencia-de-tipos">Inferencia de tipos</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subtipado"><a class="header" href="#subtipado">Subtipado</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unidad-3---programación-funcional"><a class="header" href="#unidad-3---programación-funcional">Unidad 3 - Programación Funcional</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cálculo-sigma"><a class="header" href="#cálculo-sigma">Cálculo Sigma</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cálculo-sigma-1"><a class="header" href="#cálculo-sigma-1">Cálculo Sigma</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unidad-4---programación-funcional"><a class="header" href="#unidad-4---programación-funcional">Unidad 4 - Programación Funcional</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resolución-proposicional"><a class="header" href="#resolución-proposicional">Resolución Proposicional</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resolución-en-lógica-de-primer-orden"><a class="header" href="#resolución-en-lógica-de-primer-orden">Resolución en lógica de primer orden</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resolución-sld"><a class="header" href="#resolución-sld">Resolución SLD</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prolog"><a class="header" href="#prolog">Prolog</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prácticas"><a class="header" href="#prácticas">Prácticas</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guia-0---repaso-haskell"><a class="header" href="#guia-0---repaso-haskell">Guia 0 - Repaso Haskell</a></h1>
<h2 id="ejercicio-1-1"><a class="header" href="#ejercicio-1-1">Ejercicio 1</a></h2>
<p>Dar el tipo y describir el comportamiento de las siguientes funciones del módulo <code>Prelude</code> de Haskell:</p>
<p>Hago un par nomás (recomiendo primero jugar un poco con las funciones y si no les queda claro pueden usar <code>:doc NOMBRE_DE_LA_FUNCIÓN</code>):</p>
<ul>
<li><code>null</code>:</li>
</ul>
<pre><code class="language-haskell">ghci&gt; :type null
null :: Foldable t =&gt; t a -&gt; Bool
ghci&gt; null []
True
ghci&gt; null [1, 2 , 3]
False
</code></pre>
<p>Devuelve si una estructura está vacía o no</p>
<ul>
<li><code>head</code></li>
</ul>
<pre><code class="language-haskell">ghci&gt; :type head
head :: GHC.Stack.Types.HasCallStack =&gt; [a] -&gt; a
ghci&gt; head []
*** Exception: Prelude.head: empty list
CallStack (from HasCallStack):
  error, called at libraries/base/GHC/List.hs:1646:3 in base:GHC.List
  errorEmptyList, called at libraries/base/GHC/List.hs:85:11 in base:GHC.List
  badHead, called at libraries/base/GHC/List.hs:81:28 in base:GHC.List
  head, called at &lt;interactive&gt;:9:1 in interactive:Ghci3
ghci&gt; head [1, 2]
1
</code></pre>
<p>Devuelve el primer elemento de una lista</p>
<ul>
<li><code>take</code></li>
</ul>
<pre><code class="language-haskell">ghci&gt; :type take
take :: Int -&gt; [a] -&gt; [a]
ghci&gt; take 3 [1, 2 , 3, 4]
[1,2,3]
ghci&gt; take 3 [1, 2]
[1,2]
ghci&gt; take 3 []
[]
</code></pre>
<p>Recibe un número <code>n</code> y una lista, y devuelve los primeros <code>n</code> elementos de dicha lista.</p>
<ul>
<li><code>!!</code></li>
</ul>
<pre><code class="language-haskell">ghci&gt; :type (!!)
(!!) :: GHC.Stack.Types.HasCallStack =&gt; [a] -&gt; Int -&gt; a
ghci&gt; [1, 2, 3, 4] !! 2
3
ghci&gt; [1, 2, 3, 4] !! 3
4
ghci&gt; [1, 2, 3, 4] !! 0
1
</code></pre>
<p>Es el operador de indexado.</p>
<h2 id="ejercicio-2-1"><a class="header" href="#ejercicio-2-1">Ejercicio 2</a></h2>
<p>Definir las siguientes funciones:</p>
<ul>
<li><code>valorAbsoluto :: Float -&gt; Float</code> que dado un número devuelve su valor absoluto.</li>
</ul>
<pre><code class="language-haskell">valorAbsoluto :: Float -&gt; Float
valorAbsoluto = abs
</code></pre>
<ul>
<li><code>bisiesto :: Int -&gt; Bool</code> que dado un número que representa un año, indica si el mismo es bisiesto.</li>
</ul>
<pre><code class="language-haskell">bisiesto :: Int -&gt; Bool
bisiesto anio | mod anio 4 == 0 = True
              | otherwise       = False
</code></pre>
<ul>
<li><code>factorial :: Int -&gt; Int</code> definida únicamente para enteros positivos, que computa el factorial.</li>
</ul>
<pre><code class="language-haskell">factorial :: Int -&gt; Int
factorial 1 = 1
factorial n = n * factorial (n-1)
</code></pre>
<ul>
<li><code>cantDivisoresPrimos :: Int -&gt; Int</code>, que dado un entero positivo devuelve la cantidad de divisores primos</li>
</ul>
<pre><code class="language-haskell">valorAbsoluto :: Float -&gt; Float
valorAbsoluto = abs

bisiesto :: Int -&gt; Bool
bisiesto anio | mod anio 4 == 0 = True
              | otherwise       = False

factorial :: Int -&gt; Int
factorial 1 = 1
factorial n = n * factorial (n-1)

cantDivisoresPrimos :: Int -&gt; Int
cantDivisoresPrimos n = cantDivisoresPrimosMenoresA n n

cantDivisoresPrimosMenoresA :: Int -&gt; Int -&gt; Int
cantDivisoresPrimosMenoresA _ 1 = 0
cantDivisoresPrimosMenoresA n divisorCandidato | esPrimo divisorCandidato &amp;&amp; mod n divisorCandidato == 0 = 1 + divisoresMenores
                                               | otherwise                   = divisoresMenores
                                              where divisoresMenores = cantDivisoresPrimosMenoresA n (divisorCandidato - 1)

esPrimo :: Int -&gt; Bool
esPrimo n = cantDivisoresMenoresA n n == 2

cantDivisoresMenoresA :: Int -&gt; Int -&gt; Int
cantDivisoresMenoresA _ 1 = 1
cantDivisoresMenoresA n divisorCandidato | mod n divisorCandidato == 0 = 1 + divisoresMenores
                                         | otherwise                   = divisoresMenores
                                         where divisoresMenores = cantDivisoresMenoresA n (divisorCandidato - 1)
</code></pre>
<h3 id="ejercicio-3-1"><a class="header" href="#ejercicio-3-1">Ejercicio 3</a></h3>
<p>Contamos con los tipos <code>Maybe</code> y <code>Either</code> definidos como sigue:</p>
<pre><code class="language-haskell">data Maybe a = Nothing | Just a
data Either a b = Left a | Right b
</code></pre>
<ul>
<li>Definir la función <code>inverso :: Float -&gt; Maybe Float</code> que dado un número devuelve su inverso multiplicativo si está definido, o <code>Nothing</code> en caso contrario.</li>
</ul>
<pre><code class="language-haskell">inverso :: Float -&gt; Maybe Float
inverso 0.0 = Nothing
inverso x = Just (1.0 / x)
</code></pre>
<ul>
<li>Definir la función <code>aEntero :: Either Int Bool -&gt; Int</code> que convierte a entero una expresión que puede ser booleana o entera. En el caso de los booleanos, el entero que corresponde es 0 para <code>False</code> y 1 para <code>True</code>.</li>
</ul>
<pre><code class="language-haskell">aEntero :: Either Int Bool -&gt; Int
aEntero (Left unEntero) = unEntero
aEntero (Right True) = 1
aEntero (Right False) = 0
</code></pre>
<h3 id="ejercicio-4-1"><a class="header" href="#ejercicio-4-1">Ejercicio 4</a></h3>
<p>Definir las siguientes funciones sobre listas:</p>
<ul>
<li><code>limpiar :: String -&gt; String -&gt; String</code>, que elimina todas las apariciones de cualquier carácter de la primera cadena en la segunda. Por ejemplo, <code>limpiar "susto" "puerta"</code> evalúa a <code>"pera"</code>. Nota: <code>String</code> es un renombre de <code>[Char]</code>. La notación <code>"hola"</code> es equivalente a <code>['h', 'o', 'l', 'a']</code> y a <code>'h':'o':'l':'a':[]</code></li>
</ul>
<pre><code class="language-haskell">limpiar :: String -&gt; String -&gt; String
limpiar [] fromStr = fromStr 
limpiar (unChar:restoDelPatron) fromStr = limpiar restoDelPatron (filter (/= unChar) fromStr) 
</code></pre>
<ul>
<li><code>difPromedio :: [Float] -&gt; [Float]</code> que dada una lista de números devuelve la diferencia de cada uno con el promedio general. Por ejemplo, <code>difPromedio [2, 3, 4]</code> evalúa a <code>[-1, 0, 1]</code>.</li>
</ul>
<pre><code class="language-haskell">difPromedio :: [Float] -&gt; [Float]
difPromedio xs = map (\x -&gt; x - promedioXs) xs
              where promedioXs = promedio xs

promedio :: [Float] -&gt; Float
promedio [] = 0.0
promedio xs = sum xs / fromIntegral (length xs)
</code></pre>
<ul>
<li><code>todosIguales :: [Int] -&gt; Bool</code> que indica si una lista de enteros tiene todos sus elementos iguales.</li>
</ul>
<pre><code class="language-haskell">todosIguales :: [Int] -&gt; Bool
todosIguales [] = True
todosIguales (x:xs) = all (== x) xs
</code></pre>
<h3 id="ejercicio-5-1"><a class="header" href="#ejercicio-5-1">Ejercicio 5</a></h3>
<p>Dado el siguiente modelo para árboles binarios:</p>
<pre><code class="language-haskell">data AB a = Nil | Bin (AB a) a (AB a)
</code></pre>
<p>definir las siguientes funciones:</p>
<ul>
<li><code>vacioAB :: AB a -&gt; Bool</code> que indica si un árbol es vacío (i.e. no tiene nodos)</li>
</ul>
<pre><code class="language-haskell">vacioAB :: AB a -&gt; Bool
vacioAB Nil = True
vacioAB _ = False
</code></pre>
<ul>
<li><code>negacionAB :: AB bool -&gt; AB Bool</code> que dado un árbol de booleanos construye otro formulado por la negación de cada uno de los nodos.</li>
</ul>
<pre><code class="language-haskell">negacionAB :: AB Bool -&gt; AB Bool
negacionAB Nil = Nil
negacionAB (Bin (hijoIzq) nodo (hijoDer)) = Bin (negacionAB hijoIzq) (not nodo) (negacionAB hijoDer)
</code></pre>
<ul>
<li><code>productoAB :: AB Int -&gt; Int</code> que calcula el producto de todos los nodos del árbol</li>
</ul>
<pre><code class="language-haskell">productoAB :: AB Int -&gt; Int
productoAB Nil = 1
productoAB (Bin hijoIzq nodo hijoDer) = productoAB hijoIzq * nodo * productoAB hijoDer
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guia-1---programación-funcional"><a class="header" href="#guia-1---programación-funcional">Guia 1 - Programación funcional</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guia-2---cálculo-lambda-tipado"><a class="header" href="#guia-2---cálculo-lambda-tipado">Guia 2 - Cálculo Lambda Tipado</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guia-3---inferencia-de-tipos"><a class="header" href="#guia-3---inferencia-de-tipos">Guia 3 - Inferencia de Tipos</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guia-4---subtipado"><a class="header" href="#guia-4---subtipado">Guia 4 - Subtipado</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guia-5---programación-orientada-a-objetos"><a class="header" href="#guia-5---programación-orientada-a-objetos">Guia 5 - Programación Orientada a Objetos</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guia-6---resolución-lógica"><a class="header" href="#guia-6---resolución-lógica">Guia 6 - Resolución Lógica</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guia-7---programación-lógica"><a class="header" href="#guia-7---programación-lógica">Guia 7 - Programación Lógica</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bibliografía"><a class="header" href="#bibliografía">Bibliografía</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>
        <script src="theme/pagetoc.js"></script>

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
